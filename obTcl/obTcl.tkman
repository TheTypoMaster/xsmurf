$t insert end "_________________________________________________________________\n\n" {} "NAME\n" h2
$t mark set js1 3.0
$t insert end "       obTcl - A pure-Tcl object oriented extension\n\n" {} "SYNOPSIS\n" h2
$t mark set js2 6.0
$t insert end "       " {} "class" b " " {} "className" i "\n       " {} "className" i " " {} "inherit" b " ?" {} "className" i "...?\n\n       " {} "className" i " " {} "method" b " " {} "methodName" i " " {} "{" b " " {} "args" i " " {} "}" b " " {} "{" b "\n          " {} "instvar" b " ?" {} "varNames..." i "?\n          " {} "iclassvar" b " ?" {} "varNames..." i "?\n          " {} "classvar" b " ?" {} "varNames..." i "?\n          " {} "global" b " ?" {} "varNames..." i "?\n          " {} "next" b " ?" {} "args..." i "?\n          " {} "Tcl" i " " {} "statements" i "\n       " {} "}" b "\n\n       " {} "className" i " " {} "methodName" i " ?" {} "args..." i "?\n\n       " {} "className" i " " {} "new" b " " {} "objName" i " ?" {} "options..." i "?\n       " {} "className" i " " {} "widgetObjName" i " ?" {} "options..." i "?\n\n       " {} "objName" i " " {} "methodName" i " ?" {} "args..." i "?\n\n       " {} "objName" i " " {} "info" b " ?" {} "args..." i "?\n       " {} "objName" i " " {} "set" b " " {} "instvarName" i " ?" {} "value" i "?\n       " {} "objName" i " " {} "eval" b " " {} "script" i "\n\n       " {} "objName" i " " {} "destroy" b "\n       " {} "widgetObjName" i " " {} "destroy" b "\n       " {} "destroy" b " " {} "widgetObjName" i "\n_________________________________________________________________\n\n\n" {} "DESCRIPTION\n" h2
$t mark set js3 36.0
$t insert end "       " {} "obTcl" b "  is an object-oriented extension to Tcl, implemented\n       entirely in standard Tcl.  Much of the functionality  pro-\n       vided is implemented in the Base and Widget classes, which\n       are two standard classes that come with " {} "obTcl" b ".  The  defi-\n       nition  of  these  classes, and their documentation can be\n       found in the file " {} "base.tcl" b ".\n\n       Most of the documentation  can  be  found  throughout  the\n       source files.  It can be conveniently read by starting the\n       " {} "demo" b " program.  If you do not have wish4.0, you  can  start\n       tclsh7.4,  source " {} "obtcl" i ", and type " {} "help" i " to access the docu-\n       mentation.  Otherwise, using " {} "less" i " or  " {} "more" i "  and  searching\n       for  the word " {} "DOC" i " will work too.  I will here only explain\n       matters that are not covered in that documentation.\n\n\n" {} "CLASS DEFINITIONS\n" h2
$t mark set js4 53.0
$t insert end "       Classes are defined by  using  the  " {} "class" b "  keyword.   Each\n       class  consists  of a class object (it is created when the\n       class is defined).  Example:\n\n              class FileSelector\n\n\n       The class object functions as a repository for  class-wide\n       data, and as a central for instantiating objects.\n" {}
update idletasks
$t insert end "\n       Most methods are used from instantiated objects, but it is\n       also possible to create  methods  which  are  to  be  used\n       directly from the class object, here called " {} "class" i " " {} "methods" i ".\n       Many class methods are actually defined in the Base class,\n       whereas  some  class methods are hard-coded into the class\n       object.\n\n       The class method " {} "inherit" b " is used  to  define  which  other\n       classes  to  inherit  from.   The " {} "Base" i " class need never be\n       specified explicitly.  Using " {} "inherit" b " without any arguments\n       returns the current inheritance list.  The specified order\n       of inherited classes  has  significance;  the  inheritance\n       list  is searched from left to right during method resolu-\n       tion.  Example:\n\n              class FileSelector\n              FileSelector inherit Widget\n\n\n       The class method " {} "method" b " is used to define new methods  for\n       the class.  Example:\n\n              FileSelector method getFile { {dir \".\"} } {\n                   set files \[exec ls \$dir\]\n                   # More code needed..\n              }\n\n\n       Another commonly used class method is " {} "option" b " which is used\n       to define class wide option handlers. See  the  documenta-\n       tion  on " {} "class" i " " {} "Base" i " for more information about option han-\n       dlers.\n\n\n" {} "OBJECT CREATION\n" h2
$t mark set js5 98.0
$t insert end "       To instantiate an object, the class name is used, followed\n       by the method " {} "new" b " and the name of the object.  For objects\n       whose names begin with a period,  \".\",  " {} "new" b "  need  not  be\n       specified.  Example:\n\n              Base new foo            ;# Create the simple object foo\n              Widget .bar -width 200  ;# Create the Widget object .bar\n\n\n       For   each  newly  created  object,  the  method  " {} "init" b "  is\n       automatically invoked.  If it does not exist,  any  inher-\n       ited  " {} "init" b "  will  be  invoked.   " {} "init" b "  should  normally be\n       defined, and it should normally use the  special  function\n       " {} "next" b "  to  allow  initialization  of any super-classes (see\n       " {} "INHERITANCE" sc ").  Sample definition:\n\n              class TwoButtons\n              TwoButtons inherit Widget\n\n              TwoButtons method init { args } {\n\n                   next     ;# Get frame widget\n\n                   button \$self.b1 -text \"Button 1\"\n                   button \$self.b2 -text \"Button 2\"\n                   pack \$self.b1 \$self.b2 -in \$self\n              }\n\n\n\n" {} "INHERITANCE\n" h2
$t mark set js6 129.0
$t insert end "       All classes inherit methods from the " {} "Base" b " class.  In addi-\n       tion  they inherit methods from classes specified with the\n       " {} "inherit" b " class method.  Multiple inheritance can  be  used.\n       Method  lookup  follows  a depth-first tree search, so all\n       methods inherited through the first  specified  class  are\n       searched, before searching the second inherited class, and\n       so on.  Once a method is located, a cache-method  is  cre-\n       ated  in the object's own class.  Thus, subsequent invoca-\n       tions will be as fast as a normal method invocation.\n\n       Should classes be  redefined  in  any  way,  the  affected\n       cache-methods  are  automatically  removed, thus forcing a\n       new lookup.\n\n       The special function " {} "next" b " can be used  to  call  the  next\n       shadowed  method.  " {} "next" b " can be used anywhere in the method\n       body.  For example, classes derived from the class  " {} "Widget" i "\n       might  want  to  call " {} "next" b " early on in the " {} "init" i " method, to\n       get the frame widget created.  Arguments  passed  to  " {} "next" b "\n       are  interpreted  as  if  they  were  passed to the method\n       explicitly.  It is valid to use " {} "next" b " even if  no  shadowed\n       method  exists.   If  several shadowed methods exist, " {} "next" b "\n       will call them all, one after the other. " {} "next" b "  also  makes\n       sure  that  multiple  inheritance paths to the same method\n       does not result in multiple invocations of that method.\n\n       It is especially important to call " {} "next" b " from  any  " {} "destroy" b "\n       method.   In this case " {} "next" b " should normally be called just\n       before returning.  If the " {} "Base" i " class'  " {} "destroy" b "  method  is\n       not invoked, some object data will not be freed.\n\n       The method " {} "unknown" b " can be used to catch all invocations of\n       un-resolvable methods.  " {} "unknown" b "  is  only  invoked  if  no\n       matching  method  can  be found throughout the inheritance\n       tree.  The Base class defines " {} "unknown" b " to produce an  error\n       message,  whereas the Widget class uses it to direct meth-\n       ods to the objects main widget.  An analogous approach  is\n       used  for unknown options.  See the documentation on " {} "class" i "\n       " {} "Base" i " and " {} "class" i " " {} "Widget" i ".\n\n\n" {} "METHOD ENVIRONMENT\n" h2
$t mark set js7 171.0
$t insert end "       During execution of a method, the following variables  are\n       set:\n\n       " {} "self" b "   The  name of the object on whose behalf we are exe-\n              cuting the method.\n\n       " {} "method" b " The name of  the  method  that  we  are  executing.\n              Especially  useful  in  the " {} "unknown" b " method, to find\n              out the name of the requested method.\n\n       " {} "iclass" b " The name of the class of the object.\n\n       " {} "class" b "  The name of the  class  in  which  this  method  is\n              defined.\n\n       These  variables  should  not be altered in any way, since\n       obTcl relies on them for various things.\n\n\n" {} "METHOD INVOCATION\n" h2
$t mark set js8 191.0
$t insert end "       Methods are invoked by calling the object  with  a  method\n       name as the first parameter.  Any parameters following the\n       method name are passed on to the method.  This follows the\n       style used in the Tk extension.\n\n       Example:\n\n               Widget .foo                ;# Create the object .foo\n               .foo configure -width 300  ;# Call method configure\n\n\n       Calling  methods  from  within  a  method is done by using\n       " {} "\$self" b ".  Example:\n\n               \$self openFile \"/tmp/foo\"\n\n\n       Within method definitions, an alternative  way  to  invoke\n       methods is available. Example:\n\n               \$class::openFile \"/tmp/foo\"\n\n\n       where  class can be either the variable \$class, or explic-\n       itly specified.  This method  is  faster  than  the  first\n       method,  but,  as  mentioned, can only be used from within\n       the methods of the class implementation.\n\n       Note:  Using the " {} "\$self" i " " {} "method" i "  style  of  calling  methods\n              allows    them    to   be   virtual.    Using   the\n              " {} "\$class::method" i " style  disables  lookup  of  virtual\n              methods.  See " {} "VIRTUAL" i " " {} "METHODS" i " below for more infor-\n              mation.  The " {} "class::method" i " style of method  invoka-\n              tion  can also be used to specify the wanted method\n              in situations where methods inherited via  multiple\n              inheritance  have  conflicting  names.  Again, note\n              that this call syntax can only be used from  " {} "within" i "\n              a method.\n\n\n" {} "VIRTUAL METHODS\n" h2
$t mark set js9 232.0
$t insert end "       When  using  the  method  invokation  syntax " {} "\$self" i " " {} "method" i ",\n       method lookup  starts  from  the  class  of  the  instance\n       object,  searching  the  iheritance tree until a method is\n       found.  This means that methods are  virtual  by  default.\n       When   this   is  undesirable,  invoke  the  method  using\n       " {} "\$class::method" i ", as described above.  To invoke  a  virtual\n       method  using  this  syntax (i.e. for performance reasons)\n       use the " {} "iclass" i " variable: " {} "\$iclass::method" i ".\n\n       Here follows an example of using a virtual method:\n\n              class Low\n              Low method foo {} {\n                   \$self high_life       ;# Call virtual method\n                   \$iclass::high_life    ;# Call virtual method\n                   \$class::high_life     ;# Calling `Low::high_life'\n              }\n              Low method high_life {} {\n\n                   # If no method was defined, catch error here\n                   #\n                   error \"Error: no `high_life' in class: \$iclass\"\n" {}
update idletasks
$t insert end "              }\n\n              class High\n              High inherit Low\n\n              High method high_life {} {\n                   puts \"High::high_life was called!\"\n              }\n\n\n\n" {} "STORAGE CLASSES\n" h2
$t mark set js10 266.0
$t insert end "       " {} "obTcl" b " adds several new storage classes to Tcl.   They  are\n       all implemented by the usage of " {} "upvar" i " to the global scope,\n       and prefixing the variable  name  with  class  and  object\n       information.   Once  " {} "upvar" i ":ed,  there  is  no  performance\n       penalty (on the contrary, using  short  " {} "instvar" b "  names  is\n       probably  often  better  than using longer global variable\n       names, as one tends to do in traditional Tcl-programming).\n       Since  Tcl  handles multiple-step upvaring gracefully, and\n       upvaring of arrays  as  well,  these  obTcl-variables  are\n       totally transparent to the user.\n\n       Instance  variables are declared with the " {} "instvar" b " keyword.\n       Instance variables are local to the  object,  but  can  be\n       shared by all methods within the same object.\n\n       Class  variables  are shared amongst all objects of a spe-\n       cific  class.   Class  variables  come  in  two   flavors:\n       instance  class scoped variables, declared with " {} "iclassvar" b ",\n       and  definition  class  scoped  variables,  declared  with\n       " {} "classvar" b ".   Instance  class  scoped  variables take on the\n       calling object's class, thus allowing the same implementa-\n       tion being inherited by various classes, all of which will\n       have a different set of  data.   Definition  scoped  class\n       variables,  on  the other hand, are tied to the class they\n       are defined in, and all inheriting classes will share  the\n       same class variables.\n\n       All  access  to  these  variables  requires  the method to\n       declare the variables using " {} "instvar" b ", " {} "iclassvar" b " and  " {} "class-" b "\n       " {} "var" b " respectively.\n\n       Global variables are accessible as usual by declaring them\n       with " {} "global" b ".\n\n       A note about " {} "instvar" b ":\n       Instvars are unique to the  class  they  are  defined  in.\n       This means that the instance variable " {} "foo" b " defined in class\n       " {} "A" b " is not connected to the instance variable " {} "foo" b " defined in\n       class  " {} "B" b ".   The  reason for this is to avoid unintentional\n       clobbering of data.  Some of the Base class methods  over-\n       ride  this  protection by explicitly changing their \$class\n       variable.  I might introduce a " {} "public" b "  storage  class,  or\n       similar, to avoid this kludge.\n\n\n" {} "MEGA WIDGETS\n" h2
$t mark set js11 312.0
$t insert end "       It  is  possible  to create classes of mega widgets, which\n       can be  used  transparently  together  with  ordinary  Tk-\n       widgets.   This is done by inheriting from the obTcl class\n       " {} "Widget" b ".\n\n       When creating objects from such classes, just  follow  the\n" {}
update idletasks
$t insert end "       normal  Tk-naming  conventions  for Tk-widgets; i.e parent\n       objects must exist, all names start with a lower case let-\n       ter, and are separated by \".\".\n\n\n       Note:  The  mega  widget object always uses a Tk-widget as\n\n              its main widget.  After it has created this  widget\n              it renames it to " {} "\$self-cmd" i ".  This is not visible to\n              users of the mega  widget,  but  can  be  an  issue\n              within  the implementation of the mega widget.  For\n              example, when  the  mega  widget  itself  needs  to\n              manipulate  the Tk-widget, it must use the Tk name:\n              " {} "\$self-cmd" i ".\n\n       Example of referring to " {} "\$self-cmd" i ":\n\n              class TwoButtons\n              TwoButtons inherit Widget\n\n              TwoButtons method init { args } {\n\n                   next     ;# Get frame widget\n\n                   # Call the configure command for the frame\n                   #\n                   eval \$self-cmd configure \$args\n\n                   button \$self.b1 -text \"Button 1\"\n                   button \$self.b2 -text \"Button 2\"\n                   pack \$self.b1 \$self.b2 -in \$self\n              }\n\n              TwoButtons .twoB   ;# Create an instance\n              pack .twoB -in .   ;# Pack it\n\n\n\n" {} "BUGS\n" h2
$t mark set js12 357.0
$t insert end "       See the " {} "README" sc " file for non-squashed bugs.  As the version\n       number  indicates,  some needed functionality may be lack-\n       ing.\n\n\n" {} "AUTHOR\n" h2
$t mark set js13 363.0
$t insert end "       Please direct comments, ideas, complaints, etc. to:\n\n              patrik@dynas.se\n\n\n       Patrik Floding\n       DynaSoft " {} "AB" sc "\n\n\n" {} "Header and Footer\n" h2
$t mark set headfoot 2683.0
$t insert end {obTcl(3)                                                 obTcl(3)} sc \n
$t insert end {1} sc \n
