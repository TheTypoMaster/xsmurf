<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- Generated by TclDoc 0.3 -->
<html>
<head><title>target.tcl</title></head>
<body bgcolor="#ffffff">
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#target.tcl">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a>
</font>
<hr>
<strong>target.tcl</strong>
(<a href="target.tcl-annot.html">annotations</a> | <a href="target.tcl.txt">original source</a>)
<p>
<pre>
<font color="#208020"># target.tcl --</font>
<font color="#208020">#</font>
<font color="#208020">#       This file implements the Tcl code for a kind target system &#34;a la&#34; make.</font>
<font color="#208020">#</font>
<font color="#208020">#   Copyright 1999 Centre de Recherche Paul Pascal, Bordeaux, France.</font>
<font color="#208020">#   Written by Nicolas Decoster.</font>
<font color="#208020">#</font>
<font color="#208020">#  RCS : $Id: target.tcl,v 1.18 1999/03/24 15:18:59 decoster Exp $</font>
<font color="#208020">#</font>

<font color="#208020"># target --</font>
<font color="#208020"># Package target :</font>
<font color="#208020">#</font>
<font color="#208020">#   This package handles a kind of target system &#34;a la&#34; make. Here is the list</font>
<font color="#208020"># of the commands :</font>
<font color="#208020">#   help</font>
<font color="#208020">#   def</font>
<font color="#208020">#   make</font>
<font color="#208020">#   isMade</font>
<font color="#208020">#   msg</font>

<font color="#208020"># target example --</font>
<font color="#208020">#   Here is an example of what you can do with the target package :</font>
<font color="#208020"># </font>
<font color="#208020"># set vlo 0</font>
<font color="#208020"># </font>
<font color="#208020"># tg def gah1 {</font>
<font color="#208020">#     set f [open @tg@ w]</font>
<font color="#208020">#     puts $f &#34;hahaha&#34;</font>
<font color="#208020">#     close $f</font>
<font color="#208020"># }</font>
<font color="#208020"># </font>
<font color="#208020"># tg def gah2 {</font>
<font color="#208020">#     tg make gah1</font>
<font color="#208020">#     set f [open @tg@ w]</font>
<font color="#208020">#     puts $f &#34;hohoho $vlo&#34;</font>
<font color="#208020">#     close $f</font>
<font color="#208020"># }</font>
<font color="#208020"># </font>
<font color="#208020"># tg def {tag hag} {</font>
<font color="#208020">#     tg make gah2</font>
<font color="#208020">#     tg msg &#34;@tg@ is mlaha&#34;</font>
<font color="#208020"># }</font>
<font color="#208020">#</font>
<font color="#208020"># for {set i 0} {$i &lt; 4} {incr i} {</font>
<font color="#208020">#     tg def blah$i {</font>
<font color="#208020"># 	set f [open @tg@ w]</font>
<font color="#208020"># 	puts $f @$i@</font>
<font color="#208020"># 	close $f</font>
<font color="#208020">#     }</font>
<font color="#208020"># }</font>
<font color="#208020"># </font>
<font color="#208020"># tg make hag</font>
<font color="#208020"># tg make blah0</font>
<font color="#208020"># tg make blah1</font>
<font color="#208020"># tg make blah2</font>
<font color="#208020"># tg make blah3</font>

package provide target 0.2

namespace eval target {
    variable typeLst {file tag}
    variable msgCmd target::newPuts
    variable targetLevel 0
    variable nCol 80
    variable currCol 0
    variable isNoNewLine no
}


<font color="#208020"># tg --</font>
<font color="#208020"># usage : tg args</font>
<font color="#208020">#</font>
<font color="#208020">#   Execute a script in the target namespace.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   args - a list of arg.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Result of the execution.</font>

<strong><a name="tg_82">proc <a href="target.tcl-annot.html#tg">tg</a></a></strong><a name="tg"></a> args {
    if {[llength $args] != 0} {
	set cmd [concat namespace inscope target $args]
	set code [catch {eval $cmd} result]
	if {$code != 0} {
	    return -code error $result
	} else {
	    return $result
	}
    }
}


<font color="#208020"># target::help --</font>
<font color="#208020"># usage : target::help [proc]</font>
<font color="#208020">#</font>
<font color="#208020">#   Get help on target pakage.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   [proc] - help on a proc.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Help message.</font>

<strong><a name="target::help_106">proc <a href="target.tcl-annot.html#target::help">target::help</a></a></strong><a name="target::help"></a> args {
    return {no help for now}
}


<font color="#208020"># target::CheckTid - PRIVATE</font>
<font color="#208020"># usage : target::CheckTid tid</font>
<font color="#208020">#</font>
<font color="#208020">#   Check if a target id is valid.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   tid - the target id.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   1 if valid, 0 otherwise.</font>

<strong><a name="target::CheckTid_122">proc <a href="target.tcl-annot.html#target::CheckTid">target::CheckTid</a></a></strong><a name="target::CheckTid"></a> {tid} {
    if [array exists target::tg_$tid] {
	return 1
    } else {
	return 0
    }
}


<font color="#208020"># target::def --</font>
<font color="#208020"># usage : target::def {[type] tid} script</font>
<font color="#208020">#</font>
<font color="#208020">#   Define a target. If this target is allready defined with exactly the same</font>
<font color="#208020"># script, the target (and its state) is not changed. So if it is allready made</font>
<font color="#208020"># subsequent calls of tg make will do nothing.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   [type] - Type of the target.</font>
<font color="#208020">#   tid    - Identifier of the target.</font>
<font color="#208020">#   script - The script to execute to make the target. Any &#34;@tg@&#34; sequence in</font>
<font color="#208020">#            the script is replaced by the target identifier string. Any</font>
<font color="#208020">#            &#34;@$varName@&#34; is replaced by the value of var &#34;varName&#34; in a higher</font>
<font color="#208020">#            level (i.e. while calling target::def).</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="target::def_149">proc <a href="target.tcl-annot.html#target::def">target::def</a></a></strong><a name="target::def"></a> {tid scr} {

    <font color="#208020"># Extract the tid and the type.</font>

    switch [llength $tid] {
	1 {
	    set type file
	}
	2 {
	    variable typeLst

	    set type [lindex $tid 0]
	    if {[lsearch $typeLst $type] == -1} {
		return -code error &#34;wrong tid type&#34;
	    }
	    set tid [lindex $tid 1]
	}
	default {
	    return -code error &#34;wrong tid description&#34;
	}
    }

    <font color="#208020"># Create the (array) variable associated to the target.</font>

    variable tg_$tid
    upvar 0 tg_$tid target

    <font color="#208020"># Parse the script to replace key words by there value.</font>

    regsub -all {@tg@} $scr $tid scr

    while {[regexp {@\$([a-zA-Z0-9_]|{[.]})*@} $scr string] == 1} {
	set firstI 2
	set lastI [expr { [string length $string] - 2 }]
	set varName [string range $string $firstI $lastI]
	upvar $varName theVar
	set exp [format &#34;@\\$%s@&#34; $varName]
	regsub -all $exp $scr $theVar scr
    }

    <font color="#208020"># Get the dependency list by looking to &#34;tg make&#34; in it.</font>

    set allwaysMakeIt no
    set dependLst {}
    set tmpScr $scr

    <font color="#208020"># We remove comments from the script.</font>

    set exp [format &#34;#\[^%s.\]*&#34; &#34;\n&#34;]
    regsub -all $exp $scr {} tmpScr

    <font color="#208020"># Loop on each occurence of the &#34;tg make ...&#34; in the script.</font>

    set exp [format &#34;(tg make \[^($|%s)\]*)&#34; &#34;\n&#34;]
    while {[regexp $exp $tmpScr string] == 1} {
	regexp -indices $exp $tmpScr indices
	set firstI [lindex $indices 0]
	set lastI [lindex $indices 1]
	set tmpScr [string range $tmpScr [expr $lastI+1] end]
	set theTarget [lindex $string 2]

	<font color="#208020"># If there is a '$' in this dependency name, we can't figure what is the</font>
	<font color="#208020"># real name of it. So by default, there will be no dependencies for the</font>
	<font color="#208020"># current target, and we will allways make the current target.</font>

	if {[regexp {\$} $theTarget] == 1} {
	    set allwaysMakeIt yes
	    set dependLst {}
	    break
	}
	set dependLst [concat $dependLst $theTarget]
    }

    if { ([info exists target(makeScr)] == 0) \
	    || ([string compare $target(makeScr) $scr] != 0) } {
	if {$type == &#34;file&#34; &amp;&amp; [file exists $tid] == 1} {
	    set zeDate [file mtime $tid]
	} else {
	    set zeDate undefined
	}
	array set target [list \
		tid		$tid \
		date		$zeDate \
		type		$type \
		makeScr		$scr \
		allwaysMakeIt	$allwaysMakeIt ]
	if {$allwaysMakeIt == &#34;no&#34;} {
	    array set target [list dependLst $dependLst]
	}
    }

    return
}


<font color="#208020"># target::make --</font>
<font color="#208020"># usage : target::make tidLst</font>
<font color="#208020">#</font>
<font color="#208020">#   Execute the script associated to a target, if the target is not allready made.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   tidLst - List of target's identifier.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Result of the script.</font>

<strong><a name="target::make_255">proc <a href="target.tcl-annot.html#target::make">target::make</a></a></strong><a name="target::make"></a> {tidLst} {
    variable msgCmd
    variable targetLevel

    set result {}
    foreach tid $tidLst {
	if {[CheckTid $tid] == 0} {
	    return -code error &#34;wrong target id ($tid)&#34;
	}
	variable tg_$tid
	upvar 0 tg_$tid target

	if {[<a name="target::isMade(1)"><a href="./target.tcl.html#target::isMade_299">target::isMade</a></a> $tid] == 0} {
	    msg -beginofline &#34;make $tid...&#34;
	    incr targetLevel
	    set code [catch {uplevel 3 $target(makeScr)} result]
	    incr targetLevel -1
	    if {$code == 0} {
		array set target [list date [clock seconds]]
		msg -beginofline &#34;$tid ok.&#34;
	    } else {
		msg -beginofline &#34;error while making $tid.&#34;
		return -code error $result
	    }
	} else {
	    msg -beginofline &#34;$tid allready made.&#34;
	}
    }

    return $result
}


<font color="#208020"># target::isMade --</font>
<font color="#208020"># usage : target::isMade tid date</font>
<font color="#208020">#</font>
<font color="#208020">#   Check if we must make a target or not (according to its dependencies).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   tid - Tid of the target.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   1 if target is made, 0 otherwise.</font>

<strong><a name="target::isMade_299">proc <a href="target.tcl-annot.html#target::isMade">target::isMade</a></a></strong><a name="target::isMade"></a> {tid {date &#34;&#34;}} {
    if {[CheckTid $tid] == 0} {
	return -code error &#34;wrong target id ($tid)&#34;
    }
    variable tg_$tid
    upvar 0 tg_$tid target

    if {$target(allwaysMakeIt) == &#34;yes&#34;} {
	return 0
    }
    switch $target(type) {
	file {
	    if {[file exists $target(tid)] == 0} {
		return 0
	    }
	    if {$date != &#34;&#34;} {
		if {[file mtime $target(tid)] &gt;= $date} {
		    return 0
		}
	    }
	}
	tag {
	    if {$target(date) == &#34;undefined&#34;} {
		return 0
	    }
	    if {$date != &#34;&#34;} {
		if {$target(date) &gt;= $date} {
		    return 0
		}
	    }
	}
    }

    <font color="#208020"># Check each dependency.</font>

    if {[llength $target(dependLst)] != 0} {
	foreach newTid $target(dependLst) {
	    if {[isMade $newTid $target(date)] == 0} {
		return 0
	    }
	}
    } else {
	return 1
    }
}


<font color="#208020"># target::msg --</font>
<font color="#208020"># usage : target::msg str</font>
<font color="#208020">#</font>
<font color="#208020">#   Set a message in a way determined by the &#34;msgCmd&#34; package variable.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   str - The string for the message.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="target::msg_357">proc <a href="target.tcl-annot.html#target::msg">target::msg</a></a></strong><a name="target::msg"></a> args {
    variable msgCmd

    set theCmdLine [concat $msgCmd $args]
    catch $theCmdLine
}


<font color="#208020"># target::newPuts -- PRIVATE</font>
<font color="#208020"># usage : target::newPuts [-nonewline] [-beginofline] str</font>
<font color="#208020">#</font>
<font color="#208020">#   Puts the date, several spaces (depending on target level) and a message.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   str - The string for the message.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -nonewline : No new line at the end of the line.</font>
<font color="#208020">#   -beginofline : Force the string to be put at the beginning of the line even</font>
<font color="#208020">#      if target::newPuts was previous called with -nonewline.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="target::newPuts_381">proc <a href="target.tcl-annot.html#target::newPuts">target::newPuts</a></a></strong><a name="target::newPuts"></a> args {
    variable targetLevel
    variable isNoNewLine
    variable nCol
    variable currCol

    set willBeNoNewLine no

    <font color="#208020"># Arguments analysis</font>

    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -nonewline {
		set willBeNoNewLine yes
		set args [lreplace $args 0 0]
	    }
	    -beginofline {
		if {$isNoNewLine == &#34;yes&#34;} {
		    set isNoNewLine no
		    puts &#34;&#34;
		}
		set args [lreplace $args 0 0]
	    }
	    default {
		break
	    }
	}
    }

    if {[llength $args] != 1} {
	return -code error &#34;wrong number of arguments&#34;	
    }
    set msgStr [lindex $args 0]

    if {$isNoNewLine == &#34;no&#34;} {
	catch {exec date +%H.%M.%S} dateStr
	puts -nonewline $dateStr
	puts -nonewline &#34; &#34;
	set currCol 9

	for {set i 0} {$i &lt; $targetLevel} {incr i} {
	    puts -nonewline &#34;  &#34;
	    incr currCol 2
	}
    } else {
	if {($currCol + [string length $msgStr]) &gt; $nCol} {
	    puts &#34;&#34;
	    catch {exec date +%H.%M.%S} dateStr
	    puts -nonewline $dateStr
	    puts -nonewline &#34; &#34;
	    set currCol 9

	    for {set i 0} {$i &lt; $targetLevel} {incr i} {
		puts -nonewline &#34;  &#34;
		incr currCol 2
	    }
	}
    }
    if {$willBeNoNewLine == &#34;no&#34;} {
	puts $msgStr
    } else {
	puts -nonewline $msgStr
	incr currCol [string length $msgStr]
    }

    set isNoNewLine $willBeNoNewLine

    flush stdout

    return
}

</pre>
<hr>
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#byfilename">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a><br>
<cite>File generated 2008-04-03 at 09:49.</cite>
</font>
</body>
</html>
