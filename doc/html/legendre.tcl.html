<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- Generated by TclDoc 0.3 -->
<html>
<head><title>legendre.tcl</title></head>
<body bgcolor="#ffffff">
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#legendre.tcl">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a>
</font>
<hr>
<strong>legendre.tcl</strong>
(<a href="legendre.tcl-annot.html">annotations</a> | <a href="legendre.tcl.txt">original source</a>)
<p>
<pre>
<font color="#208020"># packageName.tcl --</font>
<font color="#208020">#</font>
<font color="#208020">#       This file implements the Tcl code for legendre transform.</font>
<font color="#208020">#</font>
<font color="#208020">#   Copyright 1999 Centre de Recherche Paul Pascal, Bordeaux, France.</font>
<font color="#208020">#   Written by Nicolas Decoster.</font>
<font color="#208020">#</font>
<font color="#208020">#  RCS: $Id: legendre.tcl,v 1.5 1999/06/25 19:55:47 decoster Exp $</font>
<font color="#208020">#</font>

package provide legendre 0.0

package require steph 0.0
package require tools 0.0

<font color="#208020"># legendre --</font>
<font color="#208020"># usage: legendre signal string</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the legendre transform of a signal. Old version, kept for backward</font>
<font color="#208020"># compatibility. Use the new command (which name is certainly legendre2).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal - Signal to transform.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Names of the 3 resulting signals.</font>

<strong><a name="legendre_28">proc <a href="legendre.tcl-annot.html#legendre">legendre</a></a></strong><a name="legendre"></a> {zeSig {order 3} {dhName &#34;&#34;}} {
    <font color="#208020"># h(q)	h$zeSig</font>

    if {[catch [list ginfo $zeSig -list]] == 1} {
	return -code error &#34;can't read \&#34;$zeSig\&#34;: no such signal&#34;
    }

    if {$dhName == &#34;&#34;} {
	set dhName dh$zeSig
    }

    set dName [<a name="getObjName(1)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    s2fs $zeSig $dName x 0.05*abs(x)+.01

    set orderLst {}
    for {set i 0} {$i &lt; $order} {incr i} {
	lappend orderLst 0
    }
    set valName [<a name="getObjName(2)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    screate $valName 0 1 $orderLst

    set fName [<a name="getObjName(3)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    screate f$zeSig 0 1 [sgetlst $zeSig -x]
    
    set resName [<a name="getObjName(4)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    polyf $zeSig $dName $valName $resName -fit f$zeSig
    sderiv f$zeSig h$zeSig

    <font color="#208020"># We verifie that h(q) is always decreasing</font>

    set uuu [<a name="getObjName(5)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    sderiv h$zeSig $uuu
    set i 0
    sigloop $uuu {
        if {$y &gt; 0.0} {
            break
        }
        incr i
    } 

    set imin [expr { $i - 2 }]
    set imax [expr { $i + 1 }]
    set xmin [lindex [sget f$zeSig $imin] 1]  
    set xmax [lindex [sget f$zeSig $imax] 1]  

    sthresh f$zeSig $uuu $xmin $xmax

    set s [<a name="getObjName(6)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    s2fs $uuu $s x .00001

    set newf [<a name="getObjName(7)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    screate $newf 0 1 [sgetlst $zeSig -x]

    sthresh $newf $newf $imin 1000

    set v [<a name="getObjName(8)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    screate $v 0 1 $orderLst
    set r [<a name="getObjName(9)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    polyf $uuu $s $v $r -fit $newf
    set xx [expr { $xmin - 0.001 }]
    sthresh f$zeSig f$zeSig -100 $xx
    scolle f$zeSig $newf f$zeSig
    sderiv f$zeSig h$zeSig

    set temp [<a name="getObjName(10)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    s2fs h$zeSig $temp x y*x

    sthresh f$zeSig f$zeSig -11 10.2

    scut f$zeSig $uuu 0 1

    scomb $temp $uuu x-y $uuu
    smerge h$zeSig $uuu $dhName

    <font color="#208020"># Clean objects created by getObjName.</font>

    delete $dName
    delete $valName
    delete $resName
    delete $uuu
    delete $s
    delete $newf
    delete $v
    delete $r
    delete $temp

    return [list f$zeSig h$zeSig $dhName]
}


<font color="#208020"># legendre2 --</font>
<font color="#208020"># usage: legendre2 signal [-dh str] [-tqfit str] [-hq str] [-qsig str] [-order int] [-fit int]</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the legendre transform of a signal. Here is the formula (and</font>
<font color="#208020"># notations): D(h) = min (q * h - tau(q)). To estimate the value of h for each</font>
<font color="#208020"># value of q, we fit tau(q) around the value of q and we take the numerical</font>
<font color="#208020"># derivative of this fit on q.</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   signal - Signal to transform.</font>
<font color="#208020">#</font>
<font color="#208020"># Options:</font>
<font color="#208020">#   -dh string: Gives the name of D(h) signal. Default is dh$tq, where $tq is</font>
<font color="#208020">#      the name of tau(q).</font>
<font color="#208020">#   -tqfit string: Gives the name of the signal that contains the fit of tau(q).</font>
<font color="#208020">#      Which must be extremly similar to the input signal. Default is fit$tq,</font>
<font color="#208020">#      where $tq is the name of tau(q).</font>
<font color="#208020">#   -hq string: Gives the name of h(q) signal. Default is hq$tq, where $tq is</font>
<font color="#208020">#      the name of tau(q).</font>
<font color="#208020">#   -qsig string: Gives the name of the signal that contains the values of q for</font>
<font color="#208020">#      wich we have to compute D(h). Default is q$tq, where $tq is the name of</font>
<font color="#208020">#      tau(q).</font>
<font color="#208020">#   -order int: Gives the order of the fit. Default is 3.</font>
<font color="#208020">#   -fit int: Gives the number of points to take befare and after each q for the</font>
<font color="#208020">#      fit. Default is 2.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Names of the 4 resulting signals: D(h), fit of tau(q), h(q) and values of q.</font>

<strong><a name="legendre2_147">proc <a href="legendre.tcl-annot.html#legendre2">legendre2</a></a></strong><a name="legendre2"></a> {<a name="tq(1)"><a href="./part_fcts.tcl.html#tq_378">tq</a></a> args} {
    <font color="#208020"># Default values.</font>

    set dh dh$tq
    set tqfit fit$tq
    set hq hq$tq
    set qsig q$tq
    set order 3

    <font color="#208020"># Number of points to take before and after each q to estimate the fit.</font>
    set m 2


    <font color="#208020"># Arguments analysis</font>

    set oldArgs $args
    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -dh {
		set dh [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -tqfit {
		set tqfit [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -hq {
		set hq [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -qsig {
		set qsig [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -order {
		set order [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -fit {
		set m [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    <font color="#208020"># Treatment.</font>


    set orderSig2 [<a name="getObjName(11)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    set orderSig [<a name="getObjName(12)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    set tmp [<a name="getObjName(13)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    set error [<a name="getObjName(14)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]
    set qValues [<a name="getObjName(15)"><a href="./tools.tcl.html#getObjName_113">getObjName</a></a>]

    <font color="#208020"># polyf command needs a signal that contains &#34;order&#34; points.</font>
    set orderLst {}
    for {set i 0} {$i &lt; $order} {incr i} {
	lappend orderLst 0
    }
    screate $orderSig2 0 1 $orderLst

    set n [ssize $tq]
    set iMin $m
    set iMax [expr { $n-$m }]

    if {$iMax &lt; $iMin} {
	return -code error &#34;signal to transform is too small&#34;
    }

    set qLst [list]
    set hLst [list]
    set DLst [list]
    set tauLst [list]

    for {set i $iMin} {$i &lt; $iMax} {incr i} {
	<a name="lassign(1)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {tau q} [sget $tq $i]
	lappend qLst $q

	<font color="#208020"># Get the piece of signal to fit. Around the point q.</font>
	scut $tq $tmp \
		[expr { $i - $m }] \
		[expr { $n - ($i + $m) - 1 }]

	<a name="lassign(2)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {gah qMin} [sget $tmp 0]
	<a name="lassign(3)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {gah qMax} [sget $tmp [expr { 2*$m }]]

	s2fs $tmp $error x 0.005*abs(x)+.00001
	scopy $orderSig2 $orderSig

	<font color="#208020"># To compute the derivative in the point q, we only needs 2 successive</font>
	<font color="#208020"># points. We get the values of the fit for q and q+0.001</font>
	screate $qValues 0 1 [list $q [expr { $q+0.001 }]]
 	polyf $tmp $error $orderSig gah -fit $qValues

 	sderiv $qValues h
 	<a name="lassign(4)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {h gah} [sget h 0]
 	lappend hLst $h

 	<a name="lassign(5)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {tau gah} [sget $qValues 0]
	lappend tauLst $tau

 	lappend DLst [expr { $q*$h - $tau }]
    }

    screate $dh 0 1 $DLst -xy $hLst
    screate $tqfit 0 1 $tauLst -xy $qLst
    screate $hq 0 1 $hLst -xy $qLst
    screate $qsig 0 1 $qLst -xy $qLst

    delete $orderSig
    delete $tmp
    delete $error
    delete $qValues
    delete $orderSig2

    return [list $dh $tqfit $hq $qsig]
}

</pre>
<hr>
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#byfilename">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a><br>
<cite>File generated 2008-04-03 at 09:49.</cite>
</font>
</body>
</html>
