<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- Generated by TclDoc 0.3 -->
<html>
<head><title>part_comp_fcts.tcl</title></head>
<body bgcolor="#ffffff">
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#part_comp_fcts.tcl">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a>
</font>
<hr>
<strong>part_comp_fcts.tcl</strong>
(<a href="part_comp_fcts.tcl-annot.html">annotations</a> | <a href="part_comp_fcts.tcl.txt">original source</a>)
<p>
<pre>
<font color="#208020"># part_comp_fcts.tcl --</font>
<font color="#208020">#</font>
<font color="#208020">#       This file implements the Tcl code to handle complex partition functions.</font>
<font color="#208020">#</font>
<font color="#208020">#   Copyright 1998 Centre de Recherche Paul Pascal, Bordeaux, France.</font>
<font color="#208020">#   Written by Nicolas Decoster.</font>
<font color="#208020">#</font>
<font color="#208020">#  RCS : $Id: part_comp_fcts.tcl,v 1.1 1998/08/18 14:30:04 decoster Exp $</font>
<font color="#208020">#</font>


<font color="#208020"># sw_comp_fqaqtq --</font>
<font color="#208020"># usage : sw_comp_fqaqtq str float int int list str [args]</font>
<font color="#208020">#</font>
<font color="#208020">#  Create coomplex partition functions files sw can read with the commands gget,</font>
<font color="#208020"># etc. These files are create from a serie of ext image from a wavelet</font>
<font color="#208020"># transform.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string  - base name of the ext images.</font>
<font color="#208020">#   float   - first scale of the WT.</font>
<font color="#208020">#   integer - number of octaves.</font>
<font color="#208020">#   integer - number of voices for each octave.</font>
<font color="#208020">#   list    - values of q for the partition functions.</font>
<font color="#208020">#   string  - base name of the resulting files (i.e. name to use in the sw</font>
<font color="#208020">#             command 'qfile').</font>
<font color="#208020">#   args    - any option to pass to command efct.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<font color="#208020"># State : Exp.</font>
<strong><a name="sw_comp_fqaqtq_33">proc <a href="part_comp_fcts.tcl-annot.html#sw_comp_fqaqtq">sw_comp_fqaqtq</a></a></strong><a name="sw_comp_fqaqtq"></a> {name a_min n_oct n_vox q_lst res args} {
    <font color="#208020"># Create general file.</font>
    set res_file [open $res w]
    puts $res_file &#34;noct $n_oct&#34;
    puts $res_file &#34;nvoice $n_vox&#34;
    puts $res_file &#34;wavelet Gauss_dx_dy&#34;
    puts $res_file &#34;amin $a_min&#34;
    foreach q $q_lst {
	puts $res_file $q
    }
    close $res_file

    <font color="#208020"># Create history file.</font>
    set hist_file [open ${res}_history w]
    puts $hist_file &#34;***Computation on a new signal:&#34;
    puts $hist_file &#34;q Values   \[nb = [llength $q_lst]\]:&#34;
    foreach q $q_lst {
	puts -nonewline $hist_file &#34;$q &#34;
    }
    puts $hist_file &#34;&#34;
    puts $hist_file &#34;Signal size : [expr $n_oct*$n_vox]&#34;
    puts $hist_file &#34;Signal name : Gauss_dx_dy&#34;
    puts $hist_file &#34;&#34;
    close $hist_file
    set val [expr $n_vox/2]

    <font color="#208020"># Create data files.</font>
    for { set oct 0;set num 0}\
	    { $oct &lt; $n_oct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $n_vox } \
		{ incr vox ; incr num} {
	    if {$vox == $val || $vox == 0} {
		set new_num [format &#34;%.3d&#34; $num]
		puts &#34;scale=$new_num&#34;
		catch {exec rm ${res}cosG_${new_num}}
		catch {exec rm ${res}sinG_${new_num}}
		set cos_file [open ${res}cosG_${new_num} a+]
		set sin_file [open ${res}sinG_${new_num} a+]
		foreach q $q_lst {
		    set cosPq [eval efct ${name}${new_num} cos(y*log(abs(x))) $q $args]
		    set sinPq [eval efct ${name}${new_num} sin(y*log(abs(x))) $q $args]
		    puts $cos_file $cosPq
		    puts $sin_file $sinPq
		}
		
		set nb_vc 0
		set nb_max 0
		foreache ${name}${new_num} {
		    incr nb_max 
		    if {[string compare $type &#34;vc&#34;] == 0} {
			incr nb_vc 
		    }
		}    
		if {[string compare $args &#34;-vc&#34;] == 0} {
		    puts $cos_file $nb_vc
		    puts $sin_file $nb_vc
		} else {
		    puts $cos_file $nb_max
		    puts $sin_file $nb_max
		}
		close $cos_file
		close $sin_file
		puts &#34;scale=$new_num max=$nb_max vc=$nb_vc&#34;
	    }
	}
    }
    return
}


<font color="#208020"># sw_comp_add_fqaqtq --</font>
<font color="#208020"># usage : sw_comp_add_fqaqtq str float int int list str [args]</font>
<font color="#208020">#</font>
<font color="#208020">#  Add values to (or create) complex partition functions files sw can read with the</font>
<font color="#208020"># commands getfg etc. These files are (were) created from a serie of ext</font>
<font color="#208020"># image from a wavelet transform.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string  - base name of the ext images.</font>
<font color="#208020">#   float   - first scale of the WT.</font>
<font color="#208020">#   integer - number of octaves.</font>
<font color="#208020">#   integer - number of voices for each octave.</font>
<font color="#208020">#   list    - values of q for the partition functions.</font>
<font color="#208020">#   string  - base name of the resulting files (i.e. name to use in the sw</font>
<font color="#208020">#             command 'qfile').</font>
<font color="#208020">#   args    - any option to pass to command efct.</font>
<font color="#208020">#</font>
<font color="#208020"># Warning :</font>
<font color="#208020">#   If the history file doesn't exists, new files are created.</font>
<font color="#208020">#   If it exists, the other files MUST exist. There is no check.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<font color="#208020"># State : Exp.</font>

<strong><a name="sw_comp_add_fqaqtq_131">proc <a href="part_comp_fcts.tcl-annot.html#sw_comp_add_fqaqtq">sw_comp_add_fqaqtq</a></a></strong><a name="sw_comp_add_fqaqtq"></a> {name a_min n_oct n_vox res args} {
    set q_lst {}
    set q 0.0
    for {set i 0} {$i &lt;= 500} {incr i} {
	set newq [format %.2f $q]
	set q_lst [lappend q_lst $newq]
	set q [expr $q+0.02]
    }

    if {[file exists ${res}_history] == 0} {
	eval sw_comp_fqaqtq $name $a_min $n_oct $n_vox {$q_lst} $res $args
	return
    }

    <font color="#208020"># Update history file.</font>
    set hist_file [open ${res}_history a+]
    puts $hist_file &#34;***Computation on a new signal:&#34;
    puts $hist_file &#34;q Values   \[nb = [llength $q_lst]\]:&#34;
    foreach q $q_lst {
	puts -nonewline $hist_file &#34;$q &#34;
    }
    puts $hist_file &#34;&#34;
    puts $hist_file &#34;Signal size : [expr $n_oct*$n_vox]&#34;
    puts $hist_file &#34;Signal name : Gauss_dx_dy&#34;
    puts $hist_file &#34;&#34;
    close $hist_file
    set val [expr $n_vox/2]

    <font color="#208020"># Update data files.</font>
    for { set oct 0;set num 0}\
	    { $oct &lt; $n_oct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $n_vox } \
		{ incr vox ; incr num} {
	    if {$vox == $val || $vox == 0} {
		set new_num [format &#34;%.3d&#34; $num]
		puts &#34;scale=$new_num&#34;
		<font color="#208020"># Read existing data.</font>
		set cos_file [open ${res}cosG_${new_num} r]
		set sin_file [open ${res}sinG_${new_num} r]
		
		catch {unset cos_lst}
		catch {unset sin_lst}
		
		foreach q $q_lst {	
		    lappend cos_lst [gets $cos_file]
		    lappend sin_lst [gets $sin_file]
		}
		lappend cos_lst [gets $cos_file]
		lappend sin_lst [gets $sin_file]

		close $cos_file
		close $sin_file
		
		<font color="#208020"># Add the new data.</font>
		catch {exec rm ${res}cosG_${new_num}}
		set cos_file [open ${res}cosG_${new_num} a+]
		catch {exec rm ${res}sinG_${new_num}}
		set sin_file [open ${res}sinG_${new_num} a+]
		
		set index 0
		foreach q $q_lst {
		    set cosPq [expr [eval efct ${name}${new_num} cos(log(abs(x))*y) $q $args]+[lindex $cos_lst $index]]
		    set sinPq [expr [eval efct ${name}${new_num} sin(log(abs(x))*y) $q $args]+[lindex $sin_lst $index]]
		    puts $cos_file $cosPq
		    puts $sin_file $sinPq
		    incr index
		}
		
		set nb_vc [lindex $cos_lst $index]
		set nb_max [lindex $cos_lst $index]
		
		set nb_vcbis [lindex $cos_lst $index]
		
		if {$nb_vc != $nb_vcbis} {
		    error &#34;problem with the number of max&#34;
		}
		
		foreache ${name}${new_num} {
		    set nb_max [expr $nb_max+1]
		    if {[string compare $type &#34;vc&#34;] == 0} {
			set nb_vc [expr $nb_vc+1]
		    }
		}    
		if {[string compare $args &#34;-vc&#34;] == 0} {
		    puts $cos_file $nb_vc
		    puts $sin_file $nb_vc
		} else {
		    puts $cos_file $nb_max
		    puts $sin_file $nb_max
		}	    
		close $cos_file
		close $sin_file
		puts &#34;scale=$new_num max=$nb_max vc=$nb_vc&#34;
	    }
	}
    }
}

<strong><a name="sw_comp_part_load_add_231">proc <a href="part_comp_fcts.tcl-annot.html#sw_comp_part_load_add">sw_comp_part_load_add</a></a></strong><a name="sw_comp_part_load_add"></a> {lstname name} {

    set name1 [lindex $lstname 0]

    <font color="#208020"># Read general file for the first name of the list</font>
    set res_file [open $name1 r]
    set n_oct [lindex [gets $res_file] 1]
    set n_vox [lindex [gets $res_file] 1]
    gets $res_file
    set a_min [lindex [gets $res_file] 1]
    gets $res_file q
    while {$q != &#34;&#34;} {
	lappend q_lst $q
	gets $res_file q
    }
    puts $q
    close $res_file
    set val [expr $n_vox/2]


    foreach name2 [lrange $lstname 1 end] {
	
	<font color="#208020"># Read general file for the other name of the list</font>
	set res_file [open $name2 r]
	set n_oct2 [lindex [gets $res_file] 1]
	set n_vox2 [lindex [gets $res_file] 1]
	gets $res_file
	set a_min2 [lindex [gets $res_file] 1]
	gets $res_file q

	catch {unset q_lst2}

	while {$q != &#34;&#34;} {
	    lappend q_lst2 $q
	    gets $res_file q
	}
	close $res_file
	set val2 [expr $n_vox/2]
	
	<font color="#208020"># Check consistency</font>
	
	if {$n_oct != $n_oct2 } {
	    error &#34;n_oct has different value for $name2&#34;
	}
	if {$n_vox != $n_vox2 } {
	    error &#34;n_vox has different value for $name2&#34;
	}
	if {$a_min != $a_min2 } {
	    error &#34;a_min has different value for $name2&#34;
	}

	set ii 0
	foreach q1 $q_lst q2 $q_lst2 {
	    if {$q1 != $q2} {
		error &#34;q ($q1 $q2) has different value for $name2&#34;
	    }
	}
	if {$val != $val2 } {
	    error &#34;val has different value for $name2&#34;
	}
    }
    
    <font color="#208020"># Read the data </font>

    for { set oct 0;set num 0}\
	    { $oct &lt; $n_oct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $n_vox } \
		{ incr vox ; incr num} {
	    if {$vox == $val || $vox == 0} {
		set new_num [format &#34;%.3d&#34; $num]
		puts &#34;scale=$new_num&#34;

		<font color="#208020"># Read data of the first name.</font>
		set cos_file [open ${name1}cosG_${new_num} r]
		set sin_file [open ${name1}sinG_${new_num} r]

		catch {unset cos_lst}
		catch {unset sin_lst}
		
		set num_of_pt 0
		foreach q $q_lst {
		    lappend cos_lst [gets $cos_file]
		    lappend sin_lst [gets $sin_file]
		    incr num_of_pt
		}
		set num_of_max [gets $cos_file]
		set num_of_max2 [gets $sin_file]
		
		if {$num_of_max != $num_of_max2} {
		    error &#34;problem with the number of max&#34;		
		}
		set num_of_pt [expr $num_of_pt-1]
		
		close $cos_file
		close $sin_file	
    

		foreach name2 [lrange $lstname 1 end] {
		    
		    <font color="#208020"># Read the data of the other files</font>
		    set cos_file2 [open ${name2}cosG_${new_num} r]
		    set sin_file2 [open ${name2}sinG_${new_num} r]
		    
		    catch {unset cos_lst2}
		    catch {unset sin_lst2}
		    
		    set num_of_pt 0
		    foreach q $q_lst {
			lappend cos_lst2 [expr [gets $cos_file2] + [lindex $cos_lst $num_of_pt]]
			lappend sin_lst2 [expr [gets $sin_file2] + [lindex $sin_lst $num_of_pt]]
			incr num_of_pt
		    }
		    set num_of_max [expr $num_of_max + [gets $cos_file2]]
		    set num_of_max2 [expr $num_of_max2 + [gets $sin_file2]]
		    
		    if {$num_of_max != $num_of_max2} {
			error &#34;problem with the number of max&#34;		
		    }
		    
		    set num_of_pt [expr $num_of_pt-1]
		    
		    close $cos_file2
		    close $sin_file2
		    
		    catch {unset cos_lst}
		    catch {unset sin_lst}
		    
		    set cos_lst $cos_lst2
		    set sin_lst $sin_lst2
		}


		set newq_lst {}
		set newcos_lst {}
		set newsin_lst {}
		set index 0
		foreach q $q_lst {
		    set ii [expr $num_of_pt-$index]
		    set newq [expr -1.0*[lindex $q_lst $ii]]
		    set newq [format %.2f $newq]
		    set newcos [expr [lindex $cos_lst $ii]/$num_of_max]
		    set newsin [expr -1.0*[lindex $sin_lst $ii]/$num_of_max]
		    
		    if {$newq &lt; 0} {
			set newq_lst [lappend newq_lst $newq]
			set newcos_lst [lappend newcos_lst $newcos]
			set newsin_lst [lappend newsin_lst $newsin]
		    }
		    
		    incr index 
		}
		
		set index 0
		foreach q $q_lst {
		    set newcos [expr [lindex $cos_lst $index]/$num_of_max]
		    set newsin [expr [lindex $sin_lst $index]/$num_of_max]
		    set newq_lst [lappend newq_lst $q]
		    set newcos_lst [lappend newcos_lst $newcos]
		    set newsin_lst [lappend newsin_lst $newsin]
		    incr index
		}
		
		screate ${name}cosG_${new_num} 0 1 $newcos_lst -xy $newq_lst
		screate ${name}sinG_${new_num} 0 1 $newsin_lst -xy $newq_lst
		
	    }
	}
    }

    return &#34;$a_min $n_oct $n_vox &#34;
}

	

<strong><a name="sw_comp_part_merge_files_407">proc <a href="part_comp_fcts.tcl-annot.html#sw_comp_part_merge_files">sw_comp_part_merge_files</a></a></strong><a name="sw_comp_part_merge_files"></a> {lstname destName} {

    set name1 [lindex $lstname 0]

    <font color="#208020"># Read general file for the first name of the list</font>
    set res_file [open $name1 r]
    set n_oct [lindex [gets $res_file] 1]
    set n_vox [lindex [gets $res_file] 1]
    gets $res_file
    set a_min [lindex [gets $res_file] 1]
    gets $res_file q
    while {$q != &#34;&#34;} {
	lappend q_lst $q
	gets $res_file q
    }
    puts $q
    close $res_file
    set val [expr $n_vox/2]


    foreach name2 [lrange $lstname 1 end] {
	
	<font color="#208020"># Read general file for the other name of the list</font>
	set res_file [open $name2 r]
	set n_oct2 [lindex [gets $res_file] 1]
	set n_vox2 [lindex [gets $res_file] 1]
	gets $res_file
	set a_min2 [lindex [gets $res_file] 1]
	gets $res_file q

	catch {unset q_lst2}

	while {$q != &#34;&#34;} {
	    lappend q_lst2 $q
	    gets $res_file q
	}
	close $res_file
	set val2 [expr $n_vox/2]
	
	<font color="#208020"># Check consistency</font>
	
	if {$n_oct != $n_oct2 } {
	    error &#34;n_oct has different value for $name2&#34;
	}
	if {$n_vox != $n_vox2 } {
	    error &#34;n_vox has different value for $name2&#34;
	}
	if {$a_min != $a_min2 } {
	    error &#34;a_min has different value for $name2&#34;
	}

	set ii 0
	foreach q1 $q_lst q2 $q_lst2 {
	    if {$q1 != $q2} {
		error &#34;q ($q1 $q2) has different value for $name2&#34;
	    }
	}
	if {$val != $val2 } {
	    error &#34;val has different value for $name2&#34;
	}
    }
    
    <font color="#208020"># Read the data </font>

    for { set oct 0;set num 0}\
	    { $oct &lt; $n_oct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $n_vox } \
		{ incr vox ; incr num} {
	    if {$vox == $val || $vox == 0} {
		set new_num [format &#34;%.3d&#34; $num]

		<font color="#208020"># Read data of the first name.</font>
		set cos_file [open ${name1}cosG_${new_num} r]
		set sin_file [open ${name1}sinG_${new_num} r]

		catch {unset cos_lst}
		catch {unset sin_lst}
		
		set num_of_pt 0
		foreach q $q_lst {
		    lappend cos_lst [gets $cos_file]
		    lappend sin_lst [gets $sin_file]
		    incr num_of_pt
		}
		set num_of_max [gets $cos_file]
		set num_of_max2 [gets $sin_file]
		
		if {$num_of_max != $num_of_max2} {
		    error &#34;problem with the number of max&#34;		
		}
		set num_of_pt [expr $num_of_pt-1]
		
		close $cos_file
		close $sin_file	
    

		foreach name2 [lrange $lstname 1 end] {
		    
		    <font color="#208020"># Read the data of the other files</font>
		    set cos_file2 [open ${name2}cosG_${new_num} r]
		    set sin_file2 [open ${name2}sinG_${new_num} r]
		    
		    catch {unset cos_lst2}
		    catch {unset sin_lst2}
		    
		    set num_of_pt 0
		    foreach q $q_lst {
			lappend cos_lst2 [expr [gets $cos_file2] + [lindex $cos_lst $num_of_pt]]
			lappend sin_lst2 [expr [gets $sin_file2] + [lindex $sin_lst $num_of_pt]]
			incr num_of_pt
		    }
		    set num_of_max [expr $num_of_max + [gets $cos_file2]]
		    set num_of_max2 [expr $num_of_max2 + [gets $sin_file2]]
		    
		    if {$num_of_max != $num_of_max2} {
			error &#34;problem with the number of max&#34;		
		    }
		    
		    set num_of_pt [expr $num_of_pt-1]
		    
		    close $cos_file2
		    close $sin_file2
		    
		    catch {unset cos_lst}
		    catch {unset sin_lst}
		    
		    set cos_lst $cos_lst2
		    set sin_lst $sin_lst2
		}

		<font color="#208020"># Write the data in destination file.</font>
		set cos_file2 [open ${destName}cosG_${new_num} w]
		set sin_file2 [open ${destName}sinG_${new_num} w]
		
		foreach cos $cos_lst sin $sin_lst {
		    puts $cos_file2 $cos
		    puts $sin_file2 $sin
		}
		puts $cos_file2 $num_of_max
		puts $sin_file2 $num_of_max

		close $cos_file2
		close $sin_file2
	    }
	}
    }

    <font color="#208020"># Create general file.</font>
    set res_file [open ${destName} w]
    puts $res_file &#34;noct $n_oct&#34;
    puts $res_file &#34;nvoice $n_vox&#34;
    puts $res_file &#34;wavelet Gauss_dx_dy&#34;
    puts $res_file &#34;amin $a_min&#34;
    foreach q $q_lst {
	puts $res_file $q
    }
    close $res_file

    <font color="#208020"># Create history file.</font>
    set hist_file [open ${destName}_history w]
    puts $hist_file &#34;***Computation on a new signal:&#34;
    puts $hist_file &#34;q Values   \[nb = [llength $q_lst]\]:&#34;
    foreach q $q_lst {
	puts -nonewline $hist_file &#34;$q &#34;
    }
    puts $hist_file &#34;&#34;
    puts $hist_file &#34;Signal size : [expr $n_oct*$n_vox]&#34;
    puts $hist_file &#34;Signal name : Gauss_dx_dy&#34;
    puts $hist_file &#34;&#34;
    close $hist_file

    return &#34;$a_min $n_oct $n_vox &#34;
}

	

<font color="#208020"># sw_comp_part_load --</font>
<font color="#208020"># usage : sw_part_load str</font>
<font color="#208020">#</font>
<font color="#208020">#  Read partition functions files in the sw format and create signals for each</font>
<font color="#208020"># partition functions (Pq, logsP and PqlogsP).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - base name of the files (i.e. name used in the sw command 'qfile').</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   A list with the parameters of the wavelet transform : first scale, number</font>
<font color="#208020">#   of octaves, number of voices and the list of the values of q.</font>

<font color="#208020"># State : Exp.</font>
<strong><a name="sw_comp_part_load_599">proc <a href="part_comp_fcts.tcl-annot.html#sw_comp_part_load">sw_comp_part_load</a></a></strong><a name="sw_comp_part_load"></a> {name} {
    <font color="#208020"># Read general file.</font>
    set res_file [open $name r]
    set n_oct [lindex [gets $res_file] 1]
    set n_vox [lindex [gets $res_file] 1]
    gets $res_file
    set a_min [lindex [gets $res_file] 1]
    gets $res_file q
    while {$q != &#34;&#34;} {
	lappend q_lst $q
	gets $res_file q
    }
    close $res_file
    set val [expr $n_vox/2]

    for { set oct 0;set num 0}\
	    { $oct &lt; $n_oct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $n_vox } \
		{ incr vox ; incr num} {
	    if {$vox == $val || $vox == 0} {
		set new_num [format &#34;%.3d&#34; $num]
		puts &#34;scale=$new_num&#34;
		<font color="#208020"># Read existing data.</font>
		set cos_file [open ${name}cosG_${new_num} r]
		set sin_file [open ${name}sinG_${new_num} r]
		
		catch {unset cos_lst}
		catch {unset sin_lst}
		
		set num_of_pt 0
		foreach q $q_lst {
		    lappend cos_lst [gets $cos_file]
		    lappend sin_lst [gets $sin_file]
		    incr num_of_pt
		}
		set num_of_max [gets $cos_file]
		set num_of_max2 [gets $sin_file]
		
		<font color="#208020">#	    puts &#34;max=$num_of_max&#34;</font>
		if {$num_of_max != $num_of_max2} {
		    error &#34;problem with the number of max&#34;		
		}
		set num_of_pt [expr $num_of_pt-1]
		
		close $cos_file
		close $sin_file
		
		set newq_lst {}
		set newcos_lst {}
		set newsin_lst {}
		
		set index 0
		foreach q $q_lst {
		    set ii [expr $num_of_pt-$index]
		    set newq [expr -1.0*[lindex $q_lst $ii]]
		    set newq [format %.2f $newq]
		    set newcos [expr [lindex $cos_lst $ii]/$num_of_max]
		    set newsin [expr -1.0*[lindex $sin_lst $ii]/$num_of_max]
		    
		    if {$newq &lt; 0} {
			<font color="#208020">#		    puts &#34;$newq  $newcos $newsin\n&#34;</font>
			set newq_lst [lappend newq_lst $newq]
			set newcos_lst [lappend newcos_lst $newcos]
			set newsin_lst [lappend newsin_lst $newsin]
		    }
		    
		    incr index 
		}

		set index 0
		foreach q $q_lst {
		    <font color="#208020">#		puts &#34;$newq  $newcos $newsin\n&#34;</font>
		    set newcos [expr [lindex $cos_lst $index]/$num_of_max]
		    set newsin [expr [lindex $sin_lst $index]/$num_of_max]
		    set newq_lst [lappend newq_lst $q]
		    set newcos_lst [lappend newcos_lst $newcos]
		    set newsin_lst [lappend newsin_lst $newsin]
		    incr index
		}
		
		<font color="#208020">#	    screate ${name}cosGbis_${new_num} 0 1 $cos_lst -xy $q_lst</font>
		<font color="#208020">#	    screate ${name}sinGbis_${new_num} 0 1 $sin_lst -xy $q_lst</font>
		screate ${name}cosG_${new_num} 0 1 $newcos_lst -xy $newq_lst
		screate ${name}sinG_${new_num} 0 1 $newsin_lst -xy $newq_lst
		<font color="#208020">#	    puts &#34;max=$num_of_max&#34;</font>
	    }
	}
    }
    return &#34;$a_min $n_oct $n_vox &#34;
}

<strong><a name="getfg_692">proc <a href="part_comp_fcts.tcl-annot.html#getfg">getfg</a></a></strong><a name="getfg"></a> {name a1 a2} {
    set new_a1 [format &#34;%.3d&#34; $a1]
    set new_a2 [format &#34;%.3d&#34; $a2]
    scomb ${name}cosG_${new_a2} ${name}sinG_${new_a2} x*x+y*y modG
    
    scomb ${name}cosG_${new_a1} ${name}cosG_${new_a2} x*y temp1
    scomb ${name}sinG_${new_a1} ${name}sinG_${new_a2} x*y temp2
    scomb temp1 temp2 x+y temp3
    scomb temp3 modG x/y ${name}reG${new_a1}_${new_a2}

    scopy temp1 c1c2
    scopy temp2 s1s2

    scopy temp3 c1c2ps1s2

    scomb ${name}sinG_${new_a1} ${name}cosG_${new_a2} x*y temp1
    scomb ${name}cosG_${new_a1} ${name}sinG_${new_a2} x*y temp2
    scomb temp1 temp2 x-y temp3
    scomb temp3 modG x/y ${name}imG${new_a1}_${new_a2}

    scopy temp1 s1c2
    scopy temp2 c1s2

    scopy temp3 s1c2mc1s2

    <font color="#208020">#delete temp1 temp2 temp3 modG</font>
}

<strong><a name="propag_720">proc <a href="part_comp_fcts.tcl-annot.html#propag">propag</a></a></strong><a name="propag"></a> {name a1 a2} {
    set new_a1 [format &#34;%.3d&#34; $a1]
    set new_a2 [format &#34;%.3d&#34; $a2]
    <a name="getfg(1)"><a href="./part_comp_fcts.tcl.html#getfg_692">getfg</a></a> $name $a1 $a2
    scomb ${name}reG${new_a1}_${new_a2} ${name}imG${new_a1}_${new_a2} sqrt(x*x+y*y) ${name}modG${new_a1}_${new_a2} 
    scomb ${name}imG${new_a1}_${new_a2} ${name}reG${new_a1}_${new_a2} atan(x/y) ${name}phiG${new_a1}_${new_a2}
    rmdisc ${name}phiG${new_a1}_${new_a2} ${name}phiG${new_a1}_${new_a2}
    scopy ${name}reG${new_a1}_${new_a2} reG
    scopy ${name}imG${new_a1}_${new_a2} imG
    scopy ${name}modG${new_a1}_${new_a2} moG
}

<strong><a name="nomsg_732">proc <a href="part_comp_fcts.tcl-annot.html#nomsg">nomsg</a></a></strong><a name="nomsg"></a> args {
}

<strong><a name="fitpropag_735">proc <a href="part_comp_fcts.tcl-annot.html#fitpropag">fitpropag</a></a></strong><a name="fitpropag"></a> {name a1 a2 xmin xmax {msg yes}} {

    if {[string compare $msg &#34;yes&#34;] == 0} {
	set msgCmd puts
    } else {
	set msgCmd nomsg
    }

    set new_a1 [format &#34;%.3d&#34; $a1]
    set new_a2 [format &#34;%.3d&#34; $a2]
    <font color="#208020"># First Method</font>
    s2fs ${name}modG${new_a1}_${new_a2} temp1 x -1*log(y)
    sderiv temp1 temp2
    set res [sfit temp2 $xmin $xmax]
    set m1 [expr { [lindex $res 0]*1000.0/1000 }]
    set res [sfit ${name}phiG${new_a1}_${new_a2} $xmin $xmax]
    set m2 [expr { [lindex $res 0]*1000.0/1000 }]
    $msgCmd &#34;First Method :  sigma=$m1 (modulus)\n                m=$m2 (argument)&#34;

    <font color="#208020">#Second Method</font>
    sthresh ${name}phiG${new_a1}_${new_a2} temp1 $xmin $xmax
    set res [sasymfit temp1 fittemp2]
    set m [lindex $res 0]
    set k3 [expr [lindex $res 1]*6]
    set k5 [lindex $res 2]
    s2fs ${name}modG${new_a1}_${new_a2} temp1 x log(y)
    sthresh temp1 temp2 $xmin $xmax
    set res [ssymfit temp2 fittemp2]
    set sigma [expr { -2*[lindex $res 0] }]
    set beta [lindex $res 1]
    set gamma [lindex $res 2]
    $msgCmd &#34;Second Method : sigma=$sigma beta=$beta gamma=$gamma (modulus)\n                m=$m k3=$k3 k5=$k5 (argument)&#34;
    delete temp*

    set a1_a2 [expr { pow(2,($a2-$a1)/10.0) }]

    return &#34;$sigma $beta $gamma $m $k3 $k5 $m1 $m2 $a1_a2&#34;
    
}

<strong><a name="getbgl_775">proc <a href="part_comp_fcts.tcl-annot.html#getbgl">getbgl</a></a></strong><a name="getbgl"></a> {sigma beta gamma m k3 k5 m1 m2 a1_a2} {
    set beta [expr { exp($k3/$sigma) / log($a1_a2)}]
    set lambda [expr { $sigma/(pow(log($beta),2)*pow(log($a1_a2),2)) }]
    set gamma [expr { $m/log($a1_a2) - $lambda*log($beta) }]

    return [list $beta $gamma $lambda]
}

<strong><a name="showfitg_783">proc <a href="part_comp_fcts.tcl-annot.html#showfitg">showfitg</a></a></strong><a name="showfitg"></a> {name a1 a2 sigma beta gamma m k3 k5} {
    set new_a1 [format &#34;%.3d&#34; $a1]
    set new_a2 [format &#34;%.3d&#34; $a2]
    s2fs ${name}modG${new_a1}_${new_a2} temp x log(y)
    s2fs ${name}modG${new_a1}_${new_a2} fitmodG x $sigma*x*x+$beta*x*x*x*x+$gamma*x*x*x*x*x*x
    s2fs ${name}phiG${new_a1}_${new_a2} fitphiG x $m*x+$k3*x*x*x+$k5*x*x*x*x*x
    set sig_lst1 {}
    set sig_lst2 {}
    set complete_lst {}
    set sig_lst1 [lappend sig_lst1 temp]
    set sig_lst1 [lappend sig_lst1 fitmodG]
    set sig_lst2 [lappend sig_lst2 ${name}phiG${new_a1}_${new_a2}]
    set sig_lst2 [lappend sig_lst2 fitphiG]
    set complete_lst [lappend complete_lst ${sig_lst1}]
    set complete_lst [lappend complete_lst ${sig_lst2}]

    set code [catch {mdisp 1 2 ${complete_lst}} result]
    ${result} setColorsByList {black red}
    set itemList {}
    foreach value {G fit} {
	set itemList [lappend itemlist [list %c $value]]
    }
    eval ${result} setLabelsItemsByList $itemList
    ${result}gr0000 set_label [list black &#34;log(Mod) scale : ${a1}_${a2} , &#34;] allSigLabel
    ${result}gr0001 set_label [list black &#34;Arg scale : ${a1}_${a2} , &#34;] allSigLabel

    return $result
}


<strong><a name="fitslopeG_813">proc <a href="part_comp_fcts.tcl-annot.html#fitslopeG">fitslopeG</a></a></strong><a name="fitslopeG"></a> {name alpha num dep} {

    set xmax 2
    set xmin [expr -1.0*$xmax]

    set ln2 0.69314718
    set r2 1.41421356237
    set dx [expr $ln2/2.0]
    set taille [expr ($num-($dep-1))*2]

    set sig_sigma_lst {}
    set sig_beta_lst {}
    set sig_gammma_lst {}
    set sig_m_lst {}
    set sig_k3_lst {}
    set sig_k5_lst {}
    set sig_sigma_lst2 {}
    set sig_beta_lst2 {}
    set sig_gammma_lst2 {}
    set sig_m_lst2 {}
    set sig_k3_lst2 {}
    set sig_k5_lst2 {}

    for {set oref  0} {$oref &lt;= $num} {incr oref} {
	set oref2 [expr 10*$oref]
	set x0 [expr ($dep-$oref)*$ln2]
	set aref [expr pow(2,$oref)]
	
	set a2alpha [expr pow($aref,$alpha)]
	
	set index 1

	set ax_lst {}
	set sigma_lst {}
	set beta_lst {}
	set gamma_lst {}
	set m_lst {}
	set k3_lst {}
	set k5_lst {}

	for {set oct $dep} {$oct &lt;= $num} {incr oct} {
	    set acur [expr pow(2,$oct)]
	    for {set vo 0} {$vo &lt;= 1} {incr vo} {
		set oct2 [expr 10*$oct]
		if {$vo == 1} {
		    set acur [expr $acur*$r2]
		    set oct2 [expr 10*$oct+5]
		}
		set a1alpha [expr pow($acur,$alpha)]
		set ax [expr ($a1alpha-$a2alpha)/$alpha]
		
		
		puts &#34;oref=$oref2 oct=$oct2 v=$vo&#34;
		<a name="propag(1)"><a href="./part_comp_fcts.tcl.html#propag_720">propag</a></a> $name $oct2 $oref2
		set res [<a name="fitpropag(1)"><a href="./part_comp_fcts.tcl.html#fitpropag_735">fitpropag</a></a> $name $oct2 $oref2 $xmin $xmax]
		set sigma [lindex $res 0]
		set beta [lindex $res 1]
		set gamma [lindex $res 2]
		set m [lindex $res 3]
		set k3 [lindex $res 4]
		set k5 [lindex $res 5]
		puts $res
		set sigma_lst [lappend sigma_lst $sigma]
		set beta_lst [lappend beta_lst $beta]
		set gamma_lst [lappend gamma_lst $gamma]
		set m_lst [lappend m_lst $m]
		set k3_lst [lappend k3_lst $k3]
		set k5_lst [lappend k5_lst $k5]
		set ax_lst [lappend ax_lst $ax]
	    }
	    
	}
	screate sigma_lna_$oref $x0 $dx $sigma_lst
	screate beta_lna_$oref $x0 $dx $beta_lst
	screate gamma_lna_$oref $x0 $dx $gamma_lst
	screate m_lna_$oref $x0 $dx $m_lst
	screate k3_lna_$oref $x0 $dx $k3_lst
	screate k5_lna_$oref $x0 $dx $k5_lst

	screate sigma_ah_$oref $x0 $dx $sigma_lst -xy $ax_lst
	screate beta_ah_$oref $x0 $dx $beta_lst -xy $ax_lst
	screate gamma_ah_$oref $x0 $dx $gamma_lst -xy $ax_lst
	screate m_ah_$oref $x0 $dx $m_lst -xy $ax_lst
	screate k3_ah_$oref $x0 $dx $k3_lst -xy $ax_lst
	screate k5_ah_$oref $x0 $dx $k5_lst -xy $ax_lst

	set sig_sigma_lst [lappend sig_sigma_lst sigma_lna_$oref]
	set sig_beta_lst [lappend sig_beta_lst beta_lna_$oref]
	set sig_gamma_lst [lappend sig_gamma_lst gamma_lna_$oref]
	set sig_m_lst [lappend sig_m_lst m_lna_$oref]
	set sig_k3_lst [lappend sig_k3_lst k3_lna_$oref]
	set sig_k5_lst [lappend sig_k5_lst k5_lna_$oref]
	set sig_sigma_lst2 [lappend sig_sigma_lst2 sigma_ah_$oref]
	set sig_beta_lst2 [lappend sig_beta_lst2 beta_ah_$oref]
	set sig_gamma_lst2 [lappend sig_gamma_lst2 gamma_ah_$oref]
	set sig_m_lst2 [lappend sig_m_lst2 m_ah_$oref]
	set sig_k3_lst2 [lappend sig_k3_lst2 k3_ah_$oref]
	set sig_k5_lst2 [lappend sig_k5_lst2 k5_ah_$oref]
	
    }


    set complete_lst {}
    set complete_lst [lappend complete_lst $sig_sigma_lst]
    set complete_lst [lappend complete_lst $sig_beta_lst]
    set complete_lst [lappend complete_lst $sig_gamma_lst]
    set complete_lst [lappend complete_lst $sig_m_lst]
    set complete_lst [lappend complete_lst $sig_k3_lst]
    set complete_lst [lappend complete_lst $sig_k5_lst]
    set complete_lst [lappend complete_lst $sig_sigma_lst2]
    set complete_lst [lappend complete_lst $sig_beta_lst2]
    set complete_lst [lappend complete_lst $sig_gamma_lst2]
    set complete_lst [lappend complete_lst $sig_m_lst2]
    set complete_lst [lappend complete_lst $sig_k3_lst2]
    set complete_lst [lappend complete_lst $sig_k5_lst2]

    set code [catch {mdisp 2 6 ${complete_lst}} result]
    if {$code != 0} {
	error $result $result
    }
    ${result} setColorsByList {red violet cyan green blue}

    set itemList {}
    for {set oref  0} {$oref &lt;= $num} {incr oref} {
    	set itemList [lappend itemlist [list %c $oref]]
    }
    eval ${result} setLabelsItemsByList $itemList
    ${result}gr0000 set_label {black &#34;sigma_vs_lna, &#34;} allSigLabel
    ${result}gr0001 set_label {black &#34;beta_vs_lna, &#34;} allSigLabel
    ${result}gr0002 set_label {black &#34;gamma_vs_lna, &#34;} allSigLabel
    ${result}gr0003 set_label {black &#34;m_vs_lna, &#34;} allSigLabel
    ${result}gr0004 set_label {black &#34;k3_vs_lna, &#34;} allSigLabel
    ${result}gr0005 set_label {black &#34;k5_vs_lna, &#34;} allSigLabel

    ${result}gr0100 set_label [list black &#34;sigma_vs_a^$alpha, &#34;] allSigLabel
    ${result}gr0101 set_label [list black &#34;beta_vs_a^$alpha, &#34;] allSigLabel
    ${result}gr0102 set_label [list black &#34;gamma_vs_a^$alpha, &#34;] allSigLabel
    ${result}gr0103 set_label [list black &#34;m_vs_a^$alpha, &#34;] allSigLabel
    ${result}gr0104 set_label [list black &#34;k3_vs_a^$alpha, &#34;] allSigLabel
    ${result}gr0105 set_label [list black &#34;k5_vs_a^$alpha, &#34;] allSigLabel


    return $result
}

</pre>
<hr>
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#byfilename">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a><br>
<cite>File generated 2008-04-03 at 09:49.</cite>
</font>
</body>
</html>
