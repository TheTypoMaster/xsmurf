<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- Generated by TclDoc 0.3 -->
<html>
<head><title>imStudy.tcl</title></head>
<body bgcolor="#ffffff">
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#imStudy.tcl">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a>
</font>
<hr>
<strong>imStudy.tcl</strong>
(<a href="imStudy.tcl-annot.html">annotations</a> | <a href="imStudy.tcl.txt">original source</a>)
<p>
<pre>
<font color="#208020"># imStudy.tcl --</font>
<font color="#208020">#</font>
<font color="#208020">#       This file implements the Tcl code to compute image study and to</font>
<font color="#208020"># store its results and its &#34;state&#34;.</font>
<font color="#208020">#</font>
<font color="#208020">#   Copyright (c) 1998-1999 Nicolas Decoster.</font>
<font color="#208020">#   Copyright (c) 1998-1999 Centre de Recherche Paul Pascal, Bordeaux, France.</font>
<font color="#208020">#</font>
<font color="#208020">#   Copyright (c) 1999-2007 Pierre Kestener.</font>
<font color="#208020">#   Copyright (c) 1999-2002 Centre de Recherche Paul Pascal, Bordeaux, France.</font>
<font color="#208020">#   Copyright (c) 2002-2003 Ecole Normale Superieure de Lyon, Lyon, France.</font>
<font color="#208020">#   Copyright (c) 2003-2007 CEA DSM/DAPNIA/SEDI, centre Saclay, France.</font>
<font color="#208020">#</font>


<font color="#208020"># </font>
<font color="#208020"># Warning : The names convention for histograms has changed :</font>
<font color="#208020">#  h_mod		-&gt; h_i_mod	: image modulus histogram.</font>
<font color="#208020">#  h_arg		-&gt; h_i_arg	: image argument histogram.</font>
<font color="#208020">#  calendos_image	-&gt; h_i_cal	: image gradient histogram.</font>
<font color="#208020">#  h_max_mod   	-&gt; h_l_mod	: contour lines modulus histogram.</font>
<font color="#208020">#  h_max_arg   	-&gt; h_l_arg	: contour lines argument histogram.</font>
<font color="#208020">#  calendos_max	-&gt; h_l_cal	: contour lines gradient histogram.</font>
<font color="#208020">#  h_max_line_mod	-&gt; h_m_mod	: maxima (on contour lines) modulus</font>
<font color="#208020">#					  histogram.</font>
<font color="#208020">#  h_max_line_arg	-&gt; h_m_arg	: maxima (on contour lines) argument</font>
<font color="#208020">#					  histogram.</font>
<font color="#208020">#  calendos_max_line-&gt; h_m_cal	: maxima (on contour lines) gradient</font>
<font color="#208020">#					  histogram.</font>

package require study
package require pf
package provide imStudy 0.0

namespace eval imStudy {
    variable studyId none

    <font color="#208020"># Description of the parameters of the study</font>
    variable parDesc
    array set  parDesc {
	baseDir        {requested -dir &#34;Base directory.&#34;}
	studyName	{&#34;the study&#34; -string &#34;Name of the study (short).&#34;}
	studyDesc	{&#34;It is a study on something (gah).&#34; -string &#34;Long description of the study.&#34;}
	histDirName    {$baseDir/histograms -string &#34;Histogram directory name.&#34;}
	histFileName   {$baseDir/min_max_hist -string &#34;Histogram file name where to save hist min and max.&#34;}
	logHistFileName   {none -string &#34;Logarithm histogram file name where to save log hist min and max.&#34;}
	spFileName	{{}	-string 	&#34;Spectrum file name.&#34;}
	first_image    {0 -posint      &#34;Index of the first image.&#34;}
	last_image     {0 -posint      &#34;Index of the last image.&#34;}
	size           {32 -posint     &#34;Size of the image(s).&#34;}
	wavelet        {gaussian -string &#34;Name of the wavelet.&#34;}
	amin           {1 -posfloat    &#34;First scale.&#34;}
	noct           {2 -posint      &#34;Number of octaves.&#34;}
	nvox           {2 -posint      &#34;Number of vox per octave.&#34;}
	nbox_mod       {1024 -posint   &#34;Size of the modulus histograms.&#34;}
	nbox_arg       {1024 -posint   &#34;Size of the argument histograms.&#34;}
	nbox_gradx     {1024 -posint   &#34;Size of the gradx histograms.&#34;}
	nbox_grady     {1024 -posint   &#34;Size of the grady histograms.&#34;}
	calendos_size  {128 -posint    &#34;Size of the 2d histograms.&#34;}
	useDiskSwap    {0 -boolean     &#34;Use disk swap so as to compute big images. Speed loss...&#34;}
	useCv2d        {0 -boolean     &#34;Use convolution algorithms from the cv2d library.&#34;}
	useFftw        {0 -boolean     &#34;Use convolution algorithms from the fftw library.&#34;}
	useNMaxSup     {0 -boolean     &#34;Use a rapid non-maxima suppression method for comptuting WTMM points instead of the default computation intensive method that uses 2nd and 3rd derivative to find if a point is a maxima of gradient modulus in the direction of the gradient vector.&#34;}
	inMemory       {0 -boolean     &#34;This parameter allows to swith computation mode: the Fourier transform image is kept in memory instead of being saved ina file on disk.&#34;}
	imagePath      {$baseDir/$imIdF/image -string &#34;Path for the image file.&#34;}
	partSize       {1024 -int      &#34;This is the size of the parts when disk swap is used.&#34;}
	isgaussian     {1 -boolean     &#34;Gaussian computation.&#34;}
	ismexican      {0 -boolean     &#34;Mexican computation.&#34;}
	issave         {0 -boolean     &#34;Save between each image computation.&#34;}
	ishisto        {0 -boolean     &#34;Computation of the histograms.&#34;}
	ismaxhisto     {0 -boolean     &#34;Computation of the maxima histograms.&#34;}
	ishistoinit    {0 -boolean     &#34;Initialization of the histograms.&#34;}
	iscontpart     {0 -boolean     &#34;Computation of the continuous partition functions.&#34;}
	isthetapart    {0 -boolean     &#34;Computation of the \&#34;theta\&#34; partition functions.&#34;}
	followVersion  {1 -int         &#34;Version of the algo for follow command (does not work with disk swap). Must be 0 1 or 2. Other values are like 1.&#34;}
	border_percent {0.72 {{-intfloat 0 1}}    &#34;To set the size of the border to cut.&#34;}
	similitude     {0.8 {{-intfloat 0 1}}     &#34;Value to use with the vchain command.&#34;}
	q_lst          {{-3 -2 -1 0 1 2 3} \
		{{-list -float}} &#34;List of the value of q for partition functions.&#34;}
	pos_q_lst      {{0 1 2 3 4 5 6 7} \
		{{-list -posfloat}} &#34;List of the value of q for continuous partition functions.&#34;}
	images_lst     {none \
		{{-list -int}} &#34;List of ID numbers (integer) of images used by foreachImage.&#34;}
    }

    <font color="#208020"># Some constants.</font>
    variable PI 3.1415926535897931
    variable mPI -3.1415926535897931
    variable pi 3.1416
    variable m_pi -3.1416

    <font color="#208020"># State variables</font>
    variable border_size
    variable hist_min none
    variable hist_max none

    <font color="#208020"># Wavelets derivatives expression definition.</font>
    variable gaussianDef
    array set gaussianDef {
	dx,r	0
	dx,i	x*exp(-x*x-y*y)
	dy,r	0
	dy,i	y*exp(-x*x-y*y)
	dxx,r	-x*x*exp(-x*x-y*y)
	dxx,i	0
	dxy,r	-y*x*exp(-x*x-y*y)
	dxy,i	0
	dyy,r	-y*y*exp(-x*x-y*y)
	dyy,i	0
	dxxx,r	0
	dxxx,i	-x*x*x*exp(-x*x-y*y)
	dxxy,r	0
	dxxy,i	-x*x*y*exp(-x*x-y*y)
	dxyy,r	0
	dxyy,i	-x*y*y*exp(-x*x-y*y)
	dyyy,r	0
	dyyy,i	-y*y*y*exp(-x*x-y*y)
    }

    variable mexicanDef
    array set mexicanDef {
	dx,r	0
	dx,i	x*(x*x+y*y)*exp(-x*x-y*y)
	dy,r	0
	dy,i	y*(x*x+y*y)*exp(-x*x-y*y)
	dxx,r	-x*x*(x*x+y*y)*exp(-x*x-y*y)
	dxx,i	0
	dxy,r	-y*x*(x*x+y*y)*exp(-x*x-y*y)
	dxy,i	0
	dyy,r	-y*y*(x*x+y*y)*exp(-x*x-y*y)
	dyy,i	0
	dxxx,r	0
	dxxx,i	-x*x*x*(x*x+y*y)*exp(-x*x-y*y)
	dxxy,r	0
	dxxy,i	-x*x*y*(x*x+y*y)*exp(-x*x-y*y)
	dxyy,r	0
	dxyy,i	-x*y*y*(x*x+y*y)*exp(-x*x-y*y)
	dyyy,r	0
	dyyy,i	-y*y*y*(x*x+y*y)*exp(-x*x-y*y)
    }

    <font color="#208020"># Wavelets derivatives expression definition for FFTW</font>
    <font color="#208020"># x and y are swapped because fftw lib expects row-major ordered data</font>
    variable gaussianDef_FFTW
    array set gaussianDef_FFTW {
	dx,r	0
	dx,i	y*exp(-x*x-y*y)
	dy,r	0
	dy,i	x*exp(-x*x-y*y)
	dxx,r	-y*y*exp(-x*x-y*y)
	dxx,i	0
	dxy,r	-y*x*exp(-x*x-y*y)
	dxy,i	0
	dyy,r	-x*x*exp(-x*x-y*y)
	dyy,i	0
	dxxx,r	0
	dxxx,i	-y*y*y*exp(-x*x-y*y)
	dxxy,r	0
	dxxy,i	-x*y*y*exp(-x*x-y*y)
	dxyy,r	0
	dxyy,i	-x*x*y*exp(-x*x-y*y)
	dyyy,r	0
	dyyy,i	-x*x*x*exp(-x*x-y*y)
    }

    variable mexicanDef_FFTW
    array set mexicanDef_FFTW {
	dx,r	0
	dx,i	y*(x*x+y*y)*exp(-x*x-y*y)
	dy,r	0
	dy,i	x*(x*x+y*y)*exp(-x*x-y*y)
	dxx,r	-y*y*(x*x+y*y)*exp(-x*x-y*y)
	dxx,i	0
	dxy,r	-y*x*(x*x+y*y)*exp(-x*x-y*y)
	dxy,i	0
	dyy,r	-x*x*(x*x+y*y)*exp(-x*x-y*y)
	dyy,i	0
	dxxx,r	0
	dxxx,i	-y*y*y*(x*x+y*y)*exp(-x*x-y*y)
	dxxy,r	0
	dxxy,i	-x*y*y*(x*x+y*y)*exp(-x*x-y*y)
	dxyy,r	0
	dxyy,i	-x*x*y*(x*x+y*y)*exp(-x*x-y*y)
	dyyy,r	0
	dyyy,i	-x*x*x*(x*x+y*y)*exp(-x*x-y*y)
    }
}


<font color="#208020"># ist --</font>
<font color="#208020"># usage : ist args</font>
<font color="#208020">#</font>
<font color="#208020">#   Execute a script in the imStudy namespace.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   args - a list of arg.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Result of the execution.</font>

<strong><a name="ist_201">proc <a href="imStudy.tcl-annot.html#ist">ist</a></a></strong><a name="ist"></a> args {
    if {[llength $args] != 0} {
	set cmd [concat namespace inscope imStudy $args]
	set code [catch {eval $cmd} result]
	if {$code != 0} {
	    return -code error $result
	} else {
	    return $result
	}
    }
}


<font color="#208020"># imStudy::help --</font>
<font color="#208020"># usage : imStudy::help [proc]</font>
<font color="#208020">#</font>
<font color="#208020">#   Get help on imStudy pakage.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   [proc] - help on a proc.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Help message.</font>

<strong><a name="imStudy::help_225">proc <a href="imStudy.tcl-annot.html#imStudy::help">imStudy::help</a></a></strong><a name="imStudy::help"></a> args {
    variable studyId
    variable parDesc

    if {[llength $args] == 0} {
	set resStr &#34;Package imStudy :

  This package handle wtmm images study. Use the \&#34;ist\&#34; command to execute
scripts in the imStudy pakage.
  A study is handle with user-defined parameters stored in a file (see \&#34;init\&#34;
command). This parameters are the usual wtmm parameters (i.e. amin, noct, etc).
You can have an help on parameters with the command \&#34;help parameters\&#34; (or
\&#34;ist help parameters\&#34; from the global interpreter).
  With the same syntax you can acces to help on internal commands (i.e. \&#34;help
init\&#34;, or \&#34;ist help init\&#34; from the global interpreter).

List of internal commands :
  init
  help
  paramValues
  scalesLoop
  imagesLoop
  foreachImage
  logMsg
  wtmmg
  wtmmg2d_vector
  wtmmg3d_scalar
  wtmmg_partial
  limitsG
  histInitG
  iHistOneScaleG
  lHistOneScaleG
  mHistOneScaleG
  convHistName
  hidisp
  hread

  This package defines some very usefull scripts for you (lucky guy). To eval
them from the global interpreter you can do this :
    ]ist \{eval \$theScriptName\}

or you can do this :
    ]ist \$\{imStudy::theScriptName\}

  For now there is no inline-help on what the scripts do. If you want to read a
little about them, you must check their \&#34;comment like help message\&#34; in the
file they are defined (i.e. the end of imStudy.tcl).

List of pre-defined scripts :
  initHistScr
  computeWtmmgOneImageScr
  pfInitScr
  computeMaxStatGOneImageScr
  pfEndScr
  completeScr
  maxStatScr&#34;
        return $resStr
    }

    if {[string compare $args parameters] == 0} {
	set resStr &#34;
  Here is the list of the parameters for a image study. If the word
\&#34;requested\&#34; appears in the \&#34;default value\&#34; column, this means the parameter
_must_ be specified in the parameters file (see \&#34;init\&#34; command).
&#34;

	set pMaxLength 0
	set vMaxLength 0
	set searchId [array startsearch parDesc]
	while {[array anymore parDesc $searchId] == 1} {
	    set parameter [array nextelement parDesc $searchId]
	    set length [string length $parameter]
	    if {$length &gt; $pMaxLength} {
		set pMaxLength $length
	    }
	    set value [lindex $parDesc($parameter) 0]
	    set length [string length $value]
	    if {$length &gt; $vMaxLength} {
		set vMaxLength $length
	    }
	}
	<font color="#208020"># To be changed...</font>
	if {$vMaxLength &gt; 30} {
	    set vMaxLength 30
	}

	<font color="#208020"># Output...</font>

	set resStr [format \
		&#34;%s\n%-${pMaxLength}s %-${vMaxLength}s %s\n&#34; \
		$resStr parameter &#34;default value&#34; &#34;description&#34;]
	array donesearch parDesc $searchId
	set searchId [array startsearch parDesc]
	while {[array anymore parDesc $searchId] == 1} {
	    set parameter [array nextelement parDesc $searchId]
	    set value [lindex $parDesc($parameter) 0]
	    set help [lindex $parDesc($parameter) 2]
	    set resStr [format \
		    &#34;%s\n%-${pMaxLength}s %-${vMaxLength}s %s&#34; \
		    $resStr $parameter $value $help]
	}
	array donesearch parDesc $searchId

	return $resStr
    }

    global auto_index

    set cmdName [lindex $args 0]
    set code [catch &#34;set auto_index(::imStudy::$cmdName)&#34; result]
    if {$code != 0} {
	return -code error &#34;no command \&#34;$cmdName\&#34; in pakage imStudy&#34;
    }
    set fileName [lindex $result 1]
    if {[string compare [lindex [file split $fileName] end] &#34;imStudy.tcl&#34;] != 0} {
	return -code error &#34;no command \&#34;$cmdName\&#34; in pakage imStudy&#34;
    }

    <font color="#208020"># Set the default message.</font>
    set resStr &#34;Sorry, no help for `$cmdName'.&#34;

    set fileId [open $fileName r]

    while {[gets $fileId line] != -1} {
	if {[string compare $line &#34;# imStudy::$cmdName --&#34;] == 0} {
	    <font color="#208020"># header line of help comment is found.</font>
	    unset resStr
	    while {[gets $fileId line] != -1} {
		if {[regexp {^# *} $line]} {
		    <font color="#208020"># the line begins by &#34;#&#34; -&gt; it is a help comment line.</font>
		    <font color="#208020"># Remove the leading &#34;#&#34; ...</font>
		    regsub {^# } $line &#34;&#34; line
		    regsub {^#} $line &#34;&#34; line
		    <font color="#208020"># ... and add to result</font>
		    if {[info exist resStr] == 1} {
			set resStr [format &#34;%s\n%s&#34; $resStr &#34;$line&#34;]
		    } else {
			set resStr $line
		    }
		} else {
		    <font color="#208020"># No more leading &#34;#&#34; -&gt; end of help comment.</font>
		    break
		}
	    }
	    if {[info exist resStr] != 1} {
		<font color="#208020"># There was no line beginning with &#34;#&#34; after the</font>
		<font color="#208020"># header line of the help comment.</font>
		set resStr &#34;Sorry, no help for `$cmdName'.&#34;
	    }		    
	    <font color="#208020"># Exit the loop on file lines.</font>
	    break
	}
    }
    close $fileId

    set resStr [format &#34;%s\n\n(file : %s)&#34; $resStr $fileName]


    return $resStr
}


<font color="#208020"># imStudy::init --</font>
<font color="#208020"># usage : imStudy::init [-filename str] [-force]</font>
<font color="#208020">#</font>
<font color="#208020">#   Init the parameters of the image study. The paramters of the study must be</font>
<font color="#208020"># stored in a file whose default name is parameters.tcl.</font>
<font color="#208020">#   The file must contain the base directory for the study. By default this</font>
<font color="#208020"># procedure must be execute in the base directory. This is done to avoid</font>
<font color="#208020"># pathname error. This can be escaped by the -force option.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   none.</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -filename : gah !</font>
<font color="#208020">#      string - file name.</font>
<font color="#208020">#   -force : escape the directory check.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::init_407">proc <a href="imStudy.tcl-annot.html#imStudy::init">imStudy::init</a></a></strong><a name="imStudy::init"></a> {args} {
    variable studyId
    variable parDesc

    <font color="#208020"># Default value of the proc variables.</font>

    set fileName parameters.tcl
    set curDir [pwd]
    set isForce 0

    <font color="#208020"># Arguments analysis</font>

    set oldArgs $args
    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -filename {
		set fileName [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -force {
		set isForce 1
		set args [lreplace $args 0 0]
	    }
	    --  {
		set args [lreplace $args 0 0]
		break
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }

    <font color="#208020"># If there is a current im study, we end it.</font>
    if {$studyId != &#34;none&#34;} {
	<a name="study::end(1)"><a href="./study.tcl.html#study::end_278">study::end</a></a> $studyId
    }
    InitVar

    <font color="#208020"># Init the study.</font>
    set cmd [concat study::init -desc parDesc $oldArgs]
    set code [catch $cmd result]
    if {$code != 0} {
	return -code error $result
    }
    set studyId $result

    <font color="#208020"># Create a variable for each parameter.</font>
    foreach {key value} [array get $studyId] {
	variable $key
    }
    <a name="study::param2var(1)"><a href="./study.tcl.html#study::param2var_426">study::param2var</a></a> $studyId

    if {$iscontpart} {
	<font color="#208020"># Temporary message. Remove it as soon as possible.</font>
	puts &#34;init : *** Sorry, no continuous partition functions for now... ***&#34; 
	puts &#34;init : *** set \&#34;iscontpart\&#34; to 0.                              ***&#34; 
    }

    variable border_size
    set border_size [GetBorderSize]

    return
}


<font color="#208020"># imStudy::InitVar -- PRIVATE</font>
<font color="#208020"># usage : imStudy::InitVar</font>
<font color="#208020">#</font>
<font color="#208020">#   Init all variables.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   None.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::InitVar_484">proc <a href="imStudy.tcl-annot.html#imStudy::InitVar">imStudy::InitVar</a></a></strong><a name="imStudy::InitVar"></a> {} {
    <font color="#208020"># Usefull variables.</font>

    variable scale	-1	;<font color="#208020"># Current scale.</font>
    variable scaleId	-1	;<font color="#208020"># Current scale id.</font>
    variable scaleIdF	0	;<font color="#208020"># Current formatted scale id (i.e. 000, 001, etc).</font>
    variable oct	0	;<font color="#208020"># Current octave.</font>
    variable octList    {}      ;<font color="#208020"># used in foreachscale</font>
    variable vox	0	;<font color="#208020"># Current voice.</font>
    variable voxList    {}      ;<font color="#208020"># used in foreachscale; must have same</font>
    <font color="#208020"># size as octList</font>


    variable imId	-1	;<font color="#208020"># Current image id.</font>
    variable imIdF	0	;<font color="#208020"># Current formatted image id (i.e. 00, 01, etc).</font>

    variable scalesLoopLock 0
    variable imagesLoopLock 0
    variable foreachImageLock 0
}


<font color="#208020"># imStudy::paramValues --</font>
<font color="#208020"># usage : imStudy::paramValues [-channel channelId] [-helpmsg]</font>
<font color="#208020">#</font>
<font color="#208020">#   Puts the name and the value of all parameters on stdout.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#</font>
<font color="#208020"># Options :</font>
<font color="#208020">#   -channel : use another channel.</font>
<font color="#208020">#      channelId - the channel id.</font>
<font color="#208020">#   -helpmsg : add an help for each parameter at the end of the line.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::paramValues_521">proc <a href="imStudy.tcl-annot.html#imStudy::paramValues">imStudy::paramValues</a></a></strong><a name="imStudy::paramValues"></a> args {
    variable studyId
    variable parDesc

    set theArgs &#34;&#34;
    while {[string match -* $args]} {
	switch -glob -- [lindex $args 0] {
	    -helpmsg {
		lappend theArgs [lindex $args 0]
		lappend theArgs parDesc
		set args [lreplace $args 0 0]
	    }
	    default {
		lappend theArgs [lindex $args 0]
		set args [lreplace $args 0 0]
	    }
	}
    }

    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    set cmd &#34;study::param $studyId $theArgs&#34;
    set code [catch $cmd result]
    if {$code != 0} {
	return -code error $result
    }

    return
}


<font color="#208020"># imStudy::scalesLoop --</font>
<font color="#208020"># usage : imStudy::scalesLoop script</font>
<font color="#208020">#</font>
<font color="#208020">#   Loop on the scales of the study. Here is the list of modified variables :</font>
<font color="#208020"># scale, scaleId, scaleIdF, oct and vox. The loop begins at the scale</font>
<font color="#208020"># corresponding to the value of scaleId before the loop.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   script  - script to execute.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The result of the last command of the loop.</font>

<strong><a name="imStudy::scalesLoop_567">proc <a href="imStudy.tcl-annot.html#imStudy::scalesLoop">imStudy::scalesLoop</a></a></strong><a name="imStudy::scalesLoop"></a> {script} {
    variable amin
    variable noct
    variable nvox
    variable scale
    variable scaleId
    variable scaleIdF
    variable oct
    variable vox
    variable scalesLoopLock

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    if {$scalesLoopLock == 1} {
	return -code error &#34;there's an other running scales loop&#34;
    }
    set scalesLoopLock 1

    set beginId $scaleId

    for { set oct 0;set num 0}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num} {
	    if {$num &gt;= $beginId} {
		set scale [expr $amin*pow(2,$oct+($vox/double($nvox)))]
		set scale [expr $scale*(6/0.86)]
		set scaleId $num
		set scaleIdF [format &#34;%.3d&#34; $num]
		set code [catch {uplevel $script} result]
		switch $code {
		    1 {
			global errorInfo
			set scalesLoopLock 0
			<font color="#208020">#error &#34;$result $errorInfo&#34;</font>
			error $result
		    }
		    2 {
			set scalesLoopLock 0
			return $result
		    }
		    3 {
			set scalesLoopLock 0
			return
		    }
		    4 {continue}
		    default {}
		}
	    }
	}
    }
    set scaleId -1
    set scalesLoopLock 0

    return $result
}


<font color="#208020"># imStudy::foreachscale --</font>
<font color="#208020"># usage : imStudy::foreachscale octList voxList script</font>
<font color="#208020">#</font>
<font color="#208020">#   Loop on the scales of $scaleList. Here is the list of modified variables :</font>
<font color="#208020"># scale, scaleId, scaleIdF, oct and vox.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   script    - script to execute.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The result of the last command of the loop.</font>

<strong><a name="imStudy::foreachscale_642">proc <a href="imStudy.tcl-annot.html#imStudy::foreachscale">imStudy::foreachscale</a></a></strong><a name="imStudy::foreachscale"></a> {script} {
    variable amin
    variable noct
    variable octList
    variable nvox
    variable voxList
    variable scale
    variable scaleId
    variable scaleIdF
    variable oct
    variable vox
    variable scalesLoopLock

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    if {$scalesLoopLock == 1} {
	return -code error &#34;there's an other running scales loop&#34;
    }
    set scalesLoopLock 1

    <font color="#208020">#set beginId $scaleId</font>

    foreach oct $octList vox $voxList {
	set scale [expr $amin*pow(2,$oct+($vox/double($nvox)))]
	set scale [expr $scale*(6/0.86)]
	set scaleId [expr $oct*$nvox+$vox]
	set scaleIdF [format &#34;%.3d&#34; $scaleId]
	set code [catch {uplevel $script} result]
	switch $code {
	    1 {
		global errorInfo
		set scalesLoopLock 0
		<font color="#208020">#error &#34;$result $errorInfo&#34;</font>
		error $result
	    }
	    2 {
		set scalesLoopLock 0
		return $result
	    }
	    3 {
		set scalesLoopLock 0
		return
	    }
	    4 {continue}
	    default {}
	    
	}
    }

    set scaleId -1
    set scalesLoopLock 0
    
    return $result
}


<font color="#208020"># imStudy::setCurIm --</font>
<font color="#208020"># usage : imStudy::setCurIm int</font>
<font color="#208020">#</font>
<font color="#208020">#   Set the current image id. Here is the list of modified variables : imId and</font>
<font color="#208020"># imIdF. If the requested id is not valid (i.e. greater than max or lesser than</font>
<font color="#208020"># min) the nearest id is taken.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   int - value of the id.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The imId.</font>

<strong><a name="imStudy::setCurIm_714">proc <a href="imStudy.tcl-annot.html#imStudy::setCurIm">imStudy::setCurIm</a></a></strong><a name="imStudy::setCurIm"></a> {reqId} {
    variable first_image
    variable last_image
    variable imId
    variable imIdF

    if {$reqId &lt; $first_image} {
	set reqId $first_image
    }
    if {$reqId &gt; $last_image} {
	set reqId $last_image
    }
    set imId $reqId
    set imIdF [format &#34;%.2d&#34; $reqId]

    return $imId
}


<font color="#208020"># imStudy::imagesLoop --</font>
<font color="#208020"># usage : imStudy::imagesLoop script</font>
<font color="#208020">#</font>
<font color="#208020">#   Loop on the images of the study. Here is the list of modified variables :</font>
<font color="#208020"># imId and imIdF.  The loop begins at the image corresponding to the value of</font>
<font color="#208020"># imId before the loop.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   script  - script to execute.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The result of the last command of the loop.</font>

<strong><a name="imStudy::imagesLoop_746">proc <a href="imStudy.tcl-annot.html#imStudy::imagesLoop">imStudy::imagesLoop</a></a></strong><a name="imStudy::imagesLoop"></a> {script} {
    variable first_image
    variable last_image
    variable imId
    variable imIdF
    variable imagesLoopLock

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    if {$imagesLoopLock == 1} {
	return -code error &#34;there's an other running images loop&#34;
    }
    set imagesLoopLock 1

    set beginId $imId

    for {set i $first_image} {$i &lt;= $last_image} {incr i} {
	if {$i &gt;= $beginId} {
	    set imId $i
	    set imIdF [format &#34;%.2d&#34; $i]
	    set code [catch {uplevel $script} result]
	    switch $code {
		1 {
		    global errorInfo
		    set imagesLoopLock 0
		    <font color="#208020">#error &#34;$result $errorInfo&#34;</font>
		    error $result
		}
		2 {
		    set imagesLoopLock 0
		    return $result
		}
		3 {
		    set imagesLoopLock 0
		    return
		}
		4 {continue}
		default {}
	    }
	}
    }
    set imId -1
    set imagesLoopLock 0

    return $result
}


<font color="#208020"># imStudy::foreachImage --</font>
<font color="#208020"># usage : imStudy::foreachImage script</font>
<font color="#208020">#</font>
<font color="#208020">#   Loop on the images of the study; id numbers must be specified in</font>
<font color="#208020"># a variable images_lst.</font>
<font color="#208020"># Here is the list of modified variables :</font>
<font color="#208020"># imId and imIdF.  The loop begins at the image corresponding to the value of</font>
<font color="#208020"># imId before the loop.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   script  - script to execute.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The result of the last command of the loop.</font>

<strong><a name="imStudy::foreachImage_812">proc <a href="imStudy.tcl-annot.html#imStudy::foreachImage">imStudy::foreachImage</a></a></strong><a name="imStudy::foreachImage"></a> {script} {
    variable first_image
    variable last_image
    variable imId
    variable imIdF
    variable foreachImageLock
    variable images_lst

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    if {$foreachImageLock == 1} {
	return -code error &#34;there's an other running images loop : foreachImage&#34;
    }
    set foreachImageLock 1

    set beginId $imId

    foreach i $images_lst {
	if {$i &gt;= $beginId} {
	    set imId $i
	    set imIdF [format &#34;%.3d&#34; $i]
	    set code [catch {uplevel $script} result]
	    switch $code {
		1 {
		    global errorInfo
		    set foreachImageLock 0
		    <font color="#208020">#error &#34;$result $errorInfo&#34;</font>
		    error $result
		}
		2 {
		    set foreachImageLock 0
		    return $result
		}
		3 {
		    set foreachImageLock 0
		    return
		}
		4 {continue}
		default {}
	    }
	}
    }
    set imId -1
    set foreachImageLock 0

    return $result
}




<font color="#208020"># imStudy::ConvolOneScale -- PRIVATE</font>
<font color="#208020"># usage : imStudy::ConvolOneScale str str real str str</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the convolution at one scale with a filter.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - Path for the image that contains the fourier transform of the</font>
<font color="#208020">#            source image.</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Scale of the convolution.</font>
<font color="#208020">#   string - Expression for the real part of the fourier transform of the</font>
<font color="#208020">#            filter.</font>
<font color="#208020">#   string - Expression for the imaginary part of the fourier transform of the</font>
<font color="#208020">#            filter.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::ConvolOneScale_884">proc <a href="imStudy.tcl-annot.html#imStudy::ConvolOneScale">imStudy::ConvolOneScale</a></a></strong><a name="imStudy::ConvolOneScale"></a> {ftPath cvName scale expr1 expr2} {
    variable useDiskSwap
    variable useFftw
    variable inMemory

    if {$inMemory==1} {
	<font color="#208020"># Tourier image is in memory, we just need to copy it</font>
	icopy $ftPath $cvName
    } else {
	<font color="#208020"># Fourier image is on disk, we need to load it</font>
	iload $ftPath $cvName
    }
    if {$useFftw == 1} {
	<font color="#208020">#logMsg &#34;ConvolOneScale with fftw...&#34;</font>
	<font color="#208020">#logMsg &#34;ifftwfilter $cvName $scale $expr1 $expr2&#34;</font>
	ifftwfilter $cvName $scale $expr1 $expr2
	ifftw2d $cvName
	<font color="#208020">#logMsg &#34;debug convol fftw...&#34;</font>
    } else {
	iconvol $cvName gah $scale -new $expr1 $expr2
	igfft   $cvName $cvName -reverse
    }

    if {$useDiskSwap == 1} {
	isave $cvName
	delete $cvName
    }
}


<font color="#208020"># imStudy::ConvolOneScale3D -- PRIVATE</font>
<font color="#208020"># usage : imStudy::ConvolOneScale3D str str real str str</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the convolution at one scale with a filter (3D data).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - Path for the image that contains the fourier transform of the</font>
<font color="#208020">#            source image.</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Scale of the convolution.</font>
<font color="#208020">#   string - Expression for the real part of the fourier transform of the</font>
<font color="#208020">#            filter.</font>
<font color="#208020">#   string - Expression for the imaginary part of the fourier transform of the</font>
<font color="#208020">#            filter.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::ConvolOneScale3D_932">proc <a href="imStudy.tcl-annot.html#imStudy::ConvolOneScale3D">imStudy::ConvolOneScale3D</a></a></strong><a name="imStudy::ConvolOneScale3D"></a> {ftPath cvName scale args} {
    <font color="#208020">#variable useDiskSwap</font>
    variable wavelet
    variable useFftw

    i3Dload $ftPath $cvName
    
    switch -exact -- $wavelet {

	gaussian {
	    ifftw3dfilter $cvName $scale -gaussian $args 
	    ifftw3d $cvName	
	}
	mexican {
	    ifftw3dfilter $cvName $scale -mexican $args 
	    ifftw3d $cvName
	}

    }

<font color="#208020">#     if {$useDiskSwap == 1} {</font>
<font color="#208020"># 	i3Dsave $cvName</font>
<font color="#208020"># 	delete $cvName</font>
<font color="#208020">#     }</font>
}


<font color="#208020"># imStudy::LoadAndCut -- PRIVATE</font>
<font color="#208020"># usage : imStudy::LoadAndCut list int int int</font>
<font color="#208020">#</font>
<font color="#208020"># blabla....</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   list  - names of the images</font>
<font color="#208020">#   2 int - coordinates of the cut</font>
<font color="#208020">#   int   - size of the cut</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None</font>

<strong><a name="imStudy::LoadAndCut_972">proc <a href="imStudy.tcl-annot.html#imStudy::LoadAndCut">imStudy::LoadAndCut</a></a></strong><a name="imStudy::LoadAndCut"></a> {imLst x y n} {
    foreach name $imLst {
	iload $name
	iicut $name $name $x $y $n $n
    }

    return
}


<strong><a name="imStudy::SeekLoad_982">proc <a href="imStudy.tcl-annot.html#imStudy::SeekLoad">imStudy::SeekLoad</a></a></strong><a name="imStudy::SeekLoad"></a> {imLst pos length} {
    foreach name $imLst {
	iload $name -seek $pos $length
    }

    return
}


<font color="#208020"># imStudy::LoadAndInsertAndSave -- PRIVATE</font>
<font color="#208020"># usage : imStudy::LoadAndInsertAndSave list int int</font>
<font color="#208020">#</font>
<font color="#208020"># blabla....</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   list  - names of the images</font>
<font color="#208020">#   2 int  - coordinates of the insert</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None</font>

<strong><a name="imStudy::LoadAndInsertAndSave_1003">proc <a href="imStudy.tcl-annot.html#imStudy::LoadAndInsertAndSave">imStudy::LoadAndInsertAndSave</a></a></strong><a name="imStudy::LoadAndInsertAndSave"></a> {imLst x y} {
    foreach name $imLst {
	iload $name __LoadAndInsertAndSave_tmp
	iinsert __LoadAndInsertAndSave_tmp $name $x $y
	isave __LoadAndInsertAndSave_tmp $name
    }
    delete __LoadAndInsertAndSave_tmp

    return
}


<strong><a name="imStudy::SeekSave_1015">proc <a href="imStudy.tcl-annot.html#imStudy::SeekSave">imStudy::SeekSave</a></a></strong><a name="imStudy::SeekSave"></a> {imLst pos length} {
    foreach name $imLst {
	isave $name -seek $pos $length
    }

    return
}


<font color="#208020"># imStudy::WtmmgCurrentScale -- PRIVATE</font>
<font color="#208020"># usage : imStudy::WtmmgCurrentScale str args</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the wtmm at the current scale using the gradient lines method.</font>
<font color="#208020"># This command computes the modulus and the argument for each point of the image</font>
<font color="#208020"># and the contour lines.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - Path for the image that contains the fourier transform of the</font>
<font color="#208020">#            source image.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   List of names of the new (ext) images : modulus image, argument image and</font>
<font color="#208020"># contour lines ext image.</font>

<strong><a name="imStudy::WtmmgCurrentScale_1039">proc <a href="imStudy.tcl-annot.html#imStudy::WtmmgCurrentScale">imStudy::WtmmgCurrentScale</a></a></strong><a name="imStudy::WtmmgCurrentScale"></a> {ftPath args} {
    variable size
    variable partSize
    variable scale
    variable scaleIdF
    variable wavelet
    variable gaussianDef
    variable mexicanDef
    variable gaussianDef_FFTW
    variable mexicanDef_FFTW
    variable useDiskSwap
    variable useCv2d
    variable useFftw
    variable useNMaxSup
    variable inMemory
    variable imageName
    variable imagePath
    variable cv2dPath
    variable baseDir

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    <font color="#208020"># remember that if inMemory is equal to 1, ftPath is an image instead of </font>
    <font color="#208020"># just a path to an image</font>

    <font color="#208020"># set default values for options</font>
    set isVector2d 0
    set is3d 0
    
    <font color="#208020"># Arguments analysis</font>
    set oldArgs $args
    while {[string match -* $args]} {
	switch -exact -- [lindex $args 0] {
	    -vector2d {
		set isVector2d 1
		set ftPath2 [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -3d {
		set is3d 1
		set args [lreplace $args 0 0]
	    }
	    default {
		return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;
	    }
	}
    }
    
    if {$isVector2d == 1} {
	switch -exact -- $wavelet {
	    gaussian {
		ConvolOneScale $ftPath  dx1 $scale $gaussianDef_FFTW(dx,r) $gaussianDef_FFTW(dx,i)
		ConvolOneScale $ftPath2 dx2 $scale $gaussianDef_FFTW(dx,r) $gaussianDef_FFTW(dx,i)
		ConvolOneScale $ftPath  dy1 $scale $gaussianDef_FFTW(dy,r) $gaussianDef_FFTW(dy,i)
		ConvolOneScale $ftPath2 dy2 $scale $gaussianDef_FFTW(dy,r) $gaussianDef_FFTW(dy,i)
	    }
	    mexican {
		ConvolOneScale $ftPath  dx1 $scale $mexicanDef_FFTW(dx,r) $mexicanDef_FFTW(dx,i)
		ConvolOneScale $ftPath2 dx2 $scale $mexicanDef_FFTW(dx,r) $mexicanDef_FFTW(dx,i)
		ConvolOneScale $ftPath  dy1 $scale $mexicanDef_FFTW(dy,r) $mexicanDef_FFTW(dy,i)
		ConvolOneScale $ftPath2 dy2 $scale $mexicanDef_FFTW(dy,r) $mexicanDef_FFTW(dy,i)
	    }
	}
    } elseif {$is3d == 1} {
	<font color="#208020"># the wavelet type (gaussian or mexican) is tested inside</font>
	<font color="#208020"># ConvolOneScale3D</font>
	ConvolOneScale3D $ftPath dx $scale -x
	ConvolOneScale3D $ftPath dy $scale -y
	ConvolOneScale3D $ftPath dz $scale -z
    } else {
	<font color="#208020"># scalar 2d    </font>
	switch -exact -- $wavelet {
	    gaussian {
		if {$useFftw == 1} {
		    <font color="#208020">#logMsg &#34;using fftw...&#34;</font>
		    ConvolOneScale $ftPath dx	$scale $gaussianDef_FFTW(dx,r)	$gaussianDef_FFTW(dx,i)
		    ConvolOneScale $ftPath dy	$scale $gaussianDef_FFTW(dy,r)	$gaussianDef_FFTW(dy,i)
		    if {$useNMaxSup == 0} {
			ConvolOneScale $ftPath dxx	$scale $gaussianDef_FFTW(dxx,r)	$gaussianDef_FFTW(dxx,i)
			ConvolOneScale $ftPath dxy	$scale $gaussianDef_FFTW(dxy,r)	$gaussianDef_FFTW(dxy,i)
			ConvolOneScale $ftPath dyy	$scale $gaussianDef_FFTW(dyy,r)	$gaussianDef_FFTW(dyy,i)
			ConvolOneScale $ftPath dxxx	$scale $gaussianDef_FFTW(dxxx,r)	$gaussianDef_FFTW(dxxx,i)
			ConvolOneScale $ftPath dxxy	$scale $gaussianDef_FFTW(dxxy,r)	$gaussianDef_FFTW(dxxy,i)
			ConvolOneScale $ftPath dxyy	$scale $gaussianDef_FFTW(dxyy,r)	$gaussianDef_FFTW(dxyy,i)
			ConvolOneScale $ftPath dyyy	$scale $gaussianDef_FFTW(dyyy,r)	$gaussianDef_FFTW(dyyy,i)
		    }
		} else { 
		    <font color="#208020"># use gfft</font>
		    ConvolOneScale $ftPath dx	$scale $gaussianDef(dx,r)	$gaussianDef(dx,i)
		    ConvolOneScale $ftPath dy	$scale $gaussianDef(dy,r)	$gaussianDef(dy,i)
		    if {$useNMaxSup == 0} {
			ConvolOneScale $ftPath dxx	$scale $gaussianDef(dxx,r)	$gaussianDef(dxx,i)
			ConvolOneScale $ftPath dxy	$scale $gaussianDef(dxy,r)	$gaussianDef(dxy,i)
			ConvolOneScale $ftPath dyy	$scale $gaussianDef(dyy,r)	$gaussianDef(dyy,i)
			ConvolOneScale $ftPath dxxx	$scale $gaussianDef(dxxx,r)	$gaussianDef(dxxx,i)
			ConvolOneScale $ftPath dxxy	$scale $gaussianDef(dxxy,r)	$gaussianDef(dxxy,i)
			ConvolOneScale $ftPath dxyy	$scale $gaussianDef(dxyy,r)	$gaussianDef(dxyy,i)
			ConvolOneScale $ftPath dyyy	$scale $gaussianDef(dyyy,r)	$gaussianDef(dyyy,i)
		    }
		}
	    }
	    mexican {
		if {$useCv2d == 0} {
		    if {$useFftw == 1} {
			ConvolOneScale $ftPath dx	$scale $mexicanDef_FFTW(dx,r)	$mexicanDef_FFTW(dx,i)
			ConvolOneScale $ftPath dy	$scale $mexicanDef_FFTW(dy,r)	$mexicanDef_FFTW(dy,i)
			if {$useNMaxSup == 0} {
			    ConvolOneScale $ftPath dxx	$scale $mexicanDef_FFTW(dxx,r)	$mexicanDef_FFTW(dxx,i)
			    ConvolOneScale $ftPath dxy	$scale $mexicanDef_FFTW(dxy,r)	$mexicanDef_FFTW(dxy,i)
			    ConvolOneScale $ftPath dyy	$scale $mexicanDef_FFTW(dyy,r)	$mexicanDef_FFTW(dyy,i)
			    ConvolOneScale $ftPath dxxx	$scale $mexicanDef_FFTW(dxxx,r)	$mexicanDef_FFTW(dxxx,i)
			    ConvolOneScale $ftPath dxxy	$scale $mexicanDef_FFTW(dxxy,r)	$mexicanDef_FFTW(dxxy,i)
			    ConvolOneScale $ftPath dxyy	$scale $mexicanDef_FFTW(dxyy,r)	$mexicanDef_FFTW(dxyy,i)
			    ConvolOneScale $ftPath dyyy	$scale $mexicanDef_FFTW(dyyy,r)	$mexicanDef_FFTW(dyyy,i)
			}
		    } else {
			ConvolOneScale $ftPath dx	$scale $mexicanDef(dx,r)	$mexicanDef(dx,i)
			ConvolOneScale $ftPath dy	$scale $mexicanDef(dy,r)	$mexicanDef(dy,i)
			if {$useNMaxSup == 0} {
			    ConvolOneScale $ftPath dxx	$scale $mexicanDef(dxx,r)	$mexicanDef(dxx,i)
			    ConvolOneScale $ftPath dxy	$scale $mexicanDef(dxy,r)	$mexicanDef(dxy,i)
			    ConvolOneScale $ftPath dyy	$scale $mexicanDef(dyy,r)	$mexicanDef(dyy,i)
			    ConvolOneScale $ftPath dxxx	$scale $mexicanDef(dxxx,r)	$mexicanDef(dxxx,i)
			    ConvolOneScale $ftPath dxxy	$scale $mexicanDef(dxxy,r)	$mexicanDef(dxxy,i)
			    ConvolOneScale $ftPath dxyy	$scale $mexicanDef(dxyy,r)	$mexicanDef(dxyy,i)
			    ConvolOneScale $ftPath dyyy	$scale $mexicanDef(dyyy,r)	$mexicanDef(dyyy,i)
			}
		}
		} else {
		    <font color="#208020"># the following is old and probably not working...</font>
		    <font color="#208020"># to be removed ???</font>
		    if {$useDiskSwap == 1} {
			iload $imagePath __image_[pid]
			foreach w {dx dy dxx dxy dyy dxxx dxxy dxyy dyyy} {
			    iload ${cv2dPath}/${w}$scaleIdF __wavelet
			    cv2dn __image_[pid] __wavelet __res -mp
			    isave __res $w
			}
			delete __wavelet
			delete __res
			delete __image_[pid]
		    } else {
			foreach w {dx dy dxx dxy dyy dxxx dxxy dxyy dyyy} {
			    iload ${cv2dPath}/${w}$scaleIdF __wavelet
			    cv2dn $imageName __wavelet $w -mp
			}
			delete __wavelet
		    }
		}
	    }
	}
    }


    <font color="#208020">#</font>
    <font color="#208020"># here begins the computation of the wtmm lines</font>
    <font color="#208020">#</font>
    if {$useDiskSwap == 0} {
	if {$useNMaxSup == 1} {
	    <font color="#208020"># use a simple non-maxima suppression routine</font>
	    <font color="#208020">#logMsg &#34;computing WTMM lines with non-maxima suppression routine&#34;</font>
	    if {$isVector2d == 1} {
		<font color="#208020"># vector 2d</font>
		wtmm2d dx1 dy1 max${scaleIdF} $scale mod$scaleIdF arg$scaleIdF -vector dx2 dy2
	    } elseif {$is3d == 1} {
		<font color="#208020"># scalar 3d</font>
		wtmm3d dx dy dz max${scaleIdF} $scale mod$scaleIdF mmax$scaleIdF
	    } else {
		<font color="#208020"># scalar 2d</font>
		wtmm2d dx dy max${scaleIdF} $scale mod$scaleIdF arg$scaleIdF
	    }
	} else {
	    <font color="#208020"># use a more computational intensive method; see code of</font>
	    <font color="#208020"># the C-defined routine named follow in interpreter/wt2d_cmds.c</font>
	    garg dx dy arg$scaleIdF
	    gmod dx dy mod$scaleIdF
	    gkapap kapap${scaleIdF} dx dxx dy dyy dxy dxxx dxxy dxyy dyyy
	    delete dxxx dxxy dxyy dyyy
	    gkapa kapa${scaleIdF} dx dxx dy dyy dxy
	    delete dx dy dxx dxy dyy
	    
	    variable followVersion
	    
	    switch $followVersion {
		0 {
		    follow kapa${scaleIdF} kapap${scaleIdF} \
			mod${scaleIdF} arg${scaleIdF} max$scaleIdF $scale -old
		}
		1 {
		    follow kapa${scaleIdF} kapap${scaleIdF} \
			mod${scaleIdF} arg${scaleIdF} max$scaleIdF $scale
		}
		2 {
		    follow kapa${scaleIdF} kapap${scaleIdF} \
			mod${scaleIdF} arg${scaleIdF} max$scaleIdF $scale -v2
		}
		default {
		    follow kapa${scaleIdF} kapap${scaleIdF} \
			mod${scaleIdF} arg${scaleIdF} max$scaleIdF $scale
		}
	    }
	    
	    delete kapa${scaleIdF}
	    delete kapap${scaleIdF}
	}
    } else {
	set nb [expr $size/$partSize]
	inull mod${scaleIdF} $size
	isave mod${scaleIdF}
	delete mod${scaleIdF}
	inull arg${scaleIdF} $size
	isave arg${scaleIdF}
	delete arg${scaleIdF}
	inull kapa${scaleIdF} $size
	isave kapa${scaleIdF}
	delete kapa${scaleIdF}
	inull kapap${scaleIdF} $size
	isave kapap${scaleIdF}
	delete kapap${scaleIdF}

	set dataSize [expr { $size*$size }]
	set length [expr { $partSize*$partSize }]

	for {set pos 0} {$pos &lt; $dataSize} {incr pos $length} {
	    if {$pos+$length &gt; $dataSize} {
		set length [expr { $dataSize-$pos }]
	    }
	    SeekLoad {dx dxx dy dyy dxy dxxx dxxy dxyy dyyy} $pos $length
	    garg dx dy arg$scaleIdF
	    gmod dx dy mod$scaleIdF
	    gkapap kapap${scaleIdF} dx dxx dy dyy dxy dxxx dxxy dxyy dyyy
	    delete dxxx dxxy dxyy dyyy
	    gkapa kapa${scaleIdF} dx dxx dy dyy dxy
	    delete dx dy dxx dxy dyy
	    SeekSave [list mod$scaleIdF arg$scaleIdF kapa${scaleIdF} kapap${scaleIdF}] $pos $length
	}

	delete arg${scaleIdF}
	delete mod${scaleIdF}

	iload kapa${scaleIdF}
	iload kapap${scaleIdF}
	follow2 kapa${scaleIdF} kapap${scaleIdF} max$scaleIdF $scale
	delete kapap${scaleIdF} kapa${scaleIdF}

	for {set pos 0} {$pos &lt; $dataSize} {incr pos $length} {
	    if {$pos+$length &gt; $dataSize} {
		set length [expr { $dataSize-$pos }]
	    }
	    iload arg${scaleIdF} -seek $pos $length $size
	    eiset max$scaleIdF \
		    -arg arg${scaleIdF} \
		    -position [expr {$pos%$size}] [expr {$pos/$size}] \
		    -flag
	    iload mod${scaleIdF} -seek $pos $length $size
	    iload kapa${scaleIdF} -seek $pos $length $size
	    eiset max$scaleIdF \
		    -mod mod${scaleIdF} kapa${scaleIdF} \
		    -position [expr {$pos%$size}] [expr {$pos/$size}] \
		    -flag
	}
	delete kapa${scaleIdF}

	file delete dx
	file delete dy
	file delete dxx
	file delete dxy
	file delete dyy
	file delete dxxx
	file delete dxxy
	file delete dxyy
	file delete dyyy
	file delete mod${scaleIdF}
	file delete arg${scaleIdF}
	file delete kapa${scaleIdF}
	file delete kapap${scaleIdF}
    }

    if {$is3d == 1} {
	return [list mod${scaleIdF} max$scaleIdF mmax$scaleIdF]
    } else {
	return [list mod${scaleIdF} arg${scaleIdF} max$scaleIdF]
    }
}


<font color="#208020"># imStudy::logMsg --</font>
<font color="#208020"># usage : imStudy::logMsg str</font>
<font color="#208020">#</font>
<font color="#208020">#   Log a message in a way determined by the &#34;logCmd&#34; package variable.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   str - The string to log.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::logMsg_1339">proc <a href="imStudy.tcl-annot.html#imStudy::logMsg">imStudy::logMsg</a></a></strong><a name="imStudy::logMsg"></a> {msgStr} {
    variable logCmd

    catch {$logCmd $msgStr}
}


<font color="#208020"># imStudy::updateSpectrum --</font>
<font color="#208020"># usage : imStudy::updateSpectrum image</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute, (eventually) add and save a 2d spectrum using the fourier transform</font>
<font color="#208020"># of an image.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   image - The fourier transform of the image (gfft format).</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::updateSpectrum_1358">proc <a href="imStudy.tcl-annot.html#imStudy::updateSpectrum">imStudy::updateSpectrum</a></a></strong><a name="imStudy::updateSpectrum"></a> {gfftIm} {
    variable spFileName
    variable size

    if {$spFileName == {}} {
	return
    }

    <font color="#208020"># Get the path from the name description.</font>

    set theNamespace [namespace current]
    set theSpFileName [namespace inscope $theNamespace {subst $spFileName}]

    <font color="#208020"># Load or create the base spectrum</font>

    if {[file exists $theSpFileName] == 1} {
	iload $theSpFileName __isp
    } else {
	inull __isp $size
    }

    <font color="#208020"># Compute the current spectrum.</font>

    igfft2ri $gfftIm __r __i
    icomb __r __r x*x __r2_tmp
    icomb __i __i y*y __i2_tmp
    icomb __r2_tmp __i2_tmp x+y __isp_tmp
    iswap __isp_tmp

    <font color="#208020"># Add and save.</font>

    icomb __isp __isp_tmp x+y __isp
    isave __isp $theSpFileName

    delete __r __i __r2_tmp __i2_tmp __isp __isp_tmp

    return
}


<font color="#208020"># imStudy::wtmmg --</font>
<font color="#208020"># usage : imStudy::wtmmg str [[&#34;cond&#34;] expr] script</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the wtmm at all current scales using the gradient lines method. For</font>
<font color="#208020"># each scale this command computes the modulus and the argument for each point</font>
<font color="#208020"># of the image and the contour lines.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - Image name.</font>
<font color="#208020">#   expr   - At each scale this expression is evaluated. If it is false the wtmm</font>
<font color="#208020">#            is not computed for this scale and the script is not executed.</font>
<font color="#208020">#   script - Script to execute.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The result of the last command of the loop.</font>

<strong><a name="imStudy::wtmmg_1414">proc <a href="imStudy.tcl-annot.html#imStudy::wtmmg">imStudy::wtmmg</a></a></strong><a name="imStudy::wtmmg"></a> {args} {
    variable scale
    variable scaleId
    variable oct
    variable vox
    variable spFileName
    variable useCv2d
    variable useFftw
    variable useDiskSwap
    variable inMemory

    variable imageName

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    <font color="#208020"># Get args.</font>

    switch [llength $args] {
	4 {
	    <font color="#208020"># The second arg must be the string &#34;cond&#34;</font>

	    if {[string compare [lindex $args 1] &#34;cond&#34;] != 0} {
		return -code error &#34;wrong \# args: extra words after body script in \&#34;wtmmg\&#34; command&#34;
	    }
	    set image [lindex $args 0]
	    set condition [lindex $args 2]
	    set script [lindex $args 3]
	}
	3 {
	    set image [lindex $args 0]
	    set condition [lindex $args 1]
	    set script [lindex $args 2]
	}
	2 {
	    set image [lindex $args 0]
	    set condition 1
	    set script [lindex $args 1]
	}
	1 {
	    return -code error &#34;wrong \# args: no script after image name&#34;
	}
	0 {
	    return -code error &#34;wrong \# args: no image name&#34;
	}
	default {
	    return -code error &#34;wrong \# args: extra words after body script in \&#34;wtmmg\&#34; command&#34;
	}
    }

    set theDir [pwd]

    if {$useFftw == 1} {
	isave   $image __image_[pid] 
	ifftw2d $image
	if {$inMemory == 1} {
	    icopy   $image __ft_[pid]
	} else {
	    isave   $image __ft_[pid]
	}
	delete  $image
    } elseif {$useCv2d == 0} {
	igfft   $image __ft_[pid]
	isave   $image __image_[pid]
	delete  $image
	isave   __ft_[pid]

	if {$spFileName != {}} {
	    updateSpectrum __ft_[pid]
	}

	delete  __ft_[pid]
    } else {
	set imageName $image
	if {$useDiskSwap == 1} {
	    isave   $image __image_[pid]
	    delete  $image
	    variable imagePath
	    set imagePath [pwd]/__image_[pid]
	}
    }

    set result {}
    
    scalesLoop {
	if [uplevel expr $condition] {
	    logMsg &#34;  Octave $oct - vox $vox - scale $scale ( $scaleId )&#34;
	    set result [WtmmgCurrentScale __ft_[pid]]
	    set modId [lindex $result 0]
	    set argId [lindex $result 1]
	    set maxId [lindex $result 2]
	    set code [catch {uplevel $script} result]
	    switch $code {
		1 {
		    if {$useCv2d == 0} {
			iload ${theDir}/__image_[pid] $image
			catch {file delete ${theDir}/__image_[pid]}
			catch {file delete ${theDir}/__ft_[pid]}
		    }
			error $result
		}
		2 {
		    if {$useCv2d == 0} {
			iload ${theDir}/__image_[pid] $image
			catch {file delete ${theDir}/__image_[pid]}
			catch {file delete ${theDir}/__ft_[pid]}
		    }
		    return $result}
		3 {break}
		4 {continue}
		default {}
	    }
	}
    }

    if {$useCv2d == 0} {
	iload ${theDir}/__image_[pid] $image
	catch {file delete ${theDir}/__image_[pid]}
	catch {file delete ${theDir}/__ft_[pid]}
    }

    return $result
}


<font color="#208020"># imStudy::wtmmg2d_vector --</font>
<font color="#208020"># usage : imStudy::wtmmg2d_vector str [[&#34;cond&#34;] expr] script</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the wtmm of a 2D -&gt; 2D vector field at all current scales using</font>
<font color="#208020"># the gradient lines method. For each scale this command computes the modulus</font>
<font color="#208020"># and the argument for each point of the image and the contour lines.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - Image name.</font>
<font color="#208020">#   expr   - At each scale this expression is evaluated. If it is false the wtmm</font>
<font color="#208020">#            is not computed for this scale and the script is not executed.</font>
<font color="#208020">#   script - Script to execute.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The result of the last command of the loop.</font>

<strong><a name="imStudy::wtmmg2d_vector_1557">proc <a href="imStudy.tcl-annot.html#imStudy::wtmmg2d_vector">imStudy::wtmmg2d_vector</a></a></strong><a name="imStudy::wtmmg2d_vector"></a> {args} {
    variable scale
    variable scaleId
    variable oct
    variable vox
    variable spFileName
    variable useCv2d
    variable useFftw
    variable useDiskSwap

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    <font color="#208020"># Get args.</font>

    switch [llength $args] {
	5 {
	    <font color="#208020"># The third arg must be the string &#34;cond&#34;</font>

	    if {[string compare [lindex $args 2] &#34;cond&#34;] != 0} {
		return -code error &#34;wrong \# args: extra words after body script in \&#34;wtmmg2d_vector\&#34; command&#34;
	    }
	    set image1 [lindex $args 0]
	    set image2 [lindex $args 1]
	    set condition [lindex $args 3]
	    set script [lindex $args 4]
	}
	4 {
	    set image1 [lindex $args 0]
	    set image2 [lindex $args 1]
	    set condition [lindex $args 2]
	    set script [lindex $args 3]
	}
	3 {
	    set image1 [lindex $args 0]
	    set image2 [lindex $args 1]
	    set condition 1
	    set script [lindex $args 2]
	}
	2 {
	    return -code error &#34;wrong \# args: no script after image name&#34;
	}
	1 {
	    return -code error &#34;wrong \# args: only one image name given&#34;
	}
	0 {
	    return -code error &#34;wrong \# args: no image names&#34;
	}
	default {
	    return -code error &#34;wrong \# args: extra words after body script in \&#34;wtmmg2d_vector\&#34; command&#34;
	}
    }

    set theDir [pwd]

    if {$useFftw == 1} {
	isave   $image1 __image1_[pid] 
	ifftw2d $image1
	isave   $image1 __ft1_[pid]	
	delete  $image1

	isave   $image2 __image2_[pid] 
	ifftw2d $image2
	isave   $image2 __ft2_[pid]	
	delete  $image2
    }

    set result {}
    scalesLoop {
	if [uplevel expr $condition] {
	    logMsg &#34;  Octave $oct - vox $vox - scale $scale ( $scaleId )&#34;
	    set result [WtmmgCurrentScale $theDir/__ft1_[pid] $theDir/__ft2_[pid]]
	    set modId [lindex $result 0]
	    set argId [lindex $result 1]
	    set maxId [lindex $result 2]
	    set code [catch {uplevel $script} result]
	}
    }

    catch {file delete ${theDir}/__image1_[pid]}
    catch {file delete ${theDir}/__image2_[pid]}
    catch {file delete ${theDir}/__ft1_[pid]}
    catch {file delete ${theDir}/__ft2_[pid]}
    
    return $result
}


<font color="#208020"># imStudy::wtmmg3d_scalar --</font>
<font color="#208020"># usage : imStudy::wtmmg3d_scalar str [[&#34;cond&#34;] expr] script</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the wtmm of a 3D scalar field at all current scales using</font>
<font color="#208020"># the gradient surfaces method. For each scale this command computes the </font>
<font color="#208020"># modulus and the argument for each point of the image and the contour</font>
<font color="#208020"># surfaces.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - Image name.</font>
<font color="#208020">#   expr   - At each scale this expression is evaluated. </font>
<font color="#208020">#            If it is false the wtmm is not computed for this scale </font>
<font color="#208020">#            and the script is not executed.</font>
<font color="#208020">#   script - Script to execute.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The result of the last command of the loop.</font>

<strong><a name="imStudy::wtmmg3d_scalar_1665">proc <a href="imStudy.tcl-annot.html#imStudy::wtmmg3d_scalar">imStudy::wtmmg3d_scalar</a></a></strong><a name="imStudy::wtmmg3d_scalar"></a> {args} {
    variable scale
    variable scaleId
    variable oct
    variable vox
    variable spFileName
    variable useFftw
    variable useDiskSwap

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    <font color="#208020"># Get args.</font>

    switch [llength $args] {
	4 {
	    <font color="#208020"># The second arg must be the string &#34;cond&#34;</font>

	    if {[string compare [lindex $args 1] &#34;cond&#34;] != 0} {
		return -code error &#34;wrong \# args: extra words after body script in \&#34;wtmmg3d_scalar\&#34; command&#34;
	    }
	    set image [lindex $args 0]
	    set condition [lindex $args 2]
	    set script [lindex $args 3]
	}
	3 {
	    set image [lindex $args 0]
	    set condition [lindex $args 1]
	    set script [lindex $args 2]
	}
	2 {
	    set image [lindex $args 0]
	    set condition 1
	    set script [lindex $args 1]
	}
	1 {
	    return -code error &#34;wrong \# args: no script after image name&#34;
	}
	0 {
	    return -code error &#34;wrong \# args: no image name&#34;
	}
	default {
	    return -code error &#34;wrong \# args: extra words after body script in \&#34;wtmmg\&#34; command&#34;
	}
    }

    set theDir [pwd]


    i3Dsave $image __image_[pid] 
    ifftw3d $image
    i3Dsave $image __ft_[pid]	
    delete  $image
    

    set result {}
    scalesLoop {
	if [uplevel expr $condition] {
	    logMsg &#34;  Octave $oct - vox $vox - scale $scale ( $scaleId )&#34;
	    set result [WtmmgCurrentScale $theDir/__ft_[pid] -3d]
	    set modId [lindex $result 0]
	    set argId [lindex $result 1]
	    set maxId [lindex $result 2]
	    set code [catch {uplevel $script} result]
	}
    }

    catch {file delete ${theDir}/__image_[pid]}
    catch {file delete ${theDir}/__ft_[pid]}
    
    return $result
}


<font color="#208020"># imStudy::wtmmg_partial --</font>
<font color="#208020"># usage : imStudy::wtmmg_partial str [[&#34;cond&#34;] expr] script</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the wtmm at scales defined by the lists octList and voxList</font>
<font color="#208020">#  using the gradient lines method. For each scale this command computes</font>
<font color="#208020">#  the modulus and the argument for each point of the image and the</font>
<font color="#208020">#  contour lines.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - Image name.</font>
<font color="#208020">#   expr   - At each scale this expression is evaluated. If it is false</font>
<font color="#208020">#            the wtmm is not computed for this scale and the script is </font>
<font color="#208020">#            not executed.</font>
<font color="#208020">#   script - Script to execute.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The result of the last command of the loop.</font>

<strong><a name="imStudy::wtmmg_partial_1759">proc <a href="imStudy.tcl-annot.html#imStudy::wtmmg_partial">imStudy::wtmmg_partial</a></a></strong><a name="imStudy::wtmmg_partial"></a> {args} {
    variable scale
    variable scaleId
    variable oct
    variable octList
    variable vox
    variable voxList
    variable spFileName
    variable useCv2d
    variable useFftw
    variable useDiskSwap

    variable imageName

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    <font color="#208020"># Get args.</font>

    switch [llength $args] {
	4 {
	    <font color="#208020"># The second arg must be the string &#34;cond&#34;</font>

	    if {[string compare [lindex $args 1] &#34;cond&#34;] != 0} {
		return -code error &#34;wrong \# args: extra words after body script in \&#34;wtmmg\&#34; command&#34;
	    }
	    set image [lindex $args 0]
	    set condition [lindex $args 2]
	    set script [lindex $args 3]
	}
	3 {
	    set image [lindex $args 0]
	    set condition [lindex $args 1]
	    set script [lindex $args 2]
	}
	2 {
	    set image [lindex $args 0]
	    set condition 1
	    set script [lindex $args 1]
	}
	1 {
	    return -code error &#34;wrong \# args: no script after image name&#34;
	}
	0 {
	    return -code error &#34;wrong \# args: no image name&#34;
	}
	default {
	    return -code error &#34;wrong \# args: extra words after body script in \&#34;wtmmg\&#34; command&#34;
	}
    }

    set theDir [pwd]

    if {$useFftw == 1} {
	isave   $image __image_[pid] 
	ifftw2d $image
	isave   $image __ft_[pid]	
	delete  $image
    } elseif {$useCv2d == 0} {
	igfft   $image __ft_[pid]
	isave   $image __image_[pid]
	delete  $image
	isave   __ft_[pid]

	if {$spFileName != {}} {
	    updateSpectrum __ft_[pid]
	}

	delete  __ft_[pid]
    } else {
	set imageName $image
	if {$useDiskSwap == 1} {
	    isave   $image __image_[pid]
	    delete  $image
	    variable imagePath
	    set imagePath [pwd]/__image_[pid]
	}
    }

    set result {}
    
    <a name="foreachscale(1)"><a href="./hpcal_proc.tcl.html#foreachscale_814">foreachscale</a></a> {
	if [uplevel expr $condition] {
	    logMsg &#34;  Octave $oct - vox $vox - scale $scale ( $scaleId )&#34;
	    set result [WtmmgCurrentScale $theDir/__ft_[pid]]
	    set modId [lindex $result 0]
	    set argId [lindex $result 1]
	    set maxId [lindex $result 2]
	    set code [catch {uplevel $script} result]
	    switch $code {
		1 {
		    if {$useCv2d == 0} {
			iload ${theDir}/__image_[pid] $image
			catch {file delete ${theDir}/__image_[pid]}
			catch {file delete ${theDir}/__ft_[pid]}
		    }
			error $result
		}
		2 {
		    if {$useCv2d == 0} {
			iload ${theDir}/__image_[pid] $image
			catch {file delete ${theDir}/__image_[pid]}
			catch {file delete ${theDir}/__ft_[pid]}
		    }
		    return $result}
		    3 {break}
		    4 {continue}
		    default {}
		}
	    }
    }

    if {$useCv2d == 0} {
	iload ${theDir}/__image_[pid] $image
	catch {file delete ${theDir}/__image_[pid]}
	catch {file delete ${theDir}/__ft_[pid]}
    }

    return $result
}


<font color="#208020"># imStudy::GetBorderSize -- PRIVATE</font>
<font color="#208020">#</font>

<strong><a name="imStudy::GetBorderSize_1886">proc <a href="imStudy.tcl-annot.html#imStudy::GetBorderSize">imStudy::GetBorderSize</a></a></strong><a name="imStudy::GetBorderSize"></a> {} {
    variable amin
    variable noct
    variable nvox
    variable border_percent

    set no [expr $noct-1]
    set nv [expr $nvox-1]
    set scale_max [expr $amin*pow(2,$no+($nv/double($nvox)))]
    set scale_max [expr $scale_max*(6/0.86)]

    return [expr int($scale_max*$border_percent)]
}


<font color="#208020"># imStudy::GetScale -- PRIVATE</font>
<font color="#208020"># usage : imStudy::GetScale int</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the value of a scale according to its id.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   int - The scale id. Must be between 0 and the number of scales minus one.</font>
<font color="#208020">#         Can be the string &#34;first&#34; or the string &#34;last&#34;.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The value of the scale.</font>

<strong><a name="imStudy::GetScale_1913">proc <a href="imStudy.tcl-annot.html#imStudy::GetScale">imStudy::GetScale</a></a></strong><a name="imStudy::GetScale"></a> {theScaleId} {
    variable amin
    variable noct
    variable nvox

    switch $theScaleId {
	first {
	    set theScale [expr $amin*(6/0.86)]
	}
	last {
	    set no [expr $noct-1]
	    set nv [expr $nvox-1]
	    set theScale [expr $amin*pow(2,$no+($nv/double($nvox)))]
	    set theScale [expr $theScale*(6/0.86)]
	}
	default {
	    if {($theScaleId &lt; 0) || ($theScaleId &gt;= [expr $noct*$nvox])} {
		error &#34;wrong scaleId&#34;
	    }
	    set theScaleId [expr int($theScaleId)]
	    set theScale [expr $amin*pow(2,$theScaleId*1.0/$nvox)]
	    set theScale [expr $theScale*(6/0.86)]
	}
    }

    return $theScale
}


<font color="#208020"># imStudy::limitsG --</font>
<font color="#208020"># usage : imStudy::limitsG</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the min and the max value of the modulus of the gradient for all</font>
<font color="#208020"># the scales and for all the images of the study.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   None.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   A list with the min and the max.</font>

<strong><a name="imStudy::limitsG_1954">proc <a href="imStudy.tcl-annot.html#imStudy::limitsG">imStudy::limitsG</a></a></strong><a name="imStudy::limitsG"></a> {} {
    variable baseDir
    variable imIdF

    variable histFileName

    variable hist_min
    variable hist_max

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    set theDir [pwd]
    set ftPath ${theDir}/__ft_[pid]

    set hist_min 1e30
    set hist_max 0

    set histDir ${baseDir}/histograms
    catch {file mkdir ${histDir}}

    set border_size [GetBorderSize]

    imagesLoop {
	logMsg &#34;Image number $imIdF.&#34;
	iload ${baseDir}/${imIdF}/image image

	igfft   image __ft_[pid]
	delete  image
	isave   __ft_[pid] $ftPath
	delete  __ft_[pid]

	logMsg &#34;  setting the limits of the modulus histograms :&#34;
	logMsg &#34;    with the upper scale...&#34;
	set scale [GetScale last]
	ConvolOneScale $ftPath dx   $scale 0 x*exp(-x*x-y*y)
	ConvolOneScale $ftPath dy   $scale 0 y*exp(-x*x-y*y)
	gmod dx dy mod
	cutedge mod mod $border_size
	set result [im_extrema mod]
	set min_upper [lindex $result 0]
	set max_upper [lindex $result 1]

	logMsg &#34;    and the lower scale...&#34;
	set scale [GetScale first]
	ConvolOneScale $ftPath dx   $scale 0 x*exp(-x*x-y*y)
	ConvolOneScale $ftPath dy   $scale 0 y*exp(-x*x-y*y)
	gmod dx dy mod
	cutedge mod mod $border_size
	set result [im_extrema mod]
	set min_lower [lindex $result 0]
	set max_lower [lindex $result 1]

	if {$min_lower &lt; $hist_min} {
	    set hist_min $min_lower
	}
	if {$min_upper &lt; $hist_min} {
	    set hist_min $min_upper
	}
	if {$max_upper &gt; $hist_max} {
	    set hist_max $max_upper
	}
	if {$max_lower &gt; $hist_max} {
	    set hist_max $max_lower
	}
	logMsg &#34;&#34;
    }

    delete dx dy mod
    catch {file delete $ftPath} 

    logMsg &#34;The range of modulus histogram for all images is :&#34;
    logMsg &#34;  from $hist_min to $hist_max.&#34;
    logMsg &#34;&#34;

    set hist_file_id [open [getHistFile] w]
    puts $hist_file_id &#34;$hist_min&#34;
    puts $hist_file_id &#34;$hist_max&#34;
    close $hist_file_id

    return [list $hist_min $hist_max]
}


<font color="#208020"># imStudy::histInitG --</font>
<font color="#208020"># usage : imStudy::histInitG real real</font>
<font color="#208020">#</font>
<font color="#208020">#   Init the histograms for the gradient line method. Here is the list of the</font>
<font color="#208020"># histograms : modulus (1D), argument (1D) and gradient (2D). These histograms</font>
<font color="#208020"># are computed for the complete image, for contour lines and for the maxima on</font>
<font color="#208020"># the contour lines.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   real - The min value of the modulus of the gradient.</font>
<font color="#208020">#   real - The max value of the modulus of the gradient.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::histInitG_2055">proc <a href="imStudy.tcl-annot.html#imStudy::histInitG">imStudy::histInitG</a></a></strong><a name="imStudy::histInitG"></a> {hist_min hist_max} {
    variable pi
    variable m_pi
    variable nbox_mod
    variable nbox_arg
    variable calendos_size
    variable scaleIdF

    variable ishisto
    variable ismaxhisto

    variable baseDir
    variable histDirName

    variable imIdF

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    set histDir ${baseDir}/histograms
    catch {file mkdir ${histDir}}

    <font color="#208020"># Initialisation of the global histograms at each scale.</font>
    sinus histo_tmp 100
    shisto histo_tmp h_mod_tmp $nbox_mod -x $hist_min $hist_max
    shisto histo_tmp h_arg_tmp $nbox_arg -x $m_pi $pi
    delete histo_tmp

    sscamult h_mod_tmp 0.0 h_mod_tmp
    sscamult h_arg_tmp 0.0 h_arg_tmp

    inull calendos_tmp $calendos_size

    <font color="#208020">#if {$hist_min &gt; 0.0} {</font>
    <font color="#208020">#    set hist_log_min [expr log($hist_min)]</font>
    <font color="#208020">#} else {</font>
    <font color="#208020">#    set hist_log_min -15.0</font>
    <font color="#208020">#}</font>
    
    set hist_log_min [expr log($hist_min)]
    set hist_log_max [expr log($hist_max)]
    shisto histo_tmp h_log_mod_tmp $nbox_mod -x $hist_log_min $hist_log_max

    scalesLoop {
	if {$ishisto} {
	    <font color="#208020">#  Gradient histograms from all points (mod, arg, gradient vector)</font>
	    ssave h_mod_tmp ${histDir}/h_i_mod$scaleIdF -sw
	    ssave h_arg_tmp ${histDir}/h_i_arg$scaleIdF -sw
	    isave calendos_tmp ${histDir}/h_i_cal$scaleIdF
	}

	if {$ismaxhisto} {
	    <font color="#208020">#  Gradient histograms from all points on lines (mod, arg,</font>
	    <font color="#208020"># gradient vector)</font>
	    ssave h_mod_tmp ${histDir}/h_l_mod$scaleIdF -sw
	    ssave h_arg_tmp ${histDir}/h_l_arg$scaleIdF -sw
	    isave calendos_tmp ${histDir}/h_l_cal$scaleIdF

	    <font color="#208020">#  Gradient histograms from all max on lines (mod, arg, gradient</font>
	    <font color="#208020"># vector)</font>
	    ssave h_mod_tmp ${histDir}/h_m_mod$scaleIdF -sw
	    ssave h_arg_tmp ${histDir}/h_m_arg$scaleIdF -sw
	    isave calendos_tmp ${histDir}/h_m_cal$scaleIdF
	    ssave h_log_mod_tmp ${histDir}/h_m_lmo$scaleIdF -sw
	}
    }
    delete h_mod_tmp
    delete h_arg_tmp
    delete calendos_tmp

    return
}


<font color="#208020"># imStudy::SAddAndSave --</font>
<font color="#208020"># usage : imStudy::SAddAndSave sig str</font>
<font color="#208020">#</font>
<font color="#208020">#   Save a signal and eventually add it to a file. Use of the &#34;sw&#34; format.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   signal - Signal to save.</font>
<font color="#208020">#   str    - name of the resulting file.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::SAddAndSave_2143">proc <a href="imStudy.tcl-annot.html#imStudy::SAddAndSave">imStudy::SAddAndSave</a></a></strong><a name="imStudy::SAddAndSave"></a> {sig file} {
    if {[file exists $file] == 1} {
	sload  $file __SAddAndSave_tmp -sw
	sadd   __SAddAndSave_tmp $sig __SAddAndSave_tmp
	ssave  __SAddAndSave_tmp $file -sw
	delete __SAddAndSave_tmp
    } else {
	ssave $sig $file -sw
    }
    return
}


<font color="#208020"># imStudy::IAddAndSave --</font>
<font color="#208020"># usage : imStudy::IAddAndSave sig str</font>
<font color="#208020">#</font>
<font color="#208020">#   Save an image and eventually add it to a file.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   image - Image to save.</font>
<font color="#208020">#   str   - name of the resulting file.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::IAddAndSave_2168">proc <a href="imStudy.tcl-annot.html#imStudy::IAddAndSave">imStudy::IAddAndSave</a></a></strong><a name="imStudy::IAddAndSave"></a> {sig file} {
    if {[file exists $file] == 1} {
	iload  $file __IAddAndSave_tmp
	iadd   __IAddAndSave_tmp $sig __IAddAndSave_tmp
	isave  __IAddAndSave_tmp $file
	delete __IAddAndSave_tmp
    } else {
	isave $sig $file
    }
    return
}


<font color="#208020"># imStudy::getHistDir --</font>
<font color="#208020"># usage : imStudy::getHistDir</font>
<font color="#208020">#</font>
<font color="#208020">#   Get the path for the current histograms directory.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   None.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The path.</font>

<strong><a name="imStudy::getHistDir_2192">proc <a href="imStudy.tcl-annot.html#imStudy::getHistDir">imStudy::getHistDir</a></a></strong><a name="imStudy::getHistDir"></a> {} {
    set theNamespace [namespace current]
    set histDir [namespace inscope $theNamespace {subst $histDirName}]

    return $histDir
}


<font color="#208020"># imStudy::getHistFile --</font>
<font color="#208020"># usage : imStudy::getHistFile</font>
<font color="#208020">#</font>
<font color="#208020">#   Get the path for the current histograms min/max file.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   None.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The path.</font>

<strong><a name="imStudy::getHistFile_2211">proc <a href="imStudy.tcl-annot.html#imStudy::getHistFile">imStudy::getHistFile</a></a></strong><a name="imStudy::getHistFile"></a> {} {
    set theNamespace [namespace current]
    set histFile [namespace inscope $theNamespace {subst $histFileName}]

    return $histFile
}


<font color="#208020"># imStudy::getLogHistFile --</font>
<font color="#208020"># usage : imStudy::getLogHistFile</font>
<font color="#208020">#</font>
<font color="#208020">#   Get the path for the current histograms min/max file.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   None.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The path.</font>

<strong><a name="imStudy::getLogHistFile_2230">proc <a href="imStudy.tcl-annot.html#imStudy::getLogHistFile">imStudy::getLogHistFile</a></a></strong><a name="imStudy::getLogHistFile"></a> {} {
    set theNamespace [namespace current]
    set histFile [namespace inscope $theNamespace {subst $logHistFileName}]

    return $histFile
}


<font color="#208020"># imStudy::iHistOneScaleG --</font>
<font color="#208020"># usage : imStudy::iHistOneScaleG str</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the histograms at one scale on all the points of a wavelet</font>
<font color="#208020"># transform. Then the results are added to possibly previous histograms</font>
<font color="#208020"># for this scale, and the they are saved on disk. The modulus and</font>
<font color="#208020"># argument images for this scale must be in memory.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   str - The formatted scale id.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::iHistOneScaleG_2252">proc <a href="imStudy.tcl-annot.html#imStudy::iHistOneScaleG">imStudy::iHistOneScaleG</a></a></strong><a name="imStudy::iHistOneScaleG"></a> {theScaleIdF} {
    variable nbox_mod
    variable nbox_arg
    variable calendos_size
    variable pi
    variable m_pi
    variable baseDir
    variable histDirName

    variable hist_max
    variable hist_min

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    set theNamespace [namespace current]
    set histDir [namespace inscope $theNamespace {subst $histDirName}]

    set mod mod${theScaleIdF}
    set arg arg${theScaleIdF}

    <font color="#208020"># Get histograms parameters</font>
    set histFile [getHistFile]

    if {[file exists $histFile]} {
	set hist_file_id [open $histFile r]
	gets $hist_file_id hist_min
	gets $hist_file_id hist_max
	close $hist_file_id
    }

    <font color="#208020"># Modulus histogram (1D).</font>
    if {$hist_max == &#34;none&#34; || $hist_min == &#34;none&#34;} {
	ihisto $mod __tmp $nbox_mod
    } else {
	ihisto $mod __tmp $nbox_mod -x $hist_min $hist_max 
    }
    SAddAndSave __tmp ${histDir}/h_i_mod${theScaleIdF}

    <font color="#208020"># Argument histogram (1D).</font>
    ihisto $arg __tmp $nbox_arg -x $m_pi $pi
    SAddAndSave __tmp ${histDir}/h_i_arg${theScaleIdF}

    <font color="#208020"># Gradient histogram (2D).</font>
    if {$hist_max == &#34;none&#34; || $hist_min == &#34;none&#34;} {
	<font color="#208020">#ihisto $mod __tmp $calendos_size -grad $arg</font>
    } else {
	<font color="#208020">#ihisto $mod __tmp $calendos_size -x -$hist_max $hist_max -grad $arg</font>
    }
    <font color="#208020">#IAddAndSave __tmp ${histDir}/h_i_cal${theScaleIdF}</font>

    delete __tmp

    return
}


<font color="#208020"># imStudy::lHistOneScaleG --</font>
<font color="#208020"># usage : imStudy::lHistOneScaleG str [str]</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the histograms at one scale on contour lines of a </font>
<font color="#208020"># wavelet transform. Then the results are added to possibly previous </font>
<font color="#208020"># histograms for this scale, and then they are saved on disk. The </font>
<font color="#208020"># corresponding ext images must be in memory.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   str - The formatted scale id.</font>
<font color="#208020">#   [str] - The base name of the ext images. Default is &#34;max&#34;.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::lHistOneScaleG_2326">proc <a href="imStudy.tcl-annot.html#imStudy::lHistOneScaleG">imStudy::lHistOneScaleG</a></a></strong><a name="imStudy::lHistOneScaleG"></a> {theScaleIdF {baseName max} {xmin -0.5} {xmax 0.5}} {
    variable nbox_mod
    variable nbox_arg
    variable nbox_gradx
    variable nbox_grady
    variable calendos_size
    variable pi
    variable m_pi
    variable baseDir
    variable histDirName

    variable hist_max
    variable hist_min

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    set theNamespace [namespace current]
    set histDir [namespace inscope $theNamespace {subst $histDirName}]

    set max ${baseName}${theScaleIdF}

    <font color="#208020"># Get histograms parameters</font>
    set histFile [getHistFile]

    if {[file exists $histFile]} {
	set hist_file_id [open $histFile r]
	gets $hist_file_id hist_min
	gets $hist_file_id hist_max
	close $hist_file_id
    }

    <font color="#208020"># Modulus histogram (1D).</font>
    if {$hist_max == &#34;none&#34; || $hist_min == &#34;none&#34;} {
	ehisto2 $max __tmp $nbox_mod 
    } else {
	ehisto2 $max __tmp $nbox_mod -x $hist_min $hist_max 
    }
    SAddAndSave __tmp ${histDir}/h_l_mod${theScaleIdF}

    <font color="#208020"># Argument histogram (1D).</font>
    ehisto2 $max __tmp $nbox_arg -x $m_pi $pi -arg
    SAddAndSave __tmp ${histDir}/h_l_arg${theScaleIdF}

    <font color="#208020"># Gradx histogram (1D).</font>
    ehisto2 $max __tmp $nbox_gradx  -x $xmin $xmax -gradx
    SAddAndSave __tmp ${histDir}/h_l_gradx${theScaleIdF}

    <font color="#208020"># Grady histogram (1D).</font>
    ehisto2 $max __tmp $nbox_grady  -x $xmin $xmax -grady
    SAddAndSave __tmp ${histDir}/h_l_grady${theScaleIdF}

            


    <font color="#208020"># Gradient histogram (2D).</font>
    if {$hist_max == &#34;none&#34; || $hist_min == &#34;none&#34;} {
	<font color="#208020">#ehisto2 $max __tmp $calendos_size -grad</font>
    } else {
	<font color="#208020">#ehisto2 $max __tmp $calendos_size -x -$hist_max $hist_max -grad</font>
    }
    <font color="#208020">#IAddAndSave __tmp ${histDir}/h_l_cal${theScaleIdF}</font>

    delete __tmp

    return
}


<font color="#208020"># imStudy::mHistOneScaleG --</font>
<font color="#208020"># usage : imStudy::mHistOneScaleG str [str]</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the histograms at one scale on maxima of the contour lines of a</font>
<font color="#208020"># wavelet transform. Then the results are added to possibly previous histograms</font>
<font color="#208020"># for this scale, and then they are saved on disk. The corresponding ext images</font>
<font color="#208020"># must be in memory.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   str   - The formatted scale id.</font>
<font color="#208020">#   [str] - The base name of the ext images. Default is &#34;max&#34;.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::mHistOneScaleG_2412">proc <a href="imStudy.tcl-annot.html#imStudy::mHistOneScaleG">imStudy::mHistOneScaleG</a></a></strong><a name="imStudy::mHistOneScaleG"></a> {theScaleIdF {baseName max}} {
    variable nbox_mod
    variable nbox_arg
    variable calendos_size
    variable pi
    variable m_pi
    variable baseDir
    variable histDirName
    variable histFileName
    variable logHistFileName

    variable hist_max
    variable hist_min

    variable studyId
    if {$studyId == &#34;none&#34;} {
	return -code error &#34;no current image study&#34;
    }

    set theNamespace [namespace current]
    set histDir [namespace inscope $theNamespace {subst $histDirName}]

    set max ${baseName}${theScaleIdF}

    <font color="#208020"># Get histograms parameters</font>
    set histFile [getHistFile]

    if {[file exists $histFile]} {
	set hist_file_id [open $histFile r]
	gets $hist_file_id hist_min
	gets $hist_file_id hist_max
	close $hist_file_id
    }

    <font color="#208020"># Modulus histogram (1D).</font>
    if {$hist_max == &#34;none&#34; || $hist_min == &#34;none&#34;} {
	ehisto2 $max __tmp $nbox_mod -vc
    } else {
	ehisto2 $max __tmp $nbox_mod -x $hist_min $hist_max -vc
    }
    SAddAndSave __tmp ${histDir}/h_m_mod${theScaleIdF}

    <font color="#208020"># Argument histogram (1D).</font>
    ehisto2 $max __tmp $nbox_arg -x $m_pi $pi -arg -vc
    SAddAndSave __tmp ${histDir}/h_m_arg${theScaleIdF}

    <font color="#208020"># Gradient histogram (2D).</font>
    if {$hist_max == &#34;none&#34; || $hist_min == &#34;none&#34;} {
	ehisto2 $max __tmp $calendos_size -grad -vc
    } else {
	ehisto2 $max __tmp $calendos_size -x -$hist_max $hist_max -grad -vc
    }
    IAddAndSave __tmp ${histDir}/h_m_cal${theScaleIdF}

    <font color="#208020"># Log of the modulus histogram (1D).</font>
    if {$hist_max == &#34;none&#34; || $hist_min == &#34;none&#34;} {
	ehisto2 $max __tmp $nbox_mod -vc  -fct log(x)
    } else {
	if {[string compare $logHistFileName &#34;none&#34;] == 0} {
	    if {$hist_min &gt; 0} {
		set hist_log_min [expr log($hist_min)]
	    } else {
		return -code error &#34;minimum for log histograms must be strictly positive&#34;
	    }
	} else {
	    set logHistFile [getLogHistFile]

	    set hist_file_id [open $logHistFile r]
	    gets $hist_file_id hist_log_min
	    gets $hist_file_id hist_log_max
	    close $hist_file_id
	}
	set hist_log_max [expr log($hist_max)]
	ehisto2 $max __tmp $nbox_mod -x $hist_log_min $hist_log_max -vc -fct log(x)
    }
    SAddAndSave __tmp ${histDir}/h_m_lmo${theScaleIdF}

    delete __tmp

    return
}


<font color="#208020"># imStudy::convHistName --</font>
<font color="#208020"># usage : imStudy::convHistName str</font>
<font color="#208020">#</font>
<font color="#208020">#   Convert histogram file names from a format to an other (old and new).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - Must be &#34;new2old&#34; or &#34;old2new&#34;.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::convHistName_2506">proc <a href="imStudy.tcl-annot.html#imStudy::convHistName">imStudy::convHistName</a></a></strong><a name="imStudy::convHistName"></a> {{way new2old}} {
    <font color="#208020">#  h_mod			-&gt; h_i_mod	: image modulus histogram.</font>
    <font color="#208020">#  h_arg			-&gt; h_i_arg	: image argument histogram.</font>
    <font color="#208020">#  calendos_image		-&gt; h_i_cal	: image gradient histogram.</font>
    <font color="#208020">#  h_max_mod		-&gt; h_l_mod	: contour lines modulus histogram.</font>
    <font color="#208020">#  h_max_arg		-&gt; h_l_arg	: contour lines argument histogram.</font>
    <font color="#208020">#  calendos_max		-&gt; h_l_cal	: contour lines gradient histogram.</font>
    <font color="#208020">#  h_max_line_mod		-&gt; h_m_mod	: maxima (on contour lines) modulus</font>
    <font color="#208020">#						  histogram.</font>
    <font color="#208020">#  h_max_line_arg		-&gt; h_m_arg	: maxima (on contour lines) argument</font>
    <font color="#208020">#						  histogram.</font>
    <font color="#208020">#  calendos_max_line	-&gt; h_m_cal	: maxima (on contour lines) gradient</font>
    <font color="#208020">#					  	histogram.</font>
    variable scaleIdF
    variable baseDir

    switch -- $way {
	new2old {
	    scalesLoop {
		file rename ${baseDir}/histograms/h_i_mod$scaleIdF \
			${baseDir}/histograms/h_mod$scaleIdF
		file rename ${baseDir}/histograms/h_i_arg$scaleIdF \
			${baseDir}/histograms/h_arg$scaleIdF
		file rename ${baseDir}/histograms/h_i_cal$scaleIdF \
			${baseDir}/histograms/calendos_image$scaleIdF

		file rename ${baseDir}/histograms/h_l_mod$scaleIdF \
			${baseDir}/histograms/h_max_mod$scaleIdF
		file rename ${baseDir}/histograms/h_l_arg$scaleIdF \
			${baseDir}/histograms/h_max_arg$scaleIdF
		file rename ${baseDir}/histograms/h_l_cal$scaleIdF \
			${baseDir}/histograms/calendos_max$scaleIdF

		file rename ${baseDir}/histograms/h_m_mod$scaleIdF \
			${baseDir}/histograms/h_max_line_mod$scaleIdF
		file rename ${baseDir}/histograms/h_m_arg$scaleIdF \
			${baseDir}/histograms/h_max_linearg$scaleIdF
		file rename ${baseDir}/histograms/h_m_cal$scaleIdF \
			${baseDir}/histograms/calendos_max_line$scaleIdF
	    }
	}   
	old2new {
	    scalesLoop {
		file rename ${baseDir}/histograms/h_mod$scaleIdF \
			${baseDir}/histograms/h_i_mod$scaleIdF
		file rename ${baseDir}/histograms/h_arg$scaleIdF \
			${baseDir}/histograms/h_i_arg$scaleIdF			
		file rename ${baseDir}/histograms/calendos_image$scaleIdF \
			${baseDir}/histograms/h_i_cal$scaleIdF

		file rename ${baseDir}/histograms/h_max_mod$scaleIdF \
			${baseDir}/histograms/h_l_mod$scaleIdF
		file rename ${baseDir}/histograms/h_max_arg$scaleIdF \
			${baseDir}/histograms/h_l_arg$scaleIdF
		file rename ${baseDir}/histograms/calendos_max$scaleIdF \
			${baseDir}/histograms/h_l_cal$scaleIdF

		file rename ${baseDir}/histograms/h_max_line_mod$scaleIdF \
			${baseDir}/histograms/h_m_mod$scaleIdF			
		file rename ${baseDir}/histograms/h_max_linearg$scaleIdF \
			${baseDir}/histograms/h_m_arg$scaleIdF			
		file rename ${baseDir}/histograms/calendos_max_line$scaleIdF \
			${baseDir}/histograms/h_m_cal$scaleIdF
	    }
	}   
    }

    return
}


<font color="#208020"># imStudy::hidisp --</font>
<font color="#208020"># usage : imStudy::hidisp int int list [list]</font>
<font color="#208020">#</font>
<font color="#208020">#   Open a window that displays 1D histograms.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   integer - Number of columns of the window.</font>
<font color="#208020">#   integer - Number of lines of the window.</font>
<font color="#208020">#   list    - The list of histograms to display (i.e. h_m_mod, h_i_arg, ...)</font>
<font color="#208020">#   list    - The list of scales to display. Default will be the first voice of</font>
<font color="#208020">#             each octave.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The name of the window.</font>

<strong><a name="imStudy::hidisp_2592">proc <a href="imStudy.tcl-annot.html#imStudy::hidisp">imStudy::hidisp</a></a></strong><a name="imStudy::hidisp"></a> {nC nL histLst {scaleIdLst &#34;&#34;}} {
    array set histLabel {
	h_i_mod &#34;Module&#34; \
	h_l_mod &#34;Module (lines)&#34; \
	h_m_mod &#34;Module (max)&#34; \
	h_i_arg &#34;Argument&#34; \
	h_l_arg &#34;Argument (lines)&#34; \
	h_m_arg &#34;Argument (max)&#34;
    }

    if {$histLst == &#34;all&#34;} {
	<font color="#208020"># We take all kind of 1D histograms.</font>

	set histLst {h_i_mod h_i_arg h_l_mod h_l_arg h_m_mod h_m_arg}
    }

    if {$scaleIdLst == &#34;&#34;} {
	<font color="#208020"># We take the first voice of each octave.</font>

	variable vox
	variable scaleId

	scalesLoop {
	    if {$vox == 0} {
		lappend scaleIdLst $scaleId
	    }
	}
    }

    set w [<a name="hdisp(1)"><a href="./histogram.tcl.html#hdisp_454">hdisp</a></a> $nC $nL $histLst $scaleIdLst]

    set i 0
    for {set c 0} {$c &lt; $nC} {incr c} {
	set cF [format &#34;%.2d&#34; $c]
	for {set l 0} {$l &lt; $nL} {incr l} {
	    set lF [format &#34;%.2d&#34; $l]
	    set theHist [lindex $histLst $i]
	    set theLabel $histLabel($theHist)
	    ${w}gr$cF$lF set_label [list black $theLabel] allSigLabel
	    incr i
	    if {$i == [llength $histLst]} {
		break
	    }
	}
	if {$i == [llength $histLst]} {
	    break
	}
    }

    variable studyName
    variable wavelet
    $w setLabel &#34;histograms - $studyName - $wavelet&#34;
    $w switch_allgraph_flag
    $w gr set_disp_mode all
    $w gr init_disp

    return $w
}


<font color="#208020"># imStudy::hread --</font>
<font color="#208020"># usage : imStudy::hread [int]</font>
<font color="#208020">#</font>
<font color="#208020">#   Read 1D histograms from files.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   [int] - Value of the zoom.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="imStudy::hread_2663">proc <a href="imStudy.tcl-annot.html#imStudy::hread">imStudy::hread</a></a></strong><a name="imStudy::hread"></a> {{zoom &#34;&#34;}} {
    <a name="gsload(1)"><a href="./hpcal_proc.tcl.html#gsload_506">gsload</a></a> h_i_mod $zoom
    <a name="gsload(2)"><a href="./hpcal_proc.tcl.html#gsload_506">gsload</a></a> h_i_arg $zoom
    <a name="gsload(3)"><a href="./hpcal_proc.tcl.html#gsload_506">gsload</a></a> h_l_mod $zoom
    <a name="gsload(4)"><a href="./hpcal_proc.tcl.html#gsload_506">gsload</a></a> h_l_arg $zoom
    <a name="gsload(5)"><a href="./hpcal_proc.tcl.html#gsload_506">gsload</a></a> h_m_mod $zoom
    <a name="gsload(6)"><a href="./hpcal_proc.tcl.html#gsload_506">gsload</a></a> h_m_arg $zoom
    return
}

<font color="#208020"># Here are some commonly used scripts.</font>

namespace eval imStudy {

    <font color="#208020"># initHistScr --</font>
    <font color="#208020">#</font>
    <font color="#208020">#   Init all needed histograms if parameter &#34;ishistoinit&#34; is set to 1. Each</font>
    <font color="#208020"># histogram is set to 0 and save on the &#34;histograms&#34; directory.</font>

    set initHistScr {
	if {$ishistoinit} {
	    if {$isgaussian} {
		logMsg &#34;Histograms init (Gradient).&#34;
		<a name="lassign(1)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {hm hM} [limitsG]
		histInitG $hm $hM
	    }
	}
    }

    <font color="#208020"># computeWtmmgOneImageScr --</font>
    <font color="#208020">#</font>
    <font color="#208020">#   Compute the wtmm on the current image using the gradient method. For</font>
    <font color="#208020"># each scale an ext image is saved on disk.</font>
    <font color="#208020">#   If parameter &#34;iscontpart&#34; is set to 1, this script computes the</font>
    <font color="#208020"># partition functions of the modulus for all the image.</font>
    <font color="#208020">#   If parameter &#34;ishisto&#34; is set to 1, this script compute the histograms</font>
    <font color="#208020"># (mod, arg and gradient) for all the image.</font>

    set computeWtmmgOneImageScr {
	iload ${baseDir}/${imIdF}/image image
	wtmmg image {
	    cutedge mod$scaleIdF mod$scaleIdF $border_size
	    cutedge arg$scaleIdF arg$scaleIdF $border_size

	    <font color="#208020"># The following commented lines are not a default behavior.</font>
	    <font color="#208020"># Uncomment tem in a new script if you need them.</font>
	    <font color="#208020">#set border [expr $size-$border_size]</font>
	    <font color="#208020">#rm_ext max$scaleIdF max$scaleIdF $border_size $border $border_size $border</font>

	    esave max$scaleIdF ${baseDir}/${imIdF}/max$scaleIdF
	    if {$ishisto} {
		iHistOneScaleG $scaleIdF
	    }
	    if {$iscontpart} {
		<font color="#208020"># *** Sorry, no continuous partition functions for now... ***</font>
	    }
	    delete mod$scaleIdF
	    delete arg$scaleIdF
	    delete max$scaleIdF
	}
    }

    <font color="#208020"># pfInitScr --</font>
    <font color="#208020">#</font>
    <font color="#208020">#   Initialisation of the pf that will contain partition functions on</font>
    <font color="#208020"># contour lines and on their maxima.</font>

    set pfInitScr {
	set pfDir ${baseDir}/partition
	if {$first_image == 0} {
	    set lpf [<a name="pf(1)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> create]
	    <a name="pf(2)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> init $lpf $amin $noct $nvox $q_lst $size &#34;Gradient lines&#34; $studyName
	    set mpf [<a name="pf(3)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> create]
	    <a name="pf(4)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> init $mpf $amin $noct $nvox $q_lst $size &#34;Gradient max&#34; $studyName
	    if {$isthetapart} {
		set num 0
		foreach {theta d_theta name} $theta_lst {
		    array set mtpfId [list $num [<a name="pf(5)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> create]]
		    <a name="pf(6)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> init $mtpfId($num) $amin $noct $nvox $q_lst $size \
			    &#34;Gradient max - theta $theta dtheta $d_theta&#34; $studyName
		    incr num
		}
	    }
	} else {
	    set lpf [<a name="pf(7)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> create]
	    <a name="pf(8)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> load $lpf ${pfDir}/lpf
	    set mpf [<a name="pf(9)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> create]
	    <a name="pf(10)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> load $mpf ${pfDir}/mpf
	    if {$isthetapart} {
		set num 0
		foreach {theta d_theta name} $theta_lst {
		    array set mtpfId [list $num [<a name="pf(11)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> create]]
		    <a name="pf(12)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> load $mtpfId($num) ${pfDir}/mtpf$num
		    incr num
		}
	    }
	}
    }

    <font color="#208020"># computeMaxStatGOneImageScr --</font>
    <font color="#208020">#</font>
    <font color="#208020">#   Compute the partition functions on contour lines and on their maxima.</font>
    <font color="#208020">#   If &#34;ismaxhisto&#34; is set to 1, this script computes the histograms on</font>
    <font color="#208020"># contour lines and on their maxima.</font>

    set computeMaxStatGOneImageScr {
	set prevId -1
	scalesLoop {
	    set theMax max$scaleIdF
	    eload ${baseDir}/${imIdF}/max$scaleIdF $theMax
	    set border [expr $size-$border_size]
	    rm_ext max$scaleIdF max$scaleIdF $border_size $border $border_size $border
	    hsearch $theMax
	    ssm $theMax
	    
	    set box_size [expr int(log($scale)*2/log(2))]
	    if {$prevId == 0} {
		vchain max$prevIdF $theMax $box_size $similitude -first
	    } elseif {$prevId &gt; 0} {
		vchain max$prevIdF $theMax $box_size $similitude
	    }

	    set prevId  $scaleId
	    set prevIdF $scaleIdF
	}
	if {$ismaxhisto} {
	    logMsg &#34;Histograms on contour lines and their maxima.&#34;
	    scalesLoop {
		lHistOneScaleG $scaleIdF
		mHistOneScaleG $scaleIdF	    
	    }
	}
	set pfDir ${baseDir}/partition
	catch {file mkdir $pfDir}
	logMsg &#34;Partition functions on contour lines.&#34;
	<a name="pf(13)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> clear $lpf
	<a name="pf(14)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> init $lpf $amin $noct $nvox $q_lst $size &#34;Gradient lines&#34; $studyName
	<a name="pf(15)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> compute $lpf max
	<a name="pf(16)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> save $lpf ${baseDir}/${imIdF}/lpf
	if {$imId != 0} {
	    <a name="pf(17)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> load $lpf ${pfDir}/lpf
	}
	<a name="pf(18)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> save $lpf ${pfDir}/lpf

	logMsg &#34;Partition functions on contour lines maxima.&#34;
	<a name="pf(19)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> clear $mpf
	<a name="pf(20)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> init $mpf $amin $noct $nvox $q_lst $size &#34;Gradient max&#34; $studyName
	<a name="pf(21)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> compute $mpf max
	<a name="pf(22)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> save $mpf ${baseDir}/${imIdF}/mpf
	if {$imId != 0} {
	    <a name="pf(23)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> load $mpf ${pfDir}/mpf
	}
	<a name="pf(24)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> save $mpf ${pfDir}/mpf

	if {$isthetapart} {
	    logMsg &#34;Partition functions on contour lines maxima conditionned by theta.&#34;
	    set num 0
	    foreach {theta d_theta name} $theta_lst {
		<a name="pf(25)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> clear $mtpfId($num)
		<a name="pf(26)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> init $mtpfId($num) $amin $noct $nvox $q_lst $size \
			&#34;Gradient max - theta $theta dtheta $d_theta&#34; $studyName
		<a name="pf(27)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> compute $mtpfId($num) max
		<a name="pf(28)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> save $mtpfId($num) ${baseDir}/${imIdF}/mtpf$num
		if {$imId != 0} {
		    <a name="pf(29)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> load $mtpfId($num) ${pfDir}/mtpf$num
		}
		<a name="pf(30)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> save $mtpfId($num) ${pfDir}/mtpf$num
		incr num
	    }
	}
	scalesLoop {
	    delete max$scaleIdF
	}
    }

    <font color="#208020"># pfEndScr --</font>
    <font color="#208020">#</font>
    <font color="#208020">#   End all the pf.</font>

    set pfEndScr {
	<a name="pf(31)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> destroy $lpf
	<a name="pf(32)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> destroy $mpf
	if {$isthetapart} {
	    set num 0
	    foreach {theta d_theta name} $theta_lst {
		<a name="pf(33)"><a href="./partFcts.tcl.html#pf_56">pf</a></a> destroy $mtpfId($num)
		incr num
	    }
	}
    }

    <font color="#208020"># completeScr --</font>
    <font color="#208020">#</font>
    <font color="#208020">#   Calls &#34;properly&#34; (?!?) all the previous scripts...</font>

    set completeScr {
	init

	set logCmd dputs

	eval $initHistScr
	
	logMsg &#34;Computation.&#34;
	eval $pfInitScr

	if {$issave} {
	    catch {file mkdir sauve}
	}

	imagesLoop {
	    logMsg &#34;Image $imIdF&#34;
	    iload ${baseDir}/${imIdF}/image image
	    if {$isgaussian} {
		eval $computeWtmmgOneImageScr
	    }
	    logMsg &#34;Contour lines and maxima statistics.&#34;
	    eval $computeMaxStatGOneImageScr

	    if {$issave == 1} {
		exec cp -r ${baseDir}/partition ${baseDir}/sauve
		variable histDirName
		set histDir [getHistDir]
		exec cp -r $histDir ${baseDir}/sauve
	    }
	}
	eval $pfEndScr
	logMsg &#34;End.&#34;
    }

    <font color="#208020"># maxStatScr --</font>
    <font color="#208020">#</font>
    <font color="#208020">#   Compute stats on pre-computed ext images. For all the images.</font>

    set maxStatScr {
	init
	set logCmd dputs

	logMsg &#34;Computation.&#34;
	eval $pfInitScr
	imagesLoop {
	    logMsg &#34;Image $imIdF&#34;
	    logMsg &#34;Contour lines and maxima statistics.&#34;
	    eval $computeMaxStatGOneImageScr
	}
	eval $pfEndScr
	logMsg &#34;End.&#34;
    }

    <font color="#208020"># maxLinkScr --</font>
    <font color="#208020">#</font>
    <font color="#208020">#   Link all the ext image corresponding to the current image.</font>

    set maxLinkScr {
	set prevId -1
	scalesLoop {
	    set theMax max$scaleIdF
	    eload ${baseDir}/${imIdF}/max$scaleIdF $theMax
	    set border [expr $size-$border_size]
	    rm_ext max$scaleIdF max$scaleIdF $border_size $border $border_size $border
	    hsearch $theMax
	    ssm $theMax
	    
	    set box_size [expr int(log($scale)*2/log(2))]
	    if {$prevId == 0} {
		vchain max$prevIdF $theMax $box_size $similitude -first
	    } elseif {$prevId &gt; 0} {
		vchain max$prevIdF $theMax $box_size $similitude
	    }

	    set prevId  $scaleId
	    set prevIdF $scaleIdF
	}
    }

    <font color="#208020"># The following line is to avoid ugly effects when you source this file...</font>
    return
}
</pre>
<hr>
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#byfilename">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a><br>
<cite>File generated 2008-04-03 at 09:49.</cite>
</font>
</body>
</html>
