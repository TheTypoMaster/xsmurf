<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- Generated by TclDoc 0.3 -->
<html>
<head><title>histogram.tcl</title></head>
<body bgcolor="#ffffff">
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#histogram.tcl">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a>
</font>
<hr>
<strong>histogram.tcl</strong>
(<a href="histogram.tcl-annot.html">annotations</a> | <a href="histogram.tcl.txt">original source</a>)
<p>
<pre>
<font color="#208020"># histogram.tcl --</font>
<font color="#208020">#</font>
<font color="#208020">#       This file implements the Tcl code for histograms handling in general.</font>
<font color="#208020">#</font>
<font color="#208020">#   Copyright 1998 Centre de Recherche Paul Pascal, Bordeaux, France.</font>
<font color="#208020">#   Written by Nicolas Decoster.</font>
<font color="#208020">#</font>
<font color="#208020">#  RCS : $Id: histogram.tcl,v 1.5 1999/05/22 16:42:18 decoster Exp $</font>
<font color="#208020">#</font>

<font color="#208020"># last modified by Pierre Kestener (2000/04/12).</font>


package provide histogram 0.0

<font color="#208020"># snorm --</font>
<font color="#208020"># usage : snorm signal</font>
<font color="#208020">#</font>
<font color="#208020">#  Normalize a signal so that its integral is 1.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   signal - signale to treat.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None</font>

<strong><a name="snorm_27">proc <a href="histogram.tcl-annot.html#snorm">snorm</a></a></strong><a name="snorm"></a> {sig} {
    set norm 0.0
    sigloop $sig {
	set norm [expr { $norm + $y }]
    }
    set dx [sgetdx $sig]
    if {$norm != 0.0} {
	sscamult $sig [expr 1.0/($dx*$norm)] $sig
    }
    return
}


<font color="#208020"># snormall --</font>
<font color="#208020"># usage : snormall str</font>
<font color="#208020">#</font>
<font color="#208020">#  Normalize a serie of signals.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - base name of the signals.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None</font>

<strong><a name="snormall_51">proc <a href="histogram.tcl-annot.html#snormall">snormall</a></a></strong><a name="snormall"></a> {baseName} {
    set lst [ginfo ${baseName}* -list]
    foreach sig $lst {
	<a name="snorm(1)"><a href="./histogram.tcl.html#snorm_27">snorm</a></a> $sig
    }
    return
}


<font color="#208020"># hrescale --</font>
<font color="#208020"># usage : hrescale real str list</font>
<font color="#208020">#</font>
<font color="#208020">#  Rescale a serie of histograms at different scales by scale^alpha. And</font>
<font color="#208020"># compute the log of the rescale. See source code.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   real   - alpha : rescaling value.</font>
<font color="#208020">#   string - base name of the histograms.</font>
<font color="#208020">#   list   - list of scaleId. The ratio between each successive scale must be 2.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<strong><a name="hrescale_74">proc <a href="histogram.tcl-annot.html#hrescale">hrescale</a></a></strong><a name="hrescale"></a> {alpha baseName args} {
    set scaleRatio 1
	
    foreach scaleId $args {
	set fmtScaleId [format &#34;%.3d&#34; $scaleId]
	sload ${baseName}${fmtScaleId} histo${fmtScaleId}
	set s histo${fmtScaleId}

	<font color="#208020">#set s ${baseName}${fmtScaleId}</font>
	<font color="#208020">#set ss h_log_max_line_mod${fmtScaleId}</font>
	<font color="#208020">#echo $ss</font>
	set scaleR [expr pow($scaleRatio, $alpha)]
	set scaleR2 [expr $alpha*log($scaleRatio)]

	scopy $s r$s
	<a name="snorm(2)"><a href="./histogram.tcl.html#snorm_27">snorm</a></a> r$s
	sputdx r$s [expr [sgetdx r$s]/$scaleR]
	sputx0 r$s [expr [sgetx0 r$s]/$scaleR]

	<a name="snorm(3)"><a href="./histogram.tcl.html#snorm_27">snorm</a></a> r$s
	<a name="h2logh(1)"><a href="./histogram.tcl.html#h2logh_284">h2logh</a></a> r$s lr$s

	<font color="#208020">#scopy $ss r$ss</font>
	<font color="#208020">#sputx0 r$ss [expr [sgetx0 r$ss]-$scaleR2]</font>
	<font color="#208020">#snorm r$ss</font>
	<font color="#208020">#h2logh r$ss lr$ss</font>
	<font color="#208020">#sthresh r$ss r$ss -1 4</font>
	
	set scaleRatio [expr $scaleRatio*2.0]
    }
}


<font color="#208020"># hrescale2 --</font>
<font color="#208020"># usage : hrescale2 str str real real</font>
<font color="#208020">#</font>
<font color="#208020">#  Rescale an histogram by scale^alpha. Execute a h2logh command.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   string - Name of the histogram.</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Scale of the histogram.</font>
<font color="#208020">#   real   - Alpha: rescaling value.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Name of the result.</font>

<strong><a name="hrescale2_121">proc <a href="histogram.tcl-annot.html#hrescale2">hrescale2</a></a></strong><a name="hrescale2"></a> {src dest scale alpha} {
    set scaleR [expr pow($scale,$alpha)]

    scopy $src $dest
    <a name="snorm(4)"><a href="./histogram.tcl.html#snorm_27">snorm</a></a> $dest

    sputdx $dest [expr [sgetdx $dest]/$scaleR]
    sputx0 $dest [expr [sgetx0 $dest]/$scaleR]

    <a name="snorm(5)"><a href="./histogram.tcl.html#snorm_27">snorm</a></a> $dest
    <a name="h2logh(2)"><a href="./histogram.tcl.html#h2logh_284">h2logh</a></a> $dest $dest

    return $dest
}


<font color="#208020"># hrescale3 --</font>
<font color="#208020"># usage : hrescale3 str str real real</font>
<font color="#208020">#</font>
<font color="#208020">#  Rescale an histogram by scale^alpha.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   string - Name of the histogram.</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Scale of the histogram.</font>
<font color="#208020">#   real   - Alpha: rescaling value.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Name of the result.</font>

<strong><a name="hrescale3_151">proc <a href="histogram.tcl-annot.html#hrescale3">hrescale3</a></a></strong><a name="hrescale3"></a> {src dest scale alpha} {
    set scaleR [expr pow($scale,$alpha)]
    scopy $src $dest
    <a name="snorm(6)"><a href="./histogram.tcl.html#snorm_27">snorm</a></a> $dest

    sputdx $dest [expr [sgetdx $dest]/$scaleR]
    sputx0 $dest [expr [sgetx0 $dest]/$scaleR]

    <a name="snorm(7)"><a href="./histogram.tcl.html#snorm_27">snorm</a></a> $dest

    return $dest
}


<strong><a name="hrescalearg_165">proc <a href="histogram.tcl-annot.html#hrescalearg">hrescalearg</a></a></strong><a name="hrescalearg"></a> {alpha baseName {args}} {
    set scaleRatio 1

    foreach scaleId $args {
	set fmtScaleId [format &#34;%.3d&#34; $scaleId]
	set s ${baseName}${fmtScaleId}
	set ss h_log_max_line_mod${fmtScaleId}
	set scaleR [expr pow($scaleRatio, $alpha)]
	set scaleR2 [expr $alpha*log($scaleRatio)]

	scopy $s r$s

	sputdx r$s [expr [sgetdx r$s]]
	sputx0 r$s [expr [sgetx0 r$s]]
	s2fs r$s r$s x y/pow($scaleRatio,$alpha)
<font color="#208020">#	snorm r$s</font>
	set uu [expr pow($scaleRatio, $alpha)]
	puts $uu
	set scaleRatio [expr $scaleRatio*2.0]
    }
    return
}


<font color="#208020"># h2hlog --</font>
<font color="#208020"># usage : h2hlog signal [str]</font>
<font color="#208020">#</font>
<font color="#208020">#  Convert an histogram into the histogram of the log. In fact this proc creates</font>
<font color="#208020"># 2 histograms, one for the positive values and one for the negative values.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   signal - histogram to treat.</font>
<font color="#208020">#   string - the basename of the results.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The list of the name of the 2 created histograms.</font>

<strong><a name="h2hlog_202">proc <a href="histogram.tcl-annot.html#h2hlog">h2hlog</a></a></strong><a name="h2hlog"></a> {name {resName &#34;&#34;}} {
    if {$resName == &#34;&#34;} {
	set resName1 hlogpos_${name}
	set resName2 hlogneg${name}
    }

    set xPosLst {}
    set yPosLst {}
    set xNegLst {}
    set yNegLst {}

    set name2 h_${name}
    foreachs ${name2} {
	if {$x &gt; 0} {
	    lappend xPosLst [expr log($x)]
	    lappend yPosLst [expr $y*$x]
	}
	if {$x &lt; 0} {
	    lappend xNegLst [expr log(-$x)]
	    lappend yNegLst [expr $y*(-$x)]
	}
    }
    screate ${resName}p 0 1 $yPosLst -xy $xPosLst
    screate ${resName}m 0 1 $yNegLst -xy $xNegLst

    return [list ${resName}p ${resName}m]
}


<font color="#208020"># h2hlog2 --</font>
<font color="#208020"># usage : h2hlog2 signal [str]</font>
<font color="#208020">#</font>
<font color="#208020">#  Convert an histogram into the histogram of the log. In fact this proc creates</font>
<font color="#208020"># 2 histograms, one for the positive values and one for the negative values.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   signal - histogram to treat.</font>
<font color="#208020">#   string - the basename of the results.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The list of the name of the 2 created histograms.</font>

<strong><a name="h2hlog2_244">proc <a href="histogram.tcl-annot.html#h2hlog2">h2hlog2</a></a></strong><a name="h2hlog2"></a> {name {resName &#34;&#34;}} {
    if {$resName == &#34;&#34;} {
	set resName1 hlogpos_${name}
	set resName2 hlogneg${name}
    }

    set xPosLst {}
    set yPosLst {}
    set xNegLst {}
    set yNegLst {}

    foreachs ${name} {
	if {$x &gt; 0} {
	    lappend xPosLst [expr log($x)]
	    lappend yPosLst [expr $y*$x]
	}
	if {$x &lt; 0} {
	    lappend xNegLst [expr log(-$x)]
	    lappend yNegLst [expr $y*(-$x)]
	}
    }
    screate ${resName}p 0 1 $yPosLst -xy $xPosLst
    screate ${resName}m 0 1 $yNegLst -xy $xNegLst

    return [list ${resName}p ${resName}m]
}


<font color="#208020"># h2logh --</font>
<font color="#208020"># usage : h2logh signal [str]</font>
<font color="#208020">#</font>
<font color="#208020">#  Convert an histogram into the log of the histogram</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   signal - histogram to treat.</font>
<font color="#208020">#   string - basename of the results.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The name of the created histogram.</font>

<strong><a name="h2logh_284">proc <a href="histogram.tcl-annot.html#h2logh">h2logh</a></a></strong><a name="h2logh"></a> {name {resName &#34;&#34;}} {
    if {$resName == &#34;&#34;} {
	set resName log${name}
    }

    sigloop $name {
	if {$y &gt; 0} {
	    <font color="#208020"># Don't remove [expr $x] !!</font>
	    lappend xPosLst [expr $x]
	    lappend yPosLst [expr log($y)]
	}
    }

    screate ${resName} 0 1 $yPosLst -xy $xPosLst

    return ${resName}
}


<font color="#208020"># h2logh10 --</font>
<font color="#208020"># usage : h2logh signal [str]</font>
<font color="#208020">#</font>
<font color="#208020">#  Convert an histogram into the log (base 10) of the histogram</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   signal - histogram to treat.</font>
<font color="#208020">#   string - basename of the results.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The name of the created histogram.</font>

<strong><a name="h2logh10_315">proc <a href="histogram.tcl-annot.html#h2logh10">h2logh10</a></a></strong><a name="h2logh10"></a> {name {resName &#34;&#34;}} {
    if {$resName == &#34;&#34;} {
	set resName log10${name}
    }

    sigloop $name {
	if {$y &gt; 0} {
	    <font color="#208020"># Don't remove [expr $x] !!</font>
	    lappend xPosLst [expr $x]
	    lappend yPosLst [expr log($y)/log(10)]
	}
    }

    screate ${resName} 0 1 $yPosLst -xy $xPosLst

    return ${resName}
}


<font color="#208020"># h2powh --</font>
<font color="#208020"># usage : h2powh signal list [str]</font>
<font color="#208020">#</font>
<font color="#208020">#  Compute the q-power of an histogram according to :</font>
<font color="#208020">#    ph(x) = h(x)*pow(abs(x),q)</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   signal - histogram to treat.</font>
<font color="#208020">#   list   - list of the values of q.</font>
<font color="#208020">#   string - basename of the results.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   List of the new histograms.</font>

<strong><a name="h2powh_348">proc <a href="histogram.tcl-annot.html#h2powh">h2powh</a></a></strong><a name="h2powh"></a> {name qLst {resName &#34;&#34;}} {
    if {$resName == &#34;&#34;} {
	set resName ${name}_pow
    }

    foreach q $qLst {
	set qStr [<a name="get_q_str(1)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	set dx [sgetdx $name]
	set x0 [sgetx0 $name]
	set yPosLst &#34;&#34;
	if {$q &gt;= 0} {
	    sigloop $name {
		lappend yPosLst [expr pow(abs($x), $q)*$y]
	    } 
	} else {
	    sigloop $name {
		if {$x == 0} {
		    lappend yPosLst 0
		} else {
		    lappend yPosLst [expr pow(abs($x), $q)*$y]
		}
	    }
	}
	screate ${resName}${qStr} $x0 $dx $yPosLst
	lappend result ${resName}${qStr}
   }
   return $result
}


<font color="#208020"># h2powh2 --</font>
<font color="#208020"># usage: h2powh2 signal string real</font>
<font color="#208020">#</font>
<font color="#208020">#  Compute the q-power of an histogram according to :</font>
<font color="#208020">#    ph(x) = h(x)*pow(abs(x),q)</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal - histogram to treat.</font>
<font color="#208020">#   string - name of the result.</font>
<font color="#208020">#   list   - value of q.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Name of the result.</font>

<strong><a name="h2powh2_392">proc <a href="histogram.tcl-annot.html#h2powh2">h2powh2</a></a></strong><a name="h2powh2"></a> {name resName q} {
    set qStr [<a name="get_q_str(2)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
    set dx [sgetdx $name]
    set x0 [sgetx0 $name]
    set yPosLst &#34;&#34;
    if {$q &gt;= 0} {
	sigloop $name {
	    lappend yPosLst [expr pow(abs($x),$q)*$y]
	} 
    } else {
	sigloop $name {
	    if {$x == 0} {
		lappend yPosLst 0
	    } else {
		lappend yPosLst [expr pow(abs($x),$q)*$y]
	    }
	}
    }
    screate ${resName} $x0 $dx $yPosLst

    return $resName
}


<font color="#208020"># gh2powh --</font>
<font color="#208020"># usage : gh2powh str list list</font>
<font color="#208020">#</font>
<font color="#208020">#  Compute the q-power of histograms at different scales according to :</font>
<font color="#208020">#    ph(x) = h(x)*pow(abs(x),q)</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - base name of the histograms to treat.</font>
<font color="#208020">#   list   - list of scale id.</font>
<font color="#208020">#   list   - list of the values of q.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None</font>

<strong><a name="gh2powh_430">proc <a href="histogram.tcl-annot.html#gh2powh">gh2powh</a></a></strong><a name="gh2powh"></a> {baseName scaleIdLst qLst} {
    foreach scaleId $scaleIdLst {
	set scaleIdF [format &#34;%.3d&#34; $scaleId]
	set name ${baseName}${scaleIdF}
	<a name="h2powh(1)"><a href="./histogram.tcl.html#h2powh_348">h2powh</a></a> $name $qLst
    }
    return
}


<font color="#208020"># hdisp --</font>
<font color="#208020"># usage : hdisp int int list [list]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display different kind of histograms (or signals) at different scales.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   int    - Number of rows of graphs</font>
<font color="#208020">#   int    - Number of lines of graphs</font>
<font color="#208020">#   list   - list of histograms names.</font>
<font color="#208020">#   [list] - list of scale id's.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Name of the window.</font>

<strong><a name="hdisp_454">proc <a href="histogram.tcl-annot.html#hdisp">hdisp</a></a></strong><a name="hdisp"></a> {nRows nLines nameLst {lst &#34;&#34;}} {
    set completeLst {}
    foreach name $nameLst {
	if {$lst == &#34;&#34;} {
	    set sigLst [ginfo $name* -list]
	} else {
	    set sigLst {}
	    foreach value $lst {
		set new_value [format &#34;%.3d&#34; $value]
		set sigLst [lappend sigLst ${name}${new_value}]
	    }
	}
	set completeLst [lappend completeLst ${sigLst}]
    }
    set code [catch {mdisp $nRows $nLines ${completeLst}} result]
    if {$code != 0} {
	error $result $result
    }
    $result setColorsByList {black red green blue yellow brown slateblue}
    set itemList {}
    foreach value $lst {
	set itemList [lappend itemlist [list %c $value]]
    }
    eval $result setLabelsItemsByList $itemList
    return $result
}


<font color="#208020"># phdisp --</font>
<font color="#208020"># usage : phdisp str list list</font>
<font color="#208020">#</font>
<font color="#208020">#  Display q-powered histograms at different scales.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - base name of the histograms to treat.</font>
<font color="#208020">#   list   - list of scale id.</font>
<font color="#208020">#   list   - list of the values of q.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Name of the window.</font>

<strong><a name="phdisp_495">proc <a href="histogram.tcl-annot.html#phdisp">phdisp</a></a></strong><a name="phdisp"></a> {baseName scaleIdLst qLst} {
    set nRows 2
    set nLines [expr [llength $qLst]/2]
    set completeLst {}
    foreach q $qLst {
	set qStr [<a name="get_q_str(3)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	set sigLst {}
	foreach scale $scaleIdLst {
	    set new_scale [format &#34;%.3d&#34; $scale]
	    set sigLst [lappend sigLst ${baseName}${new_scale}_pow${qStr}]
	}
	set completeLst [lappend completeLst ${sigLst}]
    }
    set code [catch {mdisp $nRows $nLines ${completeLst}} result]
    if {$code != 0} {
	error $result $result
    }
    <font color="#208020">#$result setColorsByList {darkgreen darkcyan darkblue slateblue darkviolet}</font>
    $result setColorsByList {black red green blue}
    set itemList {}
    foreach scale $scaleIdLst {
	set itemList [lappend itemlist [list %c $scale]]
    }
    eval $result setLabelsItemsByList $itemList
    set l 0
    set r 0
    foreach q $qLst {
	set newL [format &#34;%.2d&#34; $l]
	set newR [format &#34;%.2d&#34; $r]
	${result}gr${newR}${newL} set_label [list black &#34;h pow $q   &#34;] allSigLabel
	incr l
	if {$l == $nLines} {
	    set l 0
	    set r 1
	}
    }
    return $result
}


<font color="#208020"># rhdisp --</font>
<font color="#208020"># usage : rhdisp list list list</font>
<font color="#208020">#</font>
<font color="#208020">#  This procedure is used to display a serie of linear and logarithm rescaled</font>
<font color="#208020"># histograms. The name have the following form : rh_${type}${scaleId} and</font>
<font color="#208020"># lrh_${type}${scaleId}.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   list - list of the types.</font>
<font color="#208020">#   list - list of the rescaling values (alpha).</font>
<font color="#208020">#   list - list of the scaleId.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Name of the window.</font>

<strong><a name="rhdisp_550">proc <a href="histogram.tcl-annot.html#rhdisp">rhdisp</a></a></strong><a name="rhdisp"></a> {typeLst alphaLst scaleIdLst} {
    set nRows 2
    set nLines [llength $typeLst]
    set completeLst {}
    foreach type $typeLst {
	set sigLst {}
	foreach value $scaleIdLst {
	    set new_value [format &#34;%.3d&#34; $value]
	    set sigLst [lappend sigLst rh_${type}${new_value}]
	}
	set completeLst [lappend completeLst ${sigLst}]
    }
    foreach type $typeLst {
	set lSigLst {}
	foreach value $scaleIdLst {
	    set new_value [format &#34;%.3d&#34; $value]
	    set lSigLst [lappend lSigLst lrh_${type}${new_value}]
	}
	set completeLst [lappend completeLst ${lSigLst}]
    }
    set code [catch {mdisp $nRows $nLines ${completeLst}} result]
    if {$code != 0} {
	error $result $result
    }
    <font color="#208020">#$result setColorsByList {darkgreen darkcyan darkblue slateblue darkviolet}</font>
    $result setColorsByList {black red green blue}
    set itemList {}
    foreach value $scaleIdLst {
	set itemList [lappend itemlist [list %c $value]]
    }
    eval $result setLabelsItemsByList $itemList
    set l 0
    foreach type $typeLst alpha $alphaLst {
	set newL [format &#34;%.2d&#34; $l]
	${result}gr00$newL set_label [list black &#34;$type, alpha = $alpha   &#34;] allSigLabel
	${result}gr01$newL set_label [list black &#34;Log $type, alpha = $alpha   &#34;] allSigLabel
	incr l
    }
    return $result
}


<font color="#208020"># smoment --</font>
<font color="#208020"># usage: smoment Signal int</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute a given moment of an signal.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   Signal   - Signal to treat.</font>
<font color="#208020">#   integer - Order of the moment.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   The moment.</font>

<strong><a name="smoment_604">proc <a href="histogram.tcl-annot.html#smoment">smoment</a></a></strong><a name="smoment"></a> {signal order} {
    <a name="lassign(1)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {type n} [sinfo $signal]

    return [expr { [sfct $signal pow(x,$order)]/$n }]
}


<font color="#208020"># sstats --</font>
<font color="#208020"># usage: sstats Signal int</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute successive moments of an signal.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   Signal   - Signal to treat.</font>
<font color="#208020">#   integer - Order of the upper moment. Must be greater or equal to 2.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   List of the variance and of the moments.</font>

<strong><a name="sstats_623">proc <a href="histogram.tcl-annot.html#sstats">sstats</a></a></strong><a name="sstats"></a> {signal order} {
    for {set k 1} {$k &lt;= $order} {incr k} {
	set res [<a name="smoment(1)"><a href="./histogram.tcl.html#smoment_604">smoment</a></a> $signal $k]
        lappend resLst $res
    }

    set variance [expr { sqrt([lindex $resLst 1]-pow([lindex $resLst 0],2)) }]

    return [concat $variance $resLst]
}


<font color="#208020"># lisse --</font>
<font color="#208020"># usage: lisse Signal</font>
<font color="#208020">#</font>
<font color="#208020">#   bricolage pour eviter des zeros dans un signal.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   Signal   - Signal to treat.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   none.</font>

<strong><a name="lisse_646">proc <a href="histogram.tcl-annot.html#lisse">lisse</a></a></strong><a name="lisse"></a> {sig} {

set size [ssize $sig]
set first [sfirst $sig]
set last [slast $sig]

for {set i [expr $first + 1]} { $i &lt; $last } {incr i} {
    if { [lindex [sget $sig $i] 0] == 0} {
	set y_avant [lindex [sget $sig [expr $i - 1]] 0]
	set y_apres [lindex [sget $sig [expr $i + 1]] 0]
	set y_mean [expr ($y_apres + $y_avant)/2]
	sset $sig $i $y_avant
    }
}
}
</pre>
<hr>
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#byfilename">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a><br>
<cite>File generated 2008-04-03 at 09:49.</cite>
</font>
</body>
</html>
