<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- Generated by TclDoc 0.3 -->
<html>
<head><title>hpcal_proc.tcl</title></head>
<body bgcolor="#ffffff">
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#hpcal_proc.tcl">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a>
</font>
<hr>
<strong>hpcal_proc.tcl</strong>
(<a href="hpcal_proc.tcl-annot.html">annotations</a> | <a href="hpcal_proc.tcl.txt">original source</a>)
<p>
<pre>

<font color="#208020"># Ce fichier contient toutes les procedures qui ont du etre developpees sur</font>
<font color="#208020"># HPCAL (machine de calculs) et non sur pcjeff (machine de developpement).</font>
<font color="#208020"># A terme ces procedures _doivent_ soit etre deplacer vers pcjeff, soit etre</font>
<font color="#208020"># effacees, soit etre repeintes en orange exsangue du retour precoce du</font>
<font color="#208020"># cheval Titude.</font>

<strong><a name="ssload_8">proc <a href="hpcal_proc.tcl-annot.html#ssload">ssload</a></a></strong><a name="ssload"></a> {name num_lst {options &#34;&#34;}} {
    foreach num $num_lst {
	set frmt_num [format &#34;%.3d&#34; $num]
	sload ${name}${frmt_num} $options
    }
}

<strong><a name="sszoom_15">proc <a href="hpcal_proc.tcl-annot.html#sszoom">sszoom</a></a></strong><a name="sszoom"></a> {name val num_lst} {
    foreach num $num_lst {
	set frmt_num [format &#34;%.3d&#34; $num]
	szoom ${name}${frmt_num} ${name}${frmt_num} $val
    }
}

<strong><a name="opdisp_22">proc <a href="hpcal_proc.tcl-annot.html#opdisp">opdisp</a></a></strong><a name="opdisp"></a> {name} {
    set tau_lst &#34;[lsort -decreasing [ginfo ${name}_taum* -list]] [lsort [ginfo ${name}_tau?p* -list]]&#34;
    set h_lst &#34;[lsort -decreasing [ginfo ${name}_hm* -list]] [lsort [ginfo ${name}_h?p* -list]]&#34;
    set D_lst &#34;[lsort -decreasing [ginfo ${name}_Dm* -list]] [lsort [ginfo ${name}_D?p* -list]]&#34;
    set code [catch {eval &#34;mdisp 2 2 {{$tau_lst} {$h_lst} {$D_lst}}&#34;} result]
    if {$code != 0} {
	error $result $result
    }
    return $result
}

<strong><a name="pdisp2_33">proc <a href="hpcal_proc.tcl-annot.html#pdisp2">pdisp2</a></a></strong><a name="pdisp2"></a> {name {q_lst &#34;&#34;}} {
    set completeLst {}
    if {$q_lst == &#34;&#34;} {
	return opdisp $name
    } else {
	set sigLst {}
	foreach q $q_lst {
	    set q_str [<a name="get_q_str(1)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${name}_tau${q_str}]
	}
	set completeLst [lappend completeLst ${sigLst}]
	set sigLst {}
	foreach q $q_lst {
	    set q_str [<a name="get_q_str(2)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${name}_h${q_str}]
	}
	set completeLst [lappend completeLst ${sigLst}]
	set sigLst {}
	foreach q $q_lst {
	    set q_str [<a name="get_q_str(3)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${name}_D${q_str}]
	}
	set completeLst [lappend completeLst ${sigLst}]
    }

    set code [catch {mdisp 2 2 ${completeLst}} result]
    if {$code != 0} {
	error $result $result
    }
    $result setColorsByList {darkgreen green darkcyan darkblue slateblue darkviolet violet}
    set itemList {}
    foreach value $q_lst {
	set itemList [lappend itemlist [list %c $value]]
    }
    eval $result setLabelsItemsByList $itemList
    ${result}gr0000 set_label {black &#34;Z(a,q), q = &#34;} allSigLabel
    ${result}gr0100 set_label {black &#34;D(a,q), q = &#34;} allSigLabel
    ${result}gr0001 set_label {black &#34;H(a,q), q = &#34;} allSigLabel
    return $result
}

<strong><a name="adisp_74">proc <a href="hpcal_proc.tcl-annot.html#adisp">adisp</a></a></strong><a name="adisp"></a> {name q} {
    set q_str [<a name="get_q_str(4)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
    set tau_lst &#34;[lsort [ginfo ${name}?_tau${q_str} -list]]&#34;
    set h_lst &#34;[lsort [ginfo ${name}?_h${q_str} -list]]&#34;
    set D_lst &#34;[lsort [ginfo ${name}?_D${q_str} -list]]&#34;
    <font color="#208020">#eval &#34;mdisp 2 2 {{$tau_lst} {$h_lst} {$D_lst}}&#34;</font>
    set code [catch {eval &#34;mdisp 2 2 {{$tau_lst} {$h_lst} {$D_lst}}&#34;} result]
    if {$code != 0} {
	error $result $result
    }
    $result setColorsByList {darkcyan darkblue slateblue darkviolet darkcyan darkblue slateblue darkviolet}
    <font color="#208020">#red darkblue black gold red darkblue black gold</font>
    set itemList {}
    foreach value {-pi -3pi/4 -pi/2 -pi/4 0 pi/4 pi/2 3pi/2} {
	set itemList [lappend itemlist [list %c $value]]
    }
    eval $result setLabelsItemsByList $itemList
    ${result}gr0000 set_label {black &#34;Z(a,q), q = $q,&#34;} allSigLabel
    ${result}gr0100 set_label {black &#34;D(a,q), q = $q,&#34;} allSigLabel
    ${result}gr0001 set_label {black &#34;H(a,q), q = $q,&#34;} allSigLabel

    return $result
}

<font color="#208020"># slogx --</font>
<font color="#208020"># usage: slogx signal1 signal2 [base]</font>
<font color="#208020">#</font>
<font color="#208020">#   transforms signal1 into signal2 just by computing log(x)</font>
<font color="#208020">#   without doing anything on y.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal1   - Signal to treat   (y versus     x  ).</font>
<font color="#208020">#   signal2   - resulting signal  (y versus log(x) ).</font>
<font color="#208020">#   [base]    - real (computes log(x)/log(base)) </font>
<font color="#208020">#</font>
<font color="#208020"># option:</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>


<strong><a name="slogx_115">proc <a href="hpcal_proc.tcl-annot.html#slogx">slogx</a></a></strong><a name="slogx"></a> {sig res {base &#34;e&#34;} } {
    if {$base == &#34;e&#34;} {
	set base [expr exp(1)]
    }    
    set y_lst [sgetlst $sig]
    set x0 [sgetx0 $sig] 
    set dx [sgetdx $sig]
    set size [ssize $sig]
    for {set i 0} {$i &lt; $size} {incr i} {
	set x [expr $x0+$i*$dx]
	if {$x &gt; 0} {
	    set logx [expr log($x)/log($base)]
	} else {
	    set logx 0
	}
	lappend x_lst $logx
    }
    screate $res 0 1 $y_lst -xy $x_lst
}

<font color="#208020"># slogx2 --</font>
<font color="#208020"># usage: slogx2 signal string base</font>
<font color="#208020">#</font>
<font color="#208020">#   transforms signal into signal (named &#34;string&#34;) just by computing</font>
<font color="#208020">#   log(x)/log($base)</font>
<font color="#208020">#   without doing anything on y. (see h2logh)</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal1   - Signal to treat   (y versus     x             ).</font>
<font color="#208020">#   signal2   - resulting signal  (y versus log(x)/log($base) ).</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>


<strong><a name="slogx2_150">proc <a href="hpcal_proc.tcl-annot.html#slogx2">slogx2</a></a></strong><a name="slogx2"></a> {sig {res &#34;&#34;} {base &#34;&#34;}} {
    if {$base == &#34;&#34;} {
	set base [expr exp(1)]
    }
    if {$res == &#34;&#34;} {
	set res log${sig}
    }
    sigloop $sig {
	if {$x &gt; 0} {
	    <font color="#208020"># Don't remove [expr $x] !!</font>
	    lappend xPosLst [expr log($x)/log($base)]
	    lappend yPosLst [expr $y]
	}
    }

    screate $res 0 1 $yPosLst -xy $xPosLst
}


<font color="#208020"># slogy --</font>
<font color="#208020"># usage: slogy signal string</font>
<font color="#208020">#</font>
<font color="#208020">#   transforms signal into signal (named &#34;string&#34;) just by computing log(y)</font>
<font color="#208020">#   without doing anything on x. (see h2logh)</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal1   - Signal to treat   (y      versus x  ).</font>
<font color="#208020">#   signal2   - resulting signal  (log(y) versus x  ).</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>


<strong><a name="slogy_183">proc <a href="hpcal_proc.tcl-annot.html#slogy">slogy</a></a></strong><a name="slogy"></a> {sig {res &#34;&#34;} {baselog &#34;&#34;} } {
    if {$baselog == &#34;&#34;} {
	set baselog [expr exp(1)]
    }

    if {$res == &#34;&#34;} {
	set res log${sig}
    }
    sigloop $sig {
	if {$y &gt; 0} {
	    <font color="#208020"># Don't remove [expr $x] !!</font>
	    lappend xPosLst [expr $x]
	    lappend yPosLst [expr log($y)/log($baselog)]
	}
    }

    screate $res 0 1 $yPosLst -xy $xPosLst
}


<font color="#208020"># sloglog --</font>
<font color="#208020"># usage: sloglog signal string</font>
<font color="#208020">#</font>
<font color="#208020">#   transforms signal into signal (named &#34;string&#34;) by computing log(x)</font>
<font color="#208020">#   and log(y).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal    - Signal to treat</font>
<font color="#208020">#   string    - name of the result</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>


<strong><a name="sloglog_217">proc <a href="hpcal_proc.tcl-annot.html#sloglog">sloglog</a></a></strong><a name="sloglog"></a> {sig {res &#34;&#34;}} {
    if {$res == &#34;&#34;} {
	set res loglog${sig}
    }
    sigloop $sig {
	if {$x &gt; 0 &amp; $y &gt;0} {
	    <font color="#208020"># Don't remove [expr $x] !!</font>
	    lappend xPosLst [expr log($x)]
	    lappend yPosLst [expr log($y)]
	}
    }

    screate $res 0 1 $yPosLst -xy $xPosLst
}

<font color="#208020"># sloglog10 --</font>
<font color="#208020"># usage: sloglog10 signal string</font>
<font color="#208020">#</font>
<font color="#208020">#   transforms signal into signal (named &#34;string&#34;) by computing log(x)</font>
<font color="#208020">#   and log(y).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal    - Signal to treat</font>
<font color="#208020">#   string    - name of the result</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>


<strong><a name="sloglog10_246">proc <a href="hpcal_proc.tcl-annot.html#sloglog10">sloglog10</a></a></strong><a name="sloglog10"></a> {sig {res &#34;&#34;}} {
    if {$res == &#34;&#34;} {
	set res loglog${sig}
    }
    sigloop $sig {
	if {$x &gt; 0 &amp; $y &gt;0} {
	    lappend xPosLst [expr log($x)/log(10)]
	    lappend yPosLst [expr log($y)/log(10)]
	}
    }

    screate $res 0 1 $yPosLst -xy $xPosLst
}

<font color="#208020"># smultx --</font>
<font color="#208020"># usage: smultx signal1 signal2 float</font>
<font color="#208020">#</font>
<font color="#208020">#   transforms signal1 into signal2 just by multiplying x</font>
<font color="#208020">#   by a scale factor param without doing anything on y.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal1   - Signal to treat   (y versus       x ).</font>
<font color="#208020">#   signal2   - resulting signal  (y versus param*x ).</font>
<font color="#208020">#   [base]    - real</font>
<font color="#208020">#</font>
<font color="#208020"># option:</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>


<strong><a name="smultx_277">proc <a href="hpcal_proc.tcl-annot.html#smultx">smultx</a></a></strong><a name="smultx"></a> {sig res {param 1} } {
    sigloop $sig {
	if {1} {
	    <font color="#208020"># Don't remove [expr $x] !!</font>
	    lappend x_lst [expr $x*$param]
	    lappend y_lst [expr $y]
	}
    }
    llength $y_lst
    llength $x_lst
    screate $res 0 1 $y_lst -xy $x_lst
}

<font color="#208020"># smulty --</font>
<font color="#208020"># usage: smulty signal1 signal2 float</font>
<font color="#208020">#</font>
<font color="#208020">#   transforms signal1 into signal2 just by multiplying y</font>
<font color="#208020">#   by a scale factor param without doing anything on x.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal1   - Signal to treat   (y       versus  x ).</font>
<font color="#208020">#   signal2   - resulting signal  (param*y versus  x ).</font>
<font color="#208020">#   [base]    - real</font>
<font color="#208020">#</font>
<font color="#208020"># option:</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>


<strong><a name="smulty_307">proc <a href="hpcal_proc.tcl-annot.html#smulty">smulty</a></a></strong><a name="smulty"></a> {sig res {param 1} } {
    sigloop $sig {
	if {1} {
	    <font color="#208020"># Don't remove [expr $x] !!</font>
	    lappend x_lst [expr $x]
	    lappend y_lst [expr $y*$param]
	}
    }
    llength $y_lst
    llength $x_lst
    screate $res 0 1 $y_lst -xy $x_lst
}

<font color="#208020"># srealloc --</font>
<font color="#208020"># usage: srealloc signal string list1 list2</font>
<font color="#208020">#</font>
<font color="#208020">#   transforms signal into signal (named &#34;string&#34;) by ...</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal    - Signal to treat</font>
<font color="#208020">#   string    - name of the result</font>
<font color="#208020">#   list1     - list of number</font>
<font color="#208020">#   list2     - list of number</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="srealloc_334">proc <a href="hpcal_proc.tcl-annot.html#srealloc">srealloc</a></a></strong><a name="srealloc"></a> {sig {res &#34;&#34;} list1 list2} {
    if {$res == &#34;&#34;} {
	set res realloc${sig}
    }
    
    set zel [llength $list1]
    set sigsize [ssize $sig]

    set list1a [lreplace $list1 [expr $zel -1] [expr $zel -1]] 
    set list1b [lreplace $list1 0 0]
    set list2a [lreplace $list2 [expr $zel -1] [expr $zel -1]] 
    set list2b [lreplace $list2 0 0]
    <a name="echo(1)"><a href="./tkcon.tcl.html#echo_3895">echo</a></a> $list1a
    <a name="echo(2)"><a href="./tkcon.tcl.html#echo_3895">echo</a></a> $list1b

    <font color="#208020">#set i 0</font>
    <font color="#208020">#set j 2570</font>

    for {set v 0} {$v &lt; $sigsize} {incr v} {
	set xy [sget $sig $v]
	set x [lindex $xy 1]
	set y [lindex $xy 0]
	foreach i $list1a j $list1b {
	    if { $x &gt;= $i &amp; $x &lt; $j } {
		set n [lsearch $list1 $i]
		set k [lindex $list2a $n]
		set l [lindex $list2b $n]
		
		set pente [expr ($l-$k)*1.0/($j-$i)]
		set newx [expr $k + $pente * ($x - $i)]
		lappend xPosLst $newx
		lappend yPosLst $y
	    }
	}
    }
    screate $res 0 1 $yPosLst -xy $xPosLst
}



<font color="#208020"># mysderiv --</font>
<font color="#208020"># usage: mysderiv signal str int</font>
<font color="#208020">#</font>
<font color="#208020">#   compute the (forward) derivative of signal_in using a convolution method.</font>
<font color="#208020">#   puts it in signal_out</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal      - Signal to treat</font>
<font color="#208020">#   string      - name of the result (signal)</font>
<font color="#208020">#   integer     - size</font>
<font color="#208020">#</font>
<font color="#208020"># mind the fact that signal_input size decreased !!!</font>
<font color="#208020">#</font>
<font color="#208020"># comment: it creates signals :</font>
<font color="#208020">#  thebox    : rectangular shape </font>
<font color="#208020">#  deriv_box : 1 -1 shape (type sdisp deriv_box to see)</font>
<font color="#208020">#                          or type sgetlst deriv_box)</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="mysderiv_394">proc <a href="hpcal_proc.tcl-annot.html#mysderiv">mysderiv</a></a></strong><a name="mysderiv"></a> {sig res size} {

    set x0 [sgetx0 $sig] 
    set dx [sgetdx $sig]
    set sig_size [ssize $sig]

    exprr thebox 0*x 0 [expr ${sig_size}-1] ${sig_size}
    for {set i 0} { $i &lt; $size } {incr i} {
	sset thebox $i 1
    }

    exprr deriv_box 0*x 0 [expr ${sig_size}-1] ${sig_size}
    for {set i 0} { $i &lt; $size } {incr i} {
	sset deriv_box $i 1
	sset deriv_box [expr ${size} + $i] -1
    }

    cv1dn $sig deriv_box _res -di -pe
    sputdx _res [sgetdx $sig]
    sputx0 _res [sgetx0 $sig]
    scomb _res _res x/[sgetdx _res]/($size*$size) _res
    scut _res $res [expr 2*$size-1] 0
    scut $sig new_$sig [expr $size - 1] $size 

    scopy new_$sig $sig
    delete new_$sig _res
}


<font color="#208020"># scutx --</font>
<font color="#208020"># usage: scutx signal_in signal_out real real</font>
<font color="#208020">#</font>
<font color="#208020">#   extracts a piece of signal_in (between xmin and xmax) and</font>
<font color="#208020">#   puts it in signal_out</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal      - Signal to treat</font>
<font color="#208020">#   string      - resulting signal</font>
<font color="#208020">#   real        - xmin</font>
<font color="#208020">#   real        - xmax</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="scutx_438">proc <a href="hpcal_proc.tcl-annot.html#scutx">scutx</a></a></strong><a name="scutx"></a> {sig res xMin xMax} {
    set y_lst [sgetlst $sig]
    set x0 [sgetx0 $sig] 
    set new_x0 [sgetx0 $sig] 
    set dx [sgetdx $sig]
    set size [ssize $sig]
    set first 0
    set last $size

    for {set i 0} {$i &lt;= $size} {incr i} {
	set x [expr $x0+$i*$dx]
	if {$x &gt;= $xMin} {
	    set first $i
	    set new_x0 $x
	    break;
	}
    }
    for {} {$i &lt;= $size} {incr i} {
	set x [expr $x0+$i*$dx]
	if {$x &gt; $xMax} {
	    set last [expr $i-1]
	    break;
	}
	lappend x_lst $x
    }
    set y_lst [lrange $y_lst $first $last]
    screate $res $new_x0 $dx $y_lst
}

<font color="#208020"># s2sp2 --</font>
<font color="#208020"># usage: s2sp2 signal_in signal_out</font>
<font color="#208020">#</font>
<font color="#208020">#   power spectrum computation</font>
<font color="#208020">#   signal_out is an XY signal:</font>
<font color="#208020">#   y -&gt; log(fft(signal_in)^2)</font>
<font color="#208020">#   x -&gt; log(k)</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   signal_in   - Signal to treat.</font>
<font color="#208020">#   signal_out  - resulting signal.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="s2sp2_482">proc <a href="hpcal_proc.tcl-annot.html#s2sp2">s2sp2</a></a></strong><a name="s2sp2"></a> {sig res} {
    gfft $sig __f
    sgfft2ri __f __rf __if
    scomb __rf __if log(x*x+y*y) __sp
    <font color="#208020">#scomb __rf __if (x*x+y*y) __sp</font>
    <font color="#208020">#scomb __rf __if sqrt(x*x+y*y) __sp</font>
    <a name="scutx(1)"><a href="./hpcal_proc.tcl.html#scutx_438">scutx</a></a> __sp __sp 0.000001 10
    <a name="slogx(1)"><a href="./hpcal_proc.tcl.html#slogx_115">slogx</a></a> __sp $res 2
    <font color="#208020">#scopy __sp $res</font>
    delete __*
}

<font color="#208020"># gsload --</font>
<font color="#208020"># usage: gsload name [ int ]</font>
<font color="#208020">#</font>
<font color="#208020">#    Load a list of signals that in curren.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   name        - Base name of files containing signals.</font>
<font color="#208020">#   [ int ]     - Argument to szoom.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="gsload_506">proc <a href="hpcal_proc.tcl-annot.html#gsload">gsload</a></a></strong><a name="gsload"></a> {name {zoom &#34;&#34;}} {
    set hist_lst [glob -nocomplain $name*]
    foreach file $hist_lst {
	sload $file $file -sw
	if {$zoom != &#34;&#34;} {
	    szoom $file $file $zoom
	}
    }
}

<strong><a name="hload_516">proc <a href="hpcal_proc.tcl-annot.html#hload">hload</a></a></strong><a name="hload"></a> {{zoom &#34;&#34;}} {
    <a name="gsload(1)"><a href="./hpcal_proc.tcl.html#gsload_506">gsload</a></a> h_mod $zoom
    <a name="gsload(2)"><a href="./hpcal_proc.tcl.html#gsload_506">gsload</a></a> h_arg $zoom
    <a name="gsload(3)"><a href="./hpcal_proc.tcl.html#gsload_506">gsload</a></a> h_max_mod $zoom
    <a name="gsload(4)"><a href="./hpcal_proc.tcl.html#gsload_506">gsload</a></a> h_max_arg $zoom
    <a name="gsload(5)"><a href="./hpcal_proc.tcl.html#gsload_506">gsload</a></a> h_max_line_mod $zoom
    <a name="gsload(6)"><a href="./hpcal_proc.tcl.html#gsload_506">gsload</a></a> h_max_line_arg $zoom
}

<strong><a name="all_hdisp_525">proc <a href="hpcal_proc.tcl-annot.html#all_hdisp">all_hdisp</a></a></strong><a name="all_hdisp"></a> {{lst &#34;&#34;}} {
    set result [<a name="hdisp(1)"><a href="./hpcal_proc.tcl.html#hdisp_535">hdisp</a></a> 2 3 {h_mod h_max_mod h_max_line_mod h_arg h_max_arg h_max_line_arg} $lst]
    ${result}gr0000 set_label {black &#34;Module -&#34;} allSigLabel
    ${result}gr0001 set_label {black &#34;Module (line) -&#34;} allSigLabel
    ${result}gr0002 set_label {black &#34;Module (max)  -&#34;} allSigLabel
    ${result}gr0100 set_label {black &#34;Argument -&#34;} allSigLabel
    ${result}gr0101 set_label {black &#34;Argument (line) -&#34;} allSigLabel
    ${result}gr0102 set_label {black &#34;Argument (max)  -&#34;} allSigLabel
}

<strong><a name="hdisp_535">proc <a href="hpcal_proc.tcl-annot.html#hdisp">hdisp</a></a></strong><a name="hdisp"></a> {nRows nLines nameLst {lst &#34;&#34;}} {
    set completeLst {}
    foreach name $nameLst {
	if {$lst == &#34;&#34;} {
	    set sigLst [ginfo $name* -list]
	} else {
	    set sigLst {}
	    foreach value $lst {
		set new_value [format &#34;%.3d&#34; $value]
		set sigLst [lappend sigLst ${name}${new_value}]
	    }
	}
	set completeLst [lappend completeLst ${sigLst}]
    }
    set code [catch {mdisp $nRows $nLines ${completeLst}} result]
    if {$code != 0} {
	error $result $result
    }
    $result setColorsByList {black red green blue yellow brown slateblue}
    set itemList {}
    foreach value $lst {
	set itemList [lappend itemlist [list %c $value]]
    }
    eval $result setLabelsItemsByList $itemList
    return $result
}

<strong><a name="ps4_562">proc <a href="hpcal_proc.tcl-annot.html#ps4">ps4</a></a></strong><a name="ps4"></a> {name {psFileName out.ps}} {
    set fileId [open ${name}.fig w]

    puts $fileId &#34;\#FIG 3.1&#34;
    puts $fileId &#34;Portrait&#34;
    puts $fileId &#34;Center&#34;
    puts $fileId &#34;Metric&#34;
    puts $fileId &#34;1200 2&#34;
    puts $fileId &#34;6 450 1920 8955 10845&#34;
    puts $fileId &#34;2 5 0 1 0 -1 0 0 -1 0.000 0 0 -1 0 0 5&#34;
    puts $fileId &#34;	0 ${name}_a1.ps&#34;
    puts $fileId &#34;	 4769 1942 8950 1942 8950 6310 4769 6310 4769 1942&#34;
    puts $fileId &#34;2 5 0 1 0 -1 0 0 -1 0.000 0 0 -1 0 0 5&#34;
    puts $fileId &#34;	0 ${name}_a0.ps&#34;
    puts $fileId &#34;	 494 1920 4675 1920 4675 6288 494 6288 494 1920&#34;
    puts $fileId &#34;2 5 0 1 0 -1 0 0 -1 0.000 0 0 -1 0 0 5&#34;
    puts $fileId &#34;	0 ${name}_a2.ps&#34;
    puts $fileId &#34;	 450 6460 4631 6460 4631 10828 450 10828 450 6460&#34;
    puts $fileId &#34;2 5 0 1 0 -1 0 0 -1 0.000 0 0 -1 0 0 5&#34;
    puts $fileId &#34;	0 ${name}_a3.ps&#34;
    puts $fileId &#34;	 4769 6460 8950 6460 8950 10828 4769 10828 4769 6460&#34;
    puts $fileId &#34;-6&#34;
    puts $fileId &#34;4 1 0 0 0 14 20 0.0000 4 240 1260 4725 1485 ${name}\001&#34;

    close $fileId
    exec fig2dev -L ps ${name}.fig ${psFileName}
}

<strong><a name="sna_590">proc <a href="hpcal_proc.tcl-annot.html#sna">sna</a></a></strong><a name="sna"></a> {} {
    set lst [ginfo *arg* -list]
    foreach sig $lst {
	<a name="snorm(1)"><a href="./histogram.tcl.html#snorm_27">snorm</a></a> $sig
    }
}

<strong><a name="snh_597">proc <a href="hpcal_proc.tcl-annot.html#snh">snh</a></a></strong><a name="snh"></a> {} {
    set lst [ginfo h_* -list]
    foreach sig $lst {
	<a name="snorm(2)"><a href="./histogram.tcl.html#snorm_27">snorm</a></a> $sig
    }
}

<strong><a name="calload_604">proc <a href="hpcal_proc.tcl-annot.html#calload">calload</a></a></strong><a name="calload"></a> {type zoom args} {
    foreach value $args {
	set fmtValue [format &#34;%.3d&#34; $value]
	set name calendos_${type}${fmtValue}
	iload $name
	if {$zoom &gt; 1} {
	    izoom $name $name $zoom
	}
    }
}

<strong><a name="calload2_615">proc <a href="hpcal_proc.tcl-annot.html#calload2">calload2</a></a></strong><a name="calload2"></a> {type zoom args} {
    foreach value $args {
	set fmtValue [format &#34;%.3d&#34; $value]
	set name calendos_${type}${fmtValue}
	iload $name
	if {$zoom &gt; 1} {
	    izoom $name $name $zoom
	}
	icomb $name $name log(x+1) $name
    }
}

<strong><a name="caldisp_627">proc <a href="hpcal_proc.tcl-annot.html#caldisp">caldisp</a></a></strong><a name="caldisp"></a> {type args} {
    foreach value $args {
	set fmtValue [format &#34;%.3d&#34; $value]
	set name calendos_${type}${fmtValue}
	iaff $name
    }
}

<strong><a name="calprint_635">proc <a href="hpcal_proc.tcl-annot.html#calprint">calprint</a></a></strong><a name="calprint"></a> {type filename width height item args} {
    set value [lindex $item 0]
    set xPos [lindex $item 1]
    set yPos [lindex $item 2]
    set fmtValue [format &#34;%.3d&#34; $value]
    set name calendos_${type}${fmtValue}
    i2eps $name $filename \
	    -size $width $height \
	    -pos $xPos $yPos \
	    -inv
    foreach item $args {
	set value [lindex $item 0]
	set xPos [lindex $item 1]
	set yPos [lindex $item 2]
	set fmtValue [format &#34;%.3d&#34; $value]
	set name calendos_${type}${fmtValue}
	i2eps $name $filename \
		-pos $xPos $yPos \
		-inv \
		-add
    }
    <a name="smeps2ps(1)"><a href="./hpcal_proc.tcl.html#smeps2ps_808">smeps2ps</a></a> $filename
}

<strong><a name="mycalprint_659">proc <a href="hpcal_proc.tcl-annot.html#mycalprint">mycalprint</a></a></strong><a name="mycalprint"></a> {type zoom} {
    <a name="calload(1)"><a href="./hpcal_proc.tcl.html#calload_604">calload</a></a> $type $zoom 0 10 20 30
    set pos [expr 550/$zoom]
    set size [expr 1066/$zoom]
    set x1 [expr (576-$size)/2]
    set x2 [expr (576-$size)/2+$pos]
    set y1 [expr (828-$size)/2]
    set y2 [expr (828-$size)/2+$pos]
    <a name="calprint(1)"><a href="./hpcal_proc.tcl.html#calprint_635">calprint</a></a> $type cal_$type.ps \
	    576 828 \
	    &#34;0  $x1 $y2&#34; \
	    &#34;10 $x2 $y2&#34; \
	    &#34;20 $x1 $y1&#34; \
	    &#34;30 $x2 $y1&#34;
}

<strong><a name="mycalprint2_675">proc <a href="hpcal_proc.tcl-annot.html#mycalprint2">mycalprint2</a></a></strong><a name="mycalprint2"></a> {type zoom} {
    <a name="calload(2)"><a href="./hpcal_proc.tcl.html#calload_604">calload</a></a> $type $zoom 0 5 10 15 20 25 30 35
    set pos [expr 550/$zoom]
    set size [expr 1066/$zoom]
    set x1 [expr (576-$size)/2]
    set x2 [expr (576-$size)/2+$pos]
    set y1 [expr (828-$size)/4]
    set y2 [expr (828-$size)/4+$pos]

    set y3 [expr (828-$size)/4+2*$pos]
    set y4 [expr (828-$size)/4+3*$pos]
    <a name="calprint(2)"><a href="./hpcal_proc.tcl.html#calprint_635">calprint</a></a> $type cal_$type.ps \
	    576 828 \
	    &#34;0  $x1 $y4&#34; \
	    &#34;5  $x2 $y4&#34; \
	    &#34;10 $x1 $y3&#34; \
	    &#34;15 $x2 $y3&#34; \
	    &#34;20 $x1 $y2&#34; \
	    &#34;25 $x2 $y2&#34; \
	    &#34;30 $x1 $y1&#34; \
	    &#34;35 $x2 $y1&#34;
}

<strong><a name="mycalprint3_698">proc <a href="hpcal_proc.tcl-annot.html#mycalprint3">mycalprint3</a></a></strong><a name="mycalprint3"></a> {type zoom} {
    <a name="calload2(1)"><a href="./hpcal_proc.tcl.html#calload2_615">calload2</a></a> $type $zoom 0 5 10 15 20 25 30 35
    set pos [expr 550/$zoom]
    set size [expr 1066/$zoom]
    set x1 [expr (576-$size)/2]
    set x2 [expr (576-$size)/2+$pos]
    set y1 [expr (828-$size)/4]
    set y2 [expr (828-$size)/4+$pos]

    set y3 [expr (828-$size)/4+2*$pos]
    set y4 [expr (828-$size)/4+3*$pos]
    <a name="calprint(3)"><a href="./hpcal_proc.tcl.html#calprint_635">calprint</a></a> $type cal_$type.ps \
	    576 828 \
	    &#34;0  $x1 $y4&#34; \
	    &#34;5  $x2 $y4&#34; \
	    &#34;10 $x1 $y3&#34; \
	    &#34;15 $x2 $y3&#34; \
	    &#34;20 $x1 $y2&#34; \
	    &#34;25 $x2 $y2&#34; \
	    &#34;30 $x1 $y1&#34; \
	    &#34;35 $x2 $y1&#34;
}

<strong><a name="mycalprint4_721">proc <a href="hpcal_proc.tcl-annot.html#mycalprint4">mycalprint4</a></a></strong><a name="mycalprint4"></a> {type zoom nR nL args} {
    eval &#34;calload2 $type $zoom $args&#34;
    set pos [expr 520/$zoom]
    set size [expr 1066/$zoom]

    set script &#34;calprint $type cal_$type.ps 576 828&#34;
    puts $script
    set y [expr (828-$size)/$nL+$nL*$pos]
    for {set j 0} {$j &lt; $nL} {incr j} {
	set y [expr $y-$pos]
	set x [expr (576-$size)/$nR]
	for {set i 0} {$i &lt; $nR} {incr i} {
	    set scaleNum [lindex $args [expr $i+$j*$nR]]
	    set script &#34;$script \{$scaleNum $x $y\}&#34;
	    set x [expr $x+$pos]
	}
    }
    eval $script
}

<strong><a name="newcalprint_741">proc <a href="hpcal_proc.tcl-annot.html#newcalprint">newcalprint</a></a></strong><a name="newcalprint"></a> {fileName zoom args} {
    set nL [llength $args]
    set nR 4
    set pos 130
    set imageScale [expr $zoom*0.25]

    eval &#34;calload image $zoom $args&#34;
    eval &#34;calload max $zoom $args&#34;
    eval &#34;calload max_line $zoom $args&#34;
    foreach scale $args {
	set num [format &#34;%.3d&#34; $scale]
	eload ../00/max$num e$num
    }

    catch {exec rm $fileName}

    set y [expr (828-$nL*$pos)/$nL+$nL*$pos]
    for {set j 0} {$j &lt; $nL} {incr j} {
	set scale [lindex $args $j]
	set num [format &#34;%.3d&#34; $scale]
	set y [expr $y-$pos]
	set x [expr (576-$nR*$pos)/$nR]
	e2eps e$num $fileName -size 576 828 -scale 0.125 -pos $x $y -inv -add
	set x [expr $x+$pos]
	i2eps calendos_image$num $fileName -scale $imageScale -pos $x $y -inv -add
	set x [expr $x+$pos]
	i2eps calendos_max$num $fileName -scale $imageScale -pos $x $y -inv -add
	set x [expr $x+$pos]
	i2eps calendos_max_line$num $fileName -scale $imageScale -pos $x $y -inv -add
    }
    <a name="smeps2ps(2)"><a href="./hpcal_proc.tcl.html#smeps2ps_808">smeps2ps</a></a> $fileName
    return
}

<strong><a name="print1scale_775">proc <a href="hpcal_proc.tcl-annot.html#print1scale">print1scale</a></a></strong><a name="print1scale"></a> {fileName zoom scaleId args} {
    set nL 2
    set nR 2
    set pos 260
    set imageScale [expr $zoom*0.25]

    set num [format &#34;%.3d&#34; $scaleId]
    iload calendos_image$num
    if {[string compare $args &#34;-log&#34;] == 0} {
	icomb calendos_image$num calendos_image$num log(x+1) calendos_image$num
    }
    iload calendos_max$num
    iload calendos_max_line$num
    eload ../00/max$num e$num

    catch {exec rm $fileName}

    set y [expr (828-$nL*$pos)/$nL+$nL*$pos]
    set y [expr $y-$pos]
    set x [expr (576-$nR*$pos)/$nR]
    e2eps e$num $fileName -size 576 828 -scale 0.25 -pos $x $y -inv -add
    set x [expr $x+$pos]
    i2eps calendos_image$num $fileName -scale $imageScale -pos $x $y -inv -add
    set y [expr $y-$pos]
    set x [expr (576-$nR*$pos)/$nR]
    i2eps calendos_max$num $fileName -scale $imageScale -pos $x $y -inv -add
    set x [expr $x+$pos]
    i2eps calendos_max_line$num $fileName -scale $imageScale -pos $x $y -inv -add

    <a name="smeps2ps(3)"><a href="./hpcal_proc.tcl.html#smeps2ps_808">smeps2ps</a></a> $fileName
    return
}

<strong><a name="smeps2ps_808">proc <a href="hpcal_proc.tcl-annot.html#smeps2ps">smeps2ps</a></a></strong><a name="smeps2ps"></a> {filename} {
    set fileId [open $filename a]
    puts $fileId showpage
    close $fileId
}

<strong><a name="foreachscale_814">proc <a href="hpcal_proc.tcl-annot.html#foreachscale">foreachscale</a></a></strong><a name="foreachscale"></a> {scaleVarName scaleIdVarName aMin nOctave nVox bodyScript} {
    upvar $scaleVarName scale
    upvar $scaleIdVarName scaleId

    for {set oct 0;set num 0}\
	    { $oct &lt; $nOctave} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nVox } \
		{ incr vox ; incr num} {
	    set scale [expr $aMin*pow(2,$oct+($vox/double($nVox)))]
	    set scale [expr $scale*(6/0.86)]
	    set scaleId [format &#34;%.3d&#34; $num]
	    uplevel $bodyScript
	}
    }
}

<strong><a name="allchain_832">proc <a href="hpcal_proc.tcl-annot.html#allchain">allchain</a></a></strong><a name="allchain"></a> {{boxRatio 1}} {
    source ../parameters.tcl
    set pi 3.1416
    set m_pi -3.1416

    set no [expr $noct-1]
    set nv [expr $nvox-1]
    set scale_max [expr $amin*pow(2,$no+($nv/double($nvox)))]
    set scale_max [expr $scale_max*(6/0.86)]
    set border_size [expr int($scale_max*$border_percent)]

    for { set oct 0;set num 0}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num} {
	    <font color="#208020"># Setting of local parameters</font>
	    set scale [expr $amin*pow(2,$oct+($vox/double($nvox)))]
	    set scale [expr $scale*(6/0.86)]
	    <a name="dputs(1)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;  Octave $oct - vox $vox - scale $scale ( $num )&#34;
	    set new_num [format &#34;%.3d&#34; $num]
	    set prev_num [expr $num-1]
	    set prev_new_num [format &#34;%.3d&#34; $prev_num]

	    eload max$new_num m$new_num

	    <font color="#208020"># We remove the border of the ext_image</font>
	    set border [expr $size-$border_size]
	    rm_ext m$new_num m$new_num $border_size $border $border_size $border

	    <font color="#208020"># Research of maxima lines and maxima line maxima (yes, don't laugh).</font>
	    hsearch m$new_num
	    ssm m$new_num

	    set box_size [expr int($boxRatio*log($scale)*2/log(2))]
	    if { $prev_num == 0} {
		vchain m$prev_new_num m$new_num $box_size $similitude -first
	    } else {
		if {$prev_num &gt; 0} {
		    vchain m$prev_new_num m$new_num $box_size $similitude
		}
	    }
	}   
    }
}

<strong><a name="getgrad_879">proc <a href="hpcal_proc.tcl-annot.html#getgrad">getgrad</a></a></strong><a name="getgrad"></a> {ext x y {name gr}} {
    vc2s $ext _sm $x $y -arg _sa
    scomb _sm _sa x*cos(y) _sx
    scomb _sm _sa x*sin(y) _sy
    screate $name 0 1 [sgetlst _sy] -xy [sgetlst _sx]
    delete _sm _sa _sx _sy
}

<strong><a name="getallgrad_887">proc <a href="hpcal_proc.tcl-annot.html#getallgrad">getallgrad</a></a></strong><a name="getallgrad"></a> {ext} {
    set i 0
    set j 0
    foreache $ext {
	if {[string compare $type &#34;vc&#34;] == 0} {
	    vc2s $ext sm$i $x $y -arg sa$i
	    scomb sm$i sa$i x*cos(y) sx$i
	    scomb sm$i sa$i x*sin(y) sy$i
	    screate gr$i 0 1 [sgetlst sy$i] -xy [sgetlst sx$i]
	    <a name="getgrad(1)"><a href="./hpcal_proc.tcl.html#getgrad_879">getgrad</a></a> $ext $x $y gr$i
	    s2fs sx$i nsx$i x log(abs(y))
	    s2fs sy$i nsy$i x log(abs(y))
	    <a name="lassign(1)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {index} [sgetindex sa$i 100]
	    set point [sget sa$i $index]
	    set y_value [lindex $point 0]
	    set x_value [lindex $point 1]
	    set cste [format &#34;%f&#34; [expr tan($y_value+1.5707963267948966)/(14*pow(2,$x_value/10.0))]]
	    s2fs sa$i nsa$i 14*pow(2,x/10.0) sin(y+1.5707963267948966)/(cos(y+1.5707963267948966))
	    incr i
	} else {
	    incr j
	}
    }
    <font color="#208020">#delete _sx _sy</font>
    return &#34;$i $j&#34;
}

<strong><a name="histdxdy_914">proc <a href="hpcal_proc.tcl-annot.html#histdxdy">histdxdy</a></a></strong><a name="histdxdy"></a> {type scale {max &#34;&#34;}} {
    set newScale [format &#34;%.3d&#34; $scale]
    if {[file exists calendos_${type}$newScale] == 1} {
	set fileName calendos_${type}$newScale
    } elseif {[file exists h_${type}_cal$newScale] == 1} {
	set fileName h_${type}_cal$newScale
    } else {
	error &#34;no 2d histogram file&#34;
    }
    iload $fileName _itmp
    set image _itmp
    set name h_${type}
    icut $image _tmp 0
    set size [im_size $image]
    sscamult _tmp 0 ${name}dx${newScale}
    sscamult _tmp 0 ${name}dy${newScale}
    for {set i 0} {$i &lt; $size} {incr i} {
	icut $image _tmp $i
	sadd _tmp ${name}dx${newScale} ${name}dx${newScale}
	icut $image _tmp $i -y
	sadd _tmp ${name}dy${newScale} ${name}dy${newScale}
    }
    if {$max != &#34;&#34;} {
	sputdx ${name}dx${newScale} [expr 2*$max/$size]
	sputx0 ${name}dx${newScale} [expr -$max]
	sputdx ${name}dy${newScale} [expr 2*$max/$size]
	sputx0 ${name}dy${newScale} [expr -$max]
    }
    szoom  ${name}dx${newScale} ${name}dx${newScale} 1
    szoom  ${name}dy${newScale} ${name}dy${newScale} 1
    delete _tmp
}

<strong><a name="allhistdxdy_947">proc <a href="hpcal_proc.tcl-annot.html#allhistdxdy">allhistdxdy</a></a></strong><a name="allhistdxdy"></a> {type {max &#34;&#34;}} {
    set scaleLst {0 10 20 30}
    foreach scale $scaleLst {
	<a name="histdxdy(1)"><a href="./hpcal_proc.tcl.html#histdxdy_914">histdxdy</a></a> $type $scale $max
    }
}

<strong><a name="all_dxdyhdisp_954">proc <a href="hpcal_proc.tcl-annot.html#all_dxdyhdisp">all_dxdyhdisp</a></a></strong><a name="all_dxdyhdisp"></a> {{lst &#34;&#34;}} {
    set result [<a name="hdisp(2)"><a href="./hpcal_proc.tcl.html#hdisp_535">hdisp</a></a> 2 3 {h_imagedx h_maxdx h_max_linedx h_imagedy h_maxdy h_max_linedy} $lst]
    ${result}gr0000 set_label {black &#34;dx -&#34;} allSigLabel
    ${result}gr0001 set_label {black &#34;dx (line) -&#34;} allSigLabel
    ${result}gr0002 set_label {black &#34;dx (max)  -&#34;} allSigLabel
    ${result}gr0100 set_label {black &#34;dy -&#34;} allSigLabel
    ${result}gr0101 set_label {black &#34;dy (line) -&#34;} allSigLabel
    ${result}gr0102 set_label {black &#34;dy (max)  -&#34;} allSigLabel
}

<font color="#208020"># signal doit etre normalise.</font>

<strong><a name="smoment2_966">proc <a href="hpcal_proc.tcl-annot.html#smoment2">smoment2</a></a></strong> {signal n} {
    set size [ssize $signal]
    set dx [sgetdx $signal]

    for {set k 1} {$k &lt;= $n} {incr k} {
	set res 0.0
	foreachs $signal {
	    set newX $x
	    for {set i 1} {$i &lt; $k} {incr i} {
		set newX [expr $newX*$x]
	    }
	    set newX [expr $newX*$y*$dx]
	    set res [expr $res+$newX]
	}
	lappend resLst $res
    }
    return $resLst
}

<strong><a name="sstat_985">proc <a href="hpcal_proc.tcl-annot.html#sstat">sstat</a></a></strong><a name="sstat"></a> {signal n} {
    set momLst [<a name="smoment(1)"><a href="./histogram.tcl.html#smoment_604">smoment</a></a> $signal $n]
    set m1 [lindex $momLst 0]
    set m2 [lindex $momLst 1]
    set sigma [expr sqrt($m2-$m1*$m1)]
    puts &#34;sigma $sigma&#34;
    for {set i 1} {$i &lt;= $n} {incr i} {
	puts &#34;moment $i [lindex $momLst [expr $i-1]]&#34;
    }
}

<font color="#208020"># smoment2 --</font>
<font color="#208020"># usage: smoment2 signal [ ]</font>
<font color="#208020">#</font>
<font color="#208020"># signal ne doit pas etre normalise.</font>
<font color="#208020">#                   integrale (x * f(x) )</font>
<font color="#208020"># mean vaut    m =  --------------------</font>
<font color="#208020">#                   integrale ( f(x)  )</font>


<strong><a name="smoment2_1005">proc <a href="hpcal_proc.tcl-annot.html#smoment2">smoment2</a></a></strong><a name="smoment2"></a> {signal {mean &#34;&#34;}} {
    set size [ssize $signal]
    set dx [sgetdx $signal]

    if {$mean == &#34;&#34;} {
	set N 0
	set mean 0.0
	foreachs $signal {
	    set mean [expr $mean+$x*$y]
	    incr N [expr int($y)]
	}
	set mean [expr $mean/$N]
    }

    set adev 0.0
    set var1 0.0
    set var2 0.0
    set skew 0.0
    set kurt 0.0
    foreachs $signal {
	set adev [expr $adev+$y*abs($x-$mean)]
	set var1 [expr $var1+$y*pow($x-$mean,2)]
	set var2 [expr $var2+$y*($x-$mean)]
	set skew [expr $skew+$y*pow($x-$mean,3)]
	set kurt [expr $kurt+$y*pow($x-$mean,4)]
    }
    set adev [expr $adev/$N]
    set var  [expr ($var1-($var2*$var2)/$N)/($N-1)]
    set sigma [expr sqrt($var)]
    set skew [expr $skew/($N*pow($sigma,3))]
    set kurt [expr $kurt/($N*pow($sigma,4))-3]

    set skewErr [expr sqrt(15.0/$N)]
    set kurtErr [expr sqrt(96.0/$N)]

    return [list $mean $adev $var $sigma [list $skew $skewErr] [list $kurt $kurtErr]]
}

<font color="#208020"># smean --</font>
<font color="#208020"># usage: smean signal [ ]</font>
<font color="#208020">#</font>
<font color="#208020"># c'est une copie de smoment2 </font>
<font color="#208020"># (qui est definie deux fois dans hpcal_proc.tcl !!!) </font>
<font color="#208020">#</font>
<font color="#208020"># signal ne doit pas etre normalise.</font>
<font color="#208020">#                        integrale (x * f(x) )</font>
<font color="#208020"># mean vaut         m =  ---------------------</font>
<font color="#208020">#                         integrale ( f(x)  )</font>
<font color="#208020">#</font>
<font color="#208020">#</font>
<font color="#208020">#                        integrale( (x-m)^2 * f(x))</font>
<font color="#208020"># var1 vaut      var1 =  -------------------------</font>
<font color="#208020">#                                    1</font>
<font color="#208020">#</font>
<font color="#208020">#</font>
<strong><a name="smean_1060">proc <a href="hpcal_proc.tcl-annot.html#smean">smean</a></a></strong><a name="smean"></a> {signal {mean &#34;&#34;}} {
    set size [ssize $signal]
    set dx [sgetdx $signal]

    if {$mean == &#34;&#34;} {
	set N 0
	set mean 0.0
	foreachs $signal {
	    set mean [expr $mean+$x*$y]
	    incr N [expr int($y)]
	}
	set mean [expr $mean/$N]
    }

    set adev 0.0
    set var1 0.0
    set var2 0.0
    set skew 0.0
    set kurt 0.0
    foreachs $signal {
	set adev [expr $adev+$y*abs($x-$mean)]
	set var1 [expr $var1+$y*pow($x-$mean,2)]
	set var2 [expr $var2+$y*($x-$mean)]
	set skew [expr $skew+$y*pow($x-$mean,3)]
	set kurt [expr $kurt+$y*pow($x-$mean,4)]
    }
    set adev [expr $adev/$N]
    set var  [expr ($var1-($var2*$var2)/$N)/($N-1)]
    set sigma [expr sqrt($var)]
    set skew [expr $skew/($N*pow($sigma,3))]
    set kurt [expr $kurt/($N*pow($sigma,4))-3]

    set skewErr [expr sqrt(15.0/$N)]
    set kurtErr [expr sqrt(96.0/$N)]

    return [list $mean $adev $var $sigma [list $skew $skewErr] [list $kurt $kurtErr]]
}




<font color="#208020">#</font>
<strong><a name="gauss_1102">proc <a href="hpcal_proc.tcl-annot.html#gauss">gauss</a></a></strong><a name="gauss"></a> {name mean sigma xmin xmax n} {
    exprr $name exp(-((x-$mean)/$sigma)^2/2) $xmin $xmax $n
}

<strong><a name="afit_1106">proc <a href="hpcal_proc.tcl-annot.html#afit">afit</a></a></strong><a name="afit"></a> {name aMin aMax q_lst} {
    foreach theta {0 1 2 3 4 5 6 7} {
	ntq $aMin $aMax $q_lst $name$theta
	nDq $aMin $aMax $q_lst $name$theta
	nhq $aMin $aMax $q_lst $name$theta
    }

    ntq $aMin $aMax $q_lst m_part
    nDq $aMin $aMax $q_lst m_part
    nhq $aMin $aMax $q_lst m_part
}


<strong><a name="mmdisp_1119">proc <a href="hpcal_proc.tcl-annot.html#mmdisp">mmdisp</a></a></strong><a name="mmdisp"></a> {} {
    set wid [mdisp 2 2 {{m0_tq m1_tq m2_tq m3_tq m4_tq m5_tq m6_tq m7_tq m_part_tq} {m0_hq m1_hq m2_hq m3_hq m4_hq m5_hq m6_hq m7_hq m_part_hq} {m0_Dq m1_Dq m2_Dq m3_Dq m4_Dq m5_Dq m6_Dq m7_Dq m_part_Dq}}]
    $wid setColorsByList {red yellow green blue red yellow green blue black}
    set itemList {}
    foreach value {-pi -3pi/4 -pi/2 -pi/4 0 pi/4 pi/2 3pi/2 glob} {
	set itemList [lappend itemlist [list %c $value]]
    }
    set result $wid
    eval $result setLabelsItemsByList $itemList
    ${result}gr0000 set_label {black &#34;tau(q),&#34;} allSigLabel
    ${result}gr0100 set_label {black &#34;D(q),&#34;} allSigLabel
    ${result}gr0001 set_label {black &#34;h(q),&#34;} allSigLabel
}


<font color="#208020"># </font>
<strong><a name="tqtheo_1135">proc <a href="hpcal_proc.tcl-annot.html#tqtheo">tqtheo</a></a></strong><a name="tqtheo"></a> {name H beta p1 xmin xmax n} {
    
    if {$beta == 0} {
	exprr ${name}tq -1.0*log(pow(2.0-2.0*$p1,x)+pow(2.0*$p1,x))/log(2.0)-1.0 $xmin $xmax $n	
	return ${name}tq
    }

    if {$H == 0.0} {
	set beta_eps [expr 1.0-log(1.0+2*$p1*($p1-1))/log(2.0)]
	set expo [expr ($beta-$beta_eps)/2.0]
	puts &#34;H=$expo&#34;
	puts &#34;beta_eps=$beta_eps&#34;
	exprr ${name}tq -1.0*log(pow(2.0-2.0*$p1,x)+pow(2.0*$p1,x))/log(2.0)-1.0+x*$expo $xmin $xmax $n	
	<font color="#208020">#sderiv ${name}tq ${name}hq </font>
	<font color="#208020">#s2fs ${name}hq ${name}dq x x*y</font>
	<font color="#208020">#scomb ${name}dq ${name}hq x-y ${name}dq</font>
	return ${name}tq
    }
<font color="#208020">#    foreachs ${name}tq {</font>
<font color="#208020">#	puts &#34;($x $y)&#34; </font>
<font color="#208020">#    }</font>
}

<font color="#208020">#</font>
<strong><a name="readsig_1159">proc <a href="hpcal_proc.tcl-annot.html#readsig">readsig</a></a></strong><a name="readsig"></a> {fileName {sigName &#34;&#34;}} {
    if {$sigName == &#34;&#34;} {
	set sigName $fileName
    }
    set fileId [open $fileName r]

    while {[gets $fileId line] &gt;= 0} {
	lappend xLst [lindex $line 0]
	lappend yLst [lindex $line 1]
    }
    screate $sigName 0 1 $yLst -xy $xLst

    close $fileId
}

<font color="#208020">#</font>
<strong><a name="mlaha_1175">proc <a href="hpcal_proc.tcl-annot.html#mlaha">mlaha</a></a></strong><a name="mlaha"></a> {} {
    foreach i {10 20 40 80} {
	sload h_dx0$i h_dx0$i -sw
	sload h_dy0$i h_dy0$i -sw
    }
}

<strong><a name="ilst2ps_1182">proc <a href="hpcal_proc.tcl-annot.html#ilst2ps">ilst2ps</a></a></strong><a name="ilst2ps"></a> {iDblLst fileName args} {
    <font color="#208020"># Default option values.</font>

    set scale 1
    set isLoaddel 0
    set isEinv 0

    <font color="#208020"># List of args for e2eps and i2eps commands.</font>
    set newArgs &#34;&#34;

    <font color="#208020"># Arguments analysis.</font>

    while {[string match -* $args]} {
	switch -glob -- [lindex $args 0] {
	    -scale {
		set scale [lindex $args 1]
		set args [lreplace $args 0 1]
	    }
	    -einv {
		set isEinv 1
		set args [lreplace $args 0 0]
	    }
	    -loaddel {
		set isLoaddel 1
		set args [lreplace $args 0 0]
	    }
	    default {
		lappend newArgs [lindex $args 0]
		set args [lreplace $args 0 0]
	    }
	}
    }

    <font color="#208020"># Page width and height of the result.</font>

    set ps(pW) 0
    set ps(pH) 0

    <font color="#208020"># Number of lines.</font>

    set ps(nL) 0

    <font color="#208020"># Get the attributes of the page.</font>

    foreach iLst $iDblLst {
	<font color="#208020"># iLst contains the image list of the current line.</font>

	set curL $ps(nL)

	<font color="#208020"># Current line width and height.</font>

	set ps($curL,lW) 0
	set ps($curL,lH) 0
	set ps($curL,nR) 0
	foreach im $iLst {
	    switch -glob -- [gettype $im] {
		E {
		    set cmdPref e
		}
		I {
		    set cmdPref i
		}
		default  {
		    return -code error &#34;bad object type [gettype $im]&#34;
		}
	    }
	    if {$isLoaddel} {
		${cmdPref}load $im
	    }
	    set lx [expr int([lindex [${cmdPref}info $im] 1]*$scale)+2]
	    set ly [expr int([lindex [${cmdPref}info $im] 2]*$scale)+2]
	    if {$ly &gt; $ps($curL,lH)} {
		set ps($curL,lH) $ly
	    }
	    incr ps($curL,lW) $lx
	    incr ps($curL,nR)
	    if {$isLoaddel} {
		delete $im
	    }
	}
	if {$ps($curL,lW) &gt; $ps(pW)} {
	    set ps(pW) $ps($curL,lW)
	}
	incr ps(pH) $ps($curL,lH)
	incr ps(nL)
    }

    <font color="#208020"># Check the request size.</font>

    if {$ps(pW) &gt; 576 || $ps(pH) &gt; 828} {
	return -code error &#34;too big request size ($ps(pW), $ps(pH))&#34;
    }

    <font color="#208020"># Create the postscript.</font>

    set posY [expr 828-(828-$ps(pH))/2]
    set curL 0
    catch {exec rm $fileName}
    foreach iLst $iDblLst {
	<font color="#208020"># iLst contains the image list of the current line.</font>

	set posX [expr (576-$ps($curL,lW))/2]
	foreach im $iLst {
	    set eArgs &#34;&#34;
	    switch -glob -- [gettype $im] {
		E {
		    if {$isEinv == 1} {
			set eArgs &#34;-inv&#34;
		    }
		    set cmdPref e
		}
		I {
		    set cmdPref i
		}
		default {
		    return -code error &#34;bad object type [gettype $im]&#34;
		}
	    }
	    if {$isLoaddel} {
		${cmdPref}load $im
	    }
	    set lx [expr int([lindex [${cmdPref}info $im] 1]*$scale)+2]
	    set ly [expr int([lindex [${cmdPref}info $im] 2]*$scale)+2]
	    set tmpPosY [expr $posY-$ly]
	    eval {${cmdPref}2eps $im $fileName \
		    -size 576 828 \
		    -pos $posX $tmpPosY \
		    -scale $scale \
		    -add} $newArgs $eArgs
	    incr posX $lx
	    if {$isLoaddel} {
		delete $im
	    }
	}
	incr posY -$ps($curL,lH)
	incr curL
    }
    <a name="smeps2ps(4)"><a href="./hpcal_proc.tcl.html#smeps2ps_808">smeps2ps</a></a> $fileName
    return $fileName
}

<strong><a name="rm1stline_1323">proc <a href="hpcal_proc.tcl-annot.html#rm1stline">rm1stline</a></a></strong><a name="rm1stline"></a> {file1Name file2Name} {
    set f1 [open $file1Name r]
    set f2 [open $file2Name w]
    gets $f1
    while {[gets $f1 line] != -1 } {
	puts $f2 $line
    }
    close $f1
    close $f2
}

<strong><a name="s2dat_1334">proc <a href="hpcal_proc.tcl-annot.html#s2dat">s2dat</a></a></strong><a name="s2dat"></a> {sig fileName {<a name="step(1)"><a href="./hpcal_proc.tcl.html#step_1590">step</a></a> 1}} {
    set f [open $fileName w]
    set count 0
    foreachs $sig {
	if {$count == 0} {
	    puts $f &#34;$x $y&#34;
	}
	incr count
	if {$count == $step} {
	    set count 0
	}
    }
    close $f
}

<strong><a name="wt12im_1349">proc <a href="hpcal_proc.tcl-annot.html#wt12im">wt12im</a></a></strong><a name="wt12im"></a> {name} {
    catch {delete $name}
    set sLst [lsort [ginfo ${name}* -list]]
    set lx [lindex [sinfo [lindex $sLst 0]] 1]
    set lx 1024
    set ly [llength $sLst]
    inull $name $lx $ly
    set y 0
    foreach s $sLst {
	iinssig $name $s $y
	incr y
    }
    return $name
}


<strong><a name="lkjklhj_1365">proc <a href="hpcal_proc.tcl-annot.html#lkjklhj">lkjklhj</a></a></strong><a name="lkjklhj"></a> {name} {
    set f [open res r]
    set amin 3.0
    set size 1024
    set no 4
    set nv 9
    set ns [expr $no*$nv]
    gets $f l
    set lst &#34;&#34;
    for {set j 0} {$j &lt; $size} {incr j} {
	gets $f l
	lappend lst $l
    }
    screate $name 0 [expr 1.0/$size] $lst
    for {set i 0} {$i &lt; $ns} {incr i} {
	set newi [format &#34;%.3d&#34; $i]
	gets $f l
	gets $f l
	set lst &#34;&#34;
	for {set j 0} {$j &lt; $size} {incr j} {
	    gets $f l
	    lappend lst $l
	}
	screate ${name}wt$newi 0 [expr 1.0/$size] $lst
    }
}

<font color="#208020"># i2sp --</font>
<font color="#208020"># usage: i2sp image [ int ] [ real ]</font>
<font color="#208020">#</font>
<font color="#208020">#   compute the power spectrum log-log (base 2 log)</font>
<font color="#208020">#   of an image and puts it in a signal (name : imagessp)</font>
<font color="#208020">#   which default size value is 32.</font>
<font color="#208020">#   it also creates an image : imageisp ( abs(fft)^2 of image).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   image     - name of the image to treat</font>
<font color="#208020">#   [ int ]   - size of the power spectrum signal</font>
<font color="#208020">#               this size is important for the resolution.</font>
<font color="#208020">#   [ real]   - base of logarithm (default value is exp(1)</font>
<font color="#208020">#               for neperian log.)</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>


<strong><a name="i2sp_1411">proc <a href="hpcal_proc.tcl-annot.html#i2sp">i2sp</a></a></strong><a name="i2sp"></a> {im {size 32} {base &#34;e&#34;} } {
    if {$base == &#34;e&#34;} {
	set base [expr exp(1)]
    }
    <a name="echo(3)"><a href="./tkcon.tcl.html#echo_3895">echo</a></a> $base
    igfft $im _f
    igfft2ri _f _r _i
    delete _f
    set isp ${im}isp
    set ssp ${im}ssp
    icomb _r _i x*x+y*y $isp
    delete _r _i
    iswap $isp
    isp2ssp $isp $ssp $size
    scomb $ssp $ssp log(x)/log($base) $ssp
    <a name="slogx(2)"><a href="./hpcal_proc.tcl.html#slogx_115">slogx</a></a> $ssp $ssp $base
}

<font color="#208020"># myi2sp --</font>
<font color="#208020"># usage: myi2sp image real real [ int ]</font>
<font color="#208020">#</font>
<font color="#208020">#   compute the power spectrum log-log (neperian log)</font>
<font color="#208020">#   of an image in angular sector of (kx,ky) plane.</font>
<font color="#208020">#</font>
<font color="#208020">#   it creates 2 signals for the 2 complementary spectrum </font>
<font color="#208020">#   (name : imagessp1 and imagessp2)</font>
<font color="#208020">#   their default size value is 32.</font>
<font color="#208020">#   it also creates an image : imageisp (the &#34;swaped&#34; abs(fft)^2</font>
<font color="#208020">#   of image, i.e. the point kx=ky=0 is in the center of imageisp).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   image     - name of the image to treat</font>
<font color="#208020">#   real      - theta1 angle in degrees : from -90 to 90</font>
<font color="#208020">#   real      - theta2  (to define the angular sector)</font>
<font color="#208020">#   [ int ]   - size of the power spectrum signal</font>
<font color="#208020">#               this size is important for the resolution.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>


<strong><a name="myi2sp_1452">proc <a href="hpcal_proc.tcl-annot.html#myi2sp">myi2sp</a></a></strong><a name="myi2sp"></a> {im theta1 theta2 {size 32}} {
    igfft $im _f
    igfft2ri _f _r _i
    delete _f
    set isp ${im}isp
    set ssp1 ${im}ssp1
    set ssp2 ${im}ssp2
    icomb _r _i x*x+y*y $isp
    delete _r _i
    iswap $isp
    myisp2ssp $isp $ssp1 $ssp2 $theta1 $theta2 $size
    scut $ssp1 $ssp1 2 1
    scut $ssp2 $ssp2 2 1
    scomb $ssp1 $ssp1 log(x) $ssp1
    scomb $ssp2 $ssp2 log(x) $ssp2
    <a name="slogx(3)"><a href="./hpcal_proc.tcl.html#slogx_115">slogx</a></a> $ssp1 $ssp1
    <a name="slogx(4)"><a href="./hpcal_proc.tcl.html#slogx_115">slogx</a></a> $ssp2 $ssp2
}

<strong><a name="i2isp_1471">proc <a href="hpcal_proc.tcl-annot.html#i2isp">i2isp</a></a></strong><a name="i2isp"></a> {im isp} {
    igfft $im _f
    igfft2ri _f _r _i
    delete _f
    icomb _r _i x*x+y*y $isp
    delete _r _i
    iswap $isp
}

<font color="#208020"># myizoom --</font>
<font color="#208020"># usage: myizoom image str  int</font>
<font color="#208020">#</font>
<font color="#208020">#   zoom image by the value &#34;zoom&#34; (see also izoom's help message)</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters:</font>
<font color="#208020">#   image     - Image  to treat</font>
<font color="#208020">#   string    - name of the resulting image</font>
<font color="#208020">#   integer   - must be an integer!!!</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="myizoom_1493">proc <a href="hpcal_proc.tcl-annot.html#myizoom">myizoom</a></a></strong><a name="myizoom"></a> {imin imout zoom} {
    set t1 [ntime]
    set lx [igetlx $imin]
    set ly [igetly $imin]
    set lx [expr $lx/$zoom*$zoom]
    set ly [expr $ly/$zoom*$zoom]
    iicut $imin _tmp 0 0 $lx $ly
    izoom _tmp $imout $zoom
    delete _tmp
    set t2 [ntime]
    <a name="echo(4)"><a href="./tkcon.tcl.html#echo_3895">echo</a></a> temps de calcul approx (en secondes) : [expr $t2 - $t1]
    unset t1 t2 lx ly
}

<strong><a name="tracerect_1507">proc <a href="hpcal_proc.tcl-annot.html#tracerect">tracerect</a></a></strong><a name="tracerect"></a> {ima listex listey { zoom 5 } {size 214} } {
    set ssize [expr $size/$zoom]
    foreach i $listex j $listey {
	set ii [expr $i/$zoom+29]
	set jj [expr $j/$zoom+29]
	
	itracerect $ima $ii $jj $ssize $ssize
    }
}

<strong><a name="isp2powSpec_1517">proc <a href="hpcal_proc.tcl-annot.html#isp2powSpec">isp2powSpec</a></a></strong><a name="isp2powSpec"></a> {isp ssp size} {
    isp2ssp $isp $ssp $size
    scomb $ssp $ssp log(x) $ssp
    <a name="slogx(5)"><a href="./hpcal_proc.tcl.html#slogx_115">slogx</a></a> $ssp $ssp
}

<strong><a name="s2sp_1523">proc <a href="hpcal_proc.tcl-annot.html#s2sp">s2sp</a></a></strong><a name="s2sp"></a> {sig} {
    gfft $sig _f
    sgfft2ri _f _r _i
    delete _f
    set ssp ${sig}ssp
    scomb _r _i log(x*x+y*y) $ssp
    <a name="scutx(2)"><a href="./hpcal_proc.tcl.html#scutx_438">scutx</a></a> $ssp $ssp 0 100
    <a name="slogx(6)"><a href="./hpcal_proc.tcl.html#slogx_115">slogx</a></a> $ssp $ssp
}

<strong><a name="icut2sp_1533">proc <a href="hpcal_proc.tcl-annot.html#icut2sp">icut2sp</a></a></strong><a name="icut2sp"></a> {im res args} {
    set imSize [im_size $im]
    set ssp $res
    icut $im _s 0 $args
    gfft _s _f
    delete _s
    sgfft2ri _f _r _i
    delete _f
    scomb _r _i 0 $ssp
    delete _r _i
    for {set x 0} {$x &lt; $imSize} {incr x} {
	icut $im _s $x $args
	gfft _s _f
	delete _s
	sgfft2ri _f _r _i
	delete _f
	scomb _r _i (x*x+y*y)/1000000 _ssp
	delete _r _i
	scomb $ssp _ssp x+y $ssp
	delete _ssp
    }
    <font color="#208020">#scomb $ssp $ssp log(x/$imSize)/log(2) $ssp</font>
    scomb $ssp $ssp (x/$imSize) $ssp
    <a name="scutx(3)"><a href="./hpcal_proc.tcl.html#scutx_438">scutx</a></a> $ssp $ssp 0 100000
    <a name="slogx(7)"><a href="./hpcal_proc.tcl.html#slogx_115">slogx</a></a> $ssp $ssp 2

    return $ssp
}

<strong><a name="icut2sp2_1562">proc <a href="hpcal_proc.tcl-annot.html#icut2sp2">icut2sp2</a></a></strong><a name="icut2sp2"></a> {im res args} {
    set imSize [im_size $im]
    set ssp $res
    icut $im _s 0 $args
    gfft _s _f
    delete _s
    sgfft2ri _f _r _i
    delete _f
    scomb _r _i 0 $ssp
    delete _r _i
    for {set x 350} {$x &lt; 650} {incr x} {
	icut $im _s $x $args
	gfft _s _f
	delete _s
	sgfft2ri _f _r _i
	delete _f
	scomb _r _i x*x+y*y _ssp
	delete _r _i
	scomb $ssp _ssp x+y $ssp
	delete _ssp
    }
    scomb $ssp $ssp log(x/300.0) $ssp
    <a name="scutx(4)"><a href="./hpcal_proc.tcl.html#scutx_438">scutx</a></a> $ssp $ssp 0 100000
    <a name="slogx(8)"><a href="./hpcal_proc.tcl.html#slogx_115">slogx</a></a> $ssp $ssp

    return $ssp
}

<strong><a name="step_1590">proc <a href="hpcal_proc.tcl-annot.html#step">step</a></a></strong><a name="step"></a> {file1Name file2Name {<a name="step(2)"><a href="./hpcal_proc.tcl.html#step_1590">step</a></a> 1}} {
    set f1 [open $file1Name r]
    set f2 [open $file2Name w]
    set count 0
    while {[gets $f1 l] != -1} {
	if {$count == 0} {
	    puts $f2 $l
	}
	incr count
	if {$count == $step} {
	    set count 0
	}
    }
    close $f1
    close $f2
}

<strong><a name="subsample_1607">proc <a href="hpcal_proc.tcl-annot.html#subsample">subsample</a></a></strong><a name="subsample"></a> {file1Name file2Name {<a name="step(3)"><a href="./hpcal_proc.tcl.html#step_1590">step</a></a> 1} {offset 0}} {
    set f1 [open $file1Name r]
    set f2 [open $file2Name w]
    for {set i 0} {$i &lt; $offset} {incr i} {
	gets $f1 l
    }
    set count 0
    while {[gets $f1 l] != -1} {
	if {$count == 0} {
	    puts $f2 $l
	}
	incr count
	if {$count == $step} {
	    set count 0
	}
    }
    close $f1
    close $f2
}

<strong><a name="rmend_1627">proc <a href="hpcal_proc.tcl-annot.html#rmend">rmend</a></a></strong><a name="rmend"></a> {file1Name file2Name index} {
    set f1 [open $file1Name r]
    set f2 [open $file2Name w]
    set count 0
    while {([gets $f1 l] != -1) &amp;&amp; ($count != $index)} {
	puts $f2 $l
	incr count
    }
    close $f1
    close $f2
}

<strong><a name="mm_1639">proc <a href="hpcal_proc.tcl-annot.html#mm">mm</a></a></strong><a name="mm"></a> {} {
    set sList {m_part_tqbest m_part_tqpref m_part_tqmean m_part_t qmax m_part_tqmin m_part_tqbestamax m_part_tqbestamin}
    foreach s $sList {
	sinus $s 1024
    }
    set code [catch {mdisp 1 2 {{m_part_tqbest m_part_tqpref m_part_tqmean m_part_t qmax m_part_tqmin} {m_part_tqbestamax m_part_tqbestamin}}} result]
    $result setColorsByList {red green cyan blue violet}

    set itemList &#34;&#34;
    foreach value {best pref mean max min} {
	set itemList [lappend itemlist [list %c $value]]
    }
    eval ${result}gr0000 setLabelsItemsByList $itemList
    ${result}gr0000 set_label {black &#34;fit, &#34;} allSigLabel

    set itemList1 {{%c &#34;amax &#34;} {%c &#34;amin &#34;}}
    eval ${result}gr0001 setLabelsItemsByList $itemList1
    ${result}gr0001 set_label {black &#34;best, &#34;} allSigLabel 



}

<strong><a name="sstats2_1662">proc <a href="hpcal_proc.tcl-annot.html#sstats2">sstats2</a></a></strong><a name="sstats2"></a> {signal n} {
    set size [ssize $signal]
    set dx [sgetdx $signal]
    for {set k 1} {$k &lt;= $n} {incr k} {
        set res 0.0
        foreachs $signal {
            set newY [expr $y]
            for {set i 1} {$i &lt; $k} {incr i} {
                set newY [expr $newY*$y]
            }
            set res [expr $res+$newY]
        }
        set res [expr $res/($size+1)]
        lappend resLst $res
    }

    return $resLst
}

<font color="#208020"># localfit --</font>
<font color="#208020"># usage : str str list [-display] [real] [real]</font>
<font color="#208020">#</font>
<font color="#208020">#  Compute different local linear regression of the partition functions ``name''</font>
<font color="#208020"># of order q from the ``basename'' file. Take windows of size 1/2, 1, 1.5 and 2</font>
<font color="#208020"># dyades.</font>
<font color="#208020"># create the signals :</font>
<font color="#208020">#    best: the best slope.</font>
<font color="#208020">#    mean: the mean slope.</font>
<font color="#208020">#    min : the min slope</font>
<font color="#208020">#    max : the max slope</font>
<font color="#208020">#    [pref: the prefered slope] </font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   str      - basename of the partition functions</font>
<font color="#208020">#   str      - name of the partition functions (i.e. tau, h or D)</font>
<font color="#208020">#   list     - list of the q values</font>
<font color="#208020">#   -display - display the results</font>
<font color="#208020">#   real     - prefered value of the minimum scale </font>
<font color="#208020">#   real     - prefered value of the maximum scale</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The list of the name of the 5 created signals.</font>

<strong><a name="localfit_1705">proc <a href="hpcal_proc.tcl-annot.html#localfit">localfit</a></a></strong><a name="localfit"></a> {basename name q_lst {option &#34;&#34;} {prefamin &#34;&#34;} {prefamax &#34;&#34;}} { 
    cd partition
    <a name="sw_part_load(1)"><a href="./part_fcts.tcl.html#sw_part_load_280">sw_part_load</a></a> ${basename}
    cd ..
    <a name="thd(1)"><a href="./part_fcts.tcl.html#thd_344">thd</a></a> ${basename} $q_lst
    catch {unset fit_lst}
    catch {unset meanfit_lst}
    catch {unset bestfit_lst}
    catch {unset amin_bestfit_lst}
    catch {unset amax_bestfit_lst}
    catch {unset amax_fitmax_lst}
    catch {unset amin_fitmax_lst}
    catch {unset amax_fitmin_lst}
    catch {unset amin_fitmin_lst}
    if {$prefamin != &#34;&#34; &amp;&amp; $prefamax != &#34;&#34;} {
	catch {unset preffit_lst}
    }
    foreach q $q_lst {
	set chi 100.0
	set ss 0.0
	set meantot 0.0
	set q_str [<a name="get_q_str(5)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	set num [ssize ${basename}_${name}$q_str]
	set x0 [sgetx0 ${basename}_${name}$q_str]
	set dx [sgetdx ${basename}_${name}$q_str]
	set WindLst {5 10 15 20}
	if {$prefamin != &#34;&#34; &amp;&amp; $prefamax != &#34;&#34;} {
	    set newwind [expr $prefamax-$prefamin]
	    set newwind [expr $newwind/$dx]
	    set testwind 0
	    foreach wind $WindLst {
		if {$newwind == $wind} {
		    set testwind 1
		}
	    }
	    if {$testwind == 0} {
		lappend WindLst $newwind
	    }
	}
	foreach wind $WindLst {
	    catch {unset fit_lst}
	    catch {unset x_lst}
	    if {$wind == 20} {
		catch {unset aminfit_lst}
		catch {unset amaxfit_lst}
	    }
	    set numb [expr $num-$wind]
	    for {set i 0} {$i &lt;= $numb} {incr i} {
		set amin [expr $x0+$dx*$i]
		set amax [expr $amin+$wind*$dx]
		set posx [expr ($amin+$amax)/2.0]
		set fit [sfit ${basename}_${name}$q_str $amin $amax]
		set a [lindex $fit 0]
		if {![string compare $a nan]} {
		    set a 0
		}
		lappend fit_lst $a
		lappend x_lst $posx
		if {$amin == $prefamin &amp;&amp; $amax == $prefamax} {
		    set preffit $a
		}
		if {$wind == 20} {
		    set chi2 [lindex $fit 4]
		    if {$chi2 &lt;= $chi} {
			set chi $chi2
			set besta $a
			set bestamax $amax
			set bestamin $amin
		    }
		    lappend aminfit_lst $amin
		    lappend amaxfit_lst $amax
		}
	    }
	    if {$wind == 20} {
		lappend bestfit_lst $besta
		lappend amax_bestfit_lst $bestamax
		lappend amin_bestfit_lst $bestamin
		screate amin_temp [lindex $x_lst 0] $dx $aminfit_lst
		screate amax_temp [lindex $x_lst 0] $dx $amaxfit_lst
	    }
	    screate ${basename}_${name}_wind${wind} [lindex $x_lst 0] $dx $fit_lst 
	    set meanvar [<a name="sstats(1)"><a href="./histogram.tcl.html#sstats_623">sstats</a></a> ${basename}_${name}_wind${wind} 2]
	    set size [ssize ${basename}_${name}_wind${wind}]
	    set mean [lindex $meanvar 0]
	    set meantot [expr $meantot+$size*$mean]
	    set ss [expr $ss+$size]
	}
	set meantot [expr $meantot/$ss]
	set fit [sgetextr ${basename}_${name}_wind20]
	set fitmin [lindex $fit 0]
	set fitmax [lindex $fit 1]
	set iminfit [lindex $fit 2]
	set imaxfit [lindex $fit 3]
	lappend meanfit_lst $meantot
	lappend minfit_lst $fitmin
	lappend maxfit_lst $fitmax	
	if {$prefamin != &#34;&#34; &amp;&amp; $prefamax != &#34;&#34;} {
	    lappend preffit_lst $preffit
	}
	set temp [sget amin_temp $iminfit]
	set amin_fitmin [lindex $temp 0]
	set temp [sget amax_temp $iminfit]
	set amax_fitmin [lindex $temp 0]
	set temp [sget amin_temp $imaxfit]
	set amin_fitmax [lindex $temp 0]
	set temp [sget amax_temp $imaxfit]
	set amax_fitmax [lindex $temp 0]
	lappend amin_fitmin_lst $amin_fitmin
	lappend amax_fitmin_lst $amax_fitmin
	lappend amin_fitmax_lst $amin_fitmax
	lappend amax_fitmax_lst $amax_fitmax
    }
    screate ${basename}_${name}best [lindex $q_lst 0] 1 $bestfit_lst -xy $q_lst
    screate ${basename}_${name}bestamax [lindex $q_lst 0] 1 $amax_bestfit_lst -xy $q_lst
    screate ${basename}_${name}bestamin [lindex $q_lst 0] 1 $amin_bestfit_lst -xy $q_lst

    screate ${basename}_${name}mean [lindex $q_lst 0] 1 $meanfit_lst -xy $q_lst
    screate ${basename}_${name}max [lindex $q_lst 0] 1 $maxfit_lst -xy $q_lst
    screate ${basename}_${name}maxamax [lindex $q_lst 0] 1 $amax_fitmax_lst -xy $q_lst
    screate ${basename}_${name}maxamin [lindex $q_lst 0] 1 $amin_fitmax_lst -xy $q_lst

    screate ${basename}_${name}min [lindex $q_lst 0] 1 $minfit_lst -xy $q_lst
    screate ${basename}_${name}minamax [lindex $q_lst 0] 1 $amax_fitmin_lst -xy $q_lst
    screate ${basename}_${name}minamin [lindex $q_lst 0] 1 $amin_fitmin_lst -xy $q_lst

    if {$prefamin != &#34;&#34; &amp;&amp; $prefamax != &#34;&#34;} {
	screate ${basename}_${name}pref [lindex $q_lst 0] 1 $preffit_lst -xy $q_lst
    }
    if {[string compare $option -display] == 0} {
	set completeLst {}
	if {$prefamin != &#34;&#34; &amp;&amp; $prefamax != &#34;&#34;} {
	    set sigLst {}
	    foreach val {best pref mean max min} {
		set sigLst [lappend sigLst ${basename}_${name}$val]
	    }
	    set completeLst [lappend completeLst ${sigLst}]
	    set sigLst2 {}
	    foreach val {bestamax bestamin maxamax maxamin minamax minamin} {
		set sigLst2 [lappend sigLst2 ${basename}_${name}$val]
	    }
	    set completeLst [lappend completeLst ${sigLst2}]
	    set code [catch {mdisp 1 2 ${completeLst}} result]
	    if {$code != 0} {
		error $result $result
	    }
	    ${result}gr0000 setColorsByList {red violet cyan green blue}
	    set itemList {}
	    foreach value {best pref mean max min} {
		set itemList [lappend itemlist [list %c $value]]
	    }
	    eval ${result}gr0000 setLabelsItemsByList $itemList
	    ${result}gr0000 set_label {black &#34;fit, &#34;} allSigLabel
	} else {
	    set sigLst {}
	    foreach val {best mean max min} {
		set sigLst [lappend sigLst ${basename}_${name}$val]
	    }
	    set completeLst [lappend completeLst ${sigLst}]
	    set sigLst2 {}
	    foreach val {bestamax bestamin maxamax maxamin minamax minamin} {
		set sigLst2 [lappend sigLst2 ${basename}_${name}$val]
	    }
	    set completeLst [lappend completeLst ${sigLst2}]
	    set code [catch {mdisp 1 2 ${completeLst}} result]
	    if {$code != 0} {
		error $result $result
	    }
	    ${result}gr0000 setColorsByList {red cyan green blue}
	    set itemList {}
	    foreach value {best mean max min} {
		set itemList [lappend itemlist [list %c $value]]
	    }
	    eval ${result}gr0000 setLabelsItemsByList $itemList
	    ${result}gr0000 set_label {black &#34;fit, &#34;} allSigLabel
	}
	${result}gr0001 setColorsByList {red red green green blue blue}
	set itemList1 {}
	foreach value {best .. max .. min ..} {
	    set itemList1 [lappend itemlist1 [list %c $value]]
	}
	eval ${result}gr0001 setLabelsItemsByList $itemList1
	${result}gr0001 set_label {black &#34;Range for, &#34;} allSigLabel
    }
    return $sigLst
}


<font color="#208020"># localslope --</font>
<font color="#208020"># usage : str str real [-display]</font>
<font color="#208020">#</font>
<font color="#208020">#  Compute the local linear regression of the partition functions ``name'' </font>
<font color="#208020"># of order q from the ``basename'' file. Take windows of size 1/2, 1, 1.5 and 2</font>
<font color="#208020"># dyades</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   str      - basename of the partition functions</font>
<font color="#208020">#   str      - name of the partition functions (i.e. tau, h or D)</font>
<font color="#208020">#   real     - the considered q value</font>
<font color="#208020">#   -display - display the results</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The list of the name of the 4 created signals.</font>

<strong><a name="localslope_1908">proc <a href="hpcal_proc.tcl-annot.html#localslope">localslope</a></a></strong><a name="localslope"></a> {basename name q {option &#34;&#34;}} { 
    cd partition
    <a name="sw_part_load(2)"><a href="./part_fcts.tcl.html#sw_part_load_280">sw_part_load</a></a> ${basename}
    cd ..
    <a name="thd(2)"><a href="./part_fcts.tcl.html#thd_344">thd</a></a> ${basename} $q
    
    set q_str [<a name="get_q_str(6)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
    set num [ssize ${basename}_${name}$q_str]
    set x0 [sgetx0 ${basename}_${name}$q_str]
    set dx [sgetdx ${basename}_${name}$q_str]
    set WindLst {5 10 15 20}

    set sigLst {}
    foreach wind $WindLst {
	catch {unset fit_lst}
	catch {unset x_lst}
	
	set numb [expr $num-$wind]
	for {set i 0} {$i &lt;= $numb} {incr i} {
	    set amin [expr $x0+$dx*$i]
	    set amax [expr $amin+$wind*$dx]
	    set posx [expr ($amin+$amax)/2.0]
	    set fit [sfit ${basename}_${name}$q_str $amin $amax]
	    set a [lindex $fit 0]
	    if {![string compare $a nan]} {
		set a 0
	    }
	    lappend fit_lst $a
	    lappend x_lst $posx
	}
	screate ${basename}_${name}_wind${wind} [lindex $x_lst 0] $dx $fit_lst 
	set sigLst [lappend sigLst ${basename}_${name}_wind${wind}]
    }

    if {[string compare $option -display] == 0} {
	set completelst {}
	set completeLst [lappend completeLst ${sigLst}]
	set code [catch {mdisp 1 1 ${completeLst}} result]
	if {$code != 0} {
	    error $result $result
	}
	${result}gr0000 setColorsByList {red cyan green blue}
	set itemList {}
	foreach value $WindLst {
	    set value [expr $value*$dx]
	    set itemList [lappend itemlist [list %c $value]]
	}
	eval ${result}gr0000 setLabelsItemsByList $itemList
	${result}gr0000 set_label {black &#34;Window size, &#34;} allSigLabel
    }
    return $sigLst
}



<strong><a name="allloc_1963">proc <a href="hpcal_proc.tcl-annot.html#allloc">allloc</a></a></strong><a name="allloc"></a> {basename name qliste} {
    set complete_Lst {}
    foreach qq $qliste {
        set sig_Lst {}
        set list [<a name="localslope(1)"><a href="./hpcal_proc.tcl.html#localslope_1908">localslope</a></a> $basename $name $qq]
        foreach name2 $list {
            scopy $name2 ${qq}_$name2
            set sig_Lst [lappend sig_Lst ${qq}_$name2] 
        }
        set complete_Lst [lappend complete_Lst $sig_Lst]        
    }
    set code [catch {mdisp 3 3 ${complete_Lst}} result]
    if {$code != 0} {
        error $result $result
    }
    ${result} setColorsByList {red cyan green blue}
    set itemList {}    
    foreach value {0.5 1.0 1.5 2.0} {
        set itemList [lappend itemlist [list %c $value]]
    }
    eval ${result} setLabelsItemsByList $itemList
    set r 0
    set l 0
    foreach qq $qliste {
        set newL [format &#34;%.2d&#34; $l]
        set newR [format &#34;%.2d&#34; $r]
        ${result}gr${newR}${newL} set_label [list black &#34;$name q=$qq W. size, &#34;] allSigLabel
        incr l
        if {$l == 3} {
            set l 0
            incr r
        }

    }
}

<strong><a name="allchain2_1999">proc <a href="hpcal_proc.tcl-annot.html#allchain2">allchain2</a></a></strong><a name="allchain2"></a> {{boxRatio 1}} {
    source ../parameters.tcl
    set pi 3.1416
    set m_pi -3.1416

    set no [expr $noct-1]
    set nv [expr $nvox-1]
    set scale_max [expr $amin*pow(2,$no+($nv/double($nvox)))]
    set scale_max [expr $scale_max*(6/0.86)]
    set border_size [expr int($scale_max*$border_percent)]
    set border [expr $size-$border_size]
    puts &#34;border size=$border_size&#34;

    <font color="#208020">#iload image</font>
    set bb [expr $border_size-1]
    set bbb [expr $border+1]
    <font color="#208020">#cutedge image image $bb</font>
    <font color="#208020">#set ss [im_size image]</font>
    <font color="#208020">#puts &#34;New size of the image ${ss}x${ss}&#34;</font>

    for { set oct 0;set num 0}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num} {
	    <font color="#208020"># Setting of local parameters</font>
	    set scale [expr $amin*pow(2,$oct+($vox/double($nvox)))]
	    set scale [expr $scale*(6/0.86)]
	    <a name="dputs(2)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;  Octave $oct - vox $vox - scale $scale ( $num )&#34;
	    set new_num [format &#34;%.3d&#34; $num]
	    set prev_num [expr $num-1]
	    set prev_new_num [format &#34;%.3d&#34; $prev_num]

	    eload max$new_num m$new_num

	    <font color="#208020"># We remove the border of the ext_image</font>
	    <font color="#208020">#rm_ext m$new_num max$new_num $border_size $border $border_size $border</font>

	    puts &#34;$bb $bbb&#34;
	    ecut m$new_num m$new_num $bb $bb $bbb $bbb

	    <font color="#208020"># Research of maxima lines and maxima line maxima (yes, don't laugh).</font>
	    puts coucou
	    hsearch m$new_num
	    puts coucou2
	    ssm m$new_num
	    puts coucou3
	    set box_size [expr int($boxRatio*log($scale)*2/log(2))]
	    if { $prev_num == 0} {
		<font color="#208020">#vchain m$prev_new_num m$new_num $box_size $similitude -first</font>
	    } else {
		if {$prev_num &gt; 0} {
		    <font color="#208020">#vchain m$prev_new_num m$new_num $box_size $similitude</font>
		}
	    }
	}   
    }
}


<strong><a name="hsvch2_2060">proc <a href="hpcal_proc.tcl-annot.html#hsvch2">hsvch2</a></a></strong> {amin noct nvox firstsid {boxRatio 1} {thresh 0}} {
    set similitude 0.8

    set no [expr $noct-1]
    set nv [expr $nvox-1]
    set scale_max [expr $amin*pow(2,$no+($nv/double($nvox)))]
    set scale_max [expr $scale_max*(6/0.86)]

    for { set oct 0;set num 0}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num} {
	    <font color="#208020"># Setting of local parameters</font>
	    set scale [expr $amin*pow(2,$oct+($vox/double($nvox)))]
	    set scale [expr $scale*(6/0.86)]
	    <a name="dputs(3)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;  Octave $oct - vox $vox - scale $scale ( $num )&#34;
	    if {$num &lt; $firstsid} {
		continue
	    }
	    set new_num [format &#34;%.3d&#34; $num]
	    set prev_num [expr $num-1]
	    set prev_new_num [format &#34;%.3d&#34; $prev_num]

	    eload max$new_num m$new_num
	    if {$thresh &gt; 0} {
		ekeep m$new_num m$new_num $thresh
	    }

	    hsearch m$new_num
	    ssm m$new_num

	    set box_size [expr int($boxRatio*log($scale)*2/log(2))]
	    if { $prev_num == 0} {
		vchain m$prev_new_num m$new_num $box_size $similitude -first
	    } else {
		if {$prev_num &gt; 0} {
		    vchain m$prev_new_num m$new_num $box_size $similitude
		}
	    }
	}   
    }
}

<strong><a name="hsvch3_2105">proc <a href="hpcal_proc.tcl-annot.html#hsvch3">hsvch3</a></a></strong><a name="hsvch3"></a> {amin noct nvox {id_offset 0} {boxRatio 1} {thresh 0}} {
    set similitude 0.8

    set no [expr $noct-1]
    set nv [expr $nvox-1]
    set scale_max [expr $amin*pow(2,$no+($nv/double($nvox)))]
    set scale_max [expr $scale_max*(6/0.86)]

    for { set oct 0;set num $id_offset;set fnum 0}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num; incr fnum} {
	    <font color="#208020"># Setting of local parameters</font>
	    set scale [expr $amin*pow(2,$oct+($vox/double($nvox)))]
	    set scale [expr $scale*(6/0.86)]
	    <a name="dputs(4)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;  Octave $oct - vox $vox - scale $scale ( $num )&#34;
	    set new_fnum [format &#34;%.3d&#34; $fnum]
	    set new_num [format &#34;%.3d&#34; $num]
	    set prev_num [expr $num-1]
	    set prev_new_num [format &#34;%.3d&#34; $prev_num]

	    eload max$new_fnum m$new_num
	    if {$thresh &gt; 0} {
		ekeep m$new_num m$new_num $thresh
	    }

	    hsearch m$new_num
	    ssm m$new_num

	    set box_size [expr int($boxRatio*log($scale)*2/log(2))]
	    if { $prev_num == $id_offset} {
		vchain m$prev_new_num m$new_num $box_size $similitude -first
	    } else {
		if {$prev_num &gt; $id_offset} {
		    vchain m$prev_new_num m$new_num $box_size $similitude
		}
	    }
	}   
    }
}

<strong><a name="hsvch_2148">proc <a href="hpcal_proc.tcl-annot.html#hsvch">hsvch</a></a></strong><a name="hsvch"></a> {amin noct nvox {boxRatio 1} {thresh 0}} {
    set similitude 0.8

    set no [expr $noct-1]
    set nv [expr $nvox-1]
    set scale_max [expr $amin*pow(2,$no+($nv/double($nvox)))]
    set scale_max [expr $scale_max*(6/0.86)]

    for { set oct 0;set num 0}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num} {
	    <font color="#208020"># Setting of local parameters</font>
	    set scale [expr $amin*pow(2,$oct+($vox/double($nvox)))]
	    set scale [expr $scale*(6/0.86)]
	    <a name="dputs(5)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;  Octave $oct - vox $vox - scale $scale ( $num )&#34;
	    set new_num [format &#34;%.3d&#34; $num]
	    set prev_num [expr $num-1]
	    set prev_new_num [format &#34;%.3d&#34; $prev_num]

	    eload max$new_num m$new_num
	    if {$thresh &gt; 0} {
		ekeep m$new_num m$new_num $thresh
	    }

	    hsearch m$new_num
	    ssm m$new_num

	    set box_size [expr int($boxRatio*log($scale)*2/log(2))]
	    if { $prev_num == 0} {
		vchain m$prev_new_num m$new_num $box_size $similitude -first
	    } else {
		if {$prev_num &gt; 0} {
		    vchain m$prev_new_num m$new_num $box_size $similitude
		}
	    }
	}   
    }
}

<strong><a name="hsvch4_2190">proc <a href="hpcal_proc.tcl-annot.html#hsvch4">hsvch4</a></a></strong><a name="hsvch4"></a> {amin noct nvox {eps 0} {offset 0} {boxRatio 1} {thresh 0}} {
    set similitude 0.8

    set no [expr $noct-1]
    set nv [expr $nvox-1]
    set scale_max [expr $amin*pow(2,$no+($nv/double($nvox)))]
    set scale_max [expr $scale_max*(6/0.86)]

    for { set oct 0;set num $offset}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num} {
	    <font color="#208020"># Setting of local parameters</font>
	    set scale [expr $amin*pow(2,$oct+($vox/double($nvox)))]
	    set scale [expr $scale*(6/0.86)]
	    <a name="dputs(6)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;  Octave $oct - vox $vox - scale $scale ( $num )&#34;
	    set new_num [format &#34;%.3d&#34; $num]
	    set prev_num [expr $num-1]
	    set prev_new_num [format &#34;%.3d&#34; $prev_num]

	    eload max$new_num m$new_num
	    if {$thresh &gt; 0} {
		ekeep m$new_num m$new_num $thresh
	    }

	    hsearch m$new_num
	    ssm m$new_num -smooth -eps $eps

	    set box_size [expr int($boxRatio*log($scale)*2/log(2))]
	    if { $prev_num == $offset} {
		vchain m$prev_new_num m$new_num $box_size $similitude -first
	    } else {
		if {$prev_num &gt; $offset} {
		    vchain m$prev_new_num m$new_num $box_size $similitude
		}
	    }
	}   
    }
}

<strong><a name="hsvch5_2232">proc <a href="hpcal_proc.tcl-annot.html#hsvch5">hsvch5</a></a></strong><a name="hsvch5"></a> {amin noct nvox {offset 0} {boxRatio 1} {thresh 0}} {
    set similitude 0.8

    set no [expr $noct-1]
    set nv [expr $nvox-1]
    set scale_max [expr $amin*pow(2,$no+($nv/double($nvox)))]
    set scale_max [expr $scale_max*(6/0.86)]

    for { set oct 0;set num $offset}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num} {
	    <font color="#208020"># Setting of local parameters</font>
	    set scale [expr $amin*pow(2,$oct+($vox/double($nvox)))]
	    set scale [expr $scale*(6/0.86)]
	    <a name="dputs(7)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;  Octave $oct - vox $vox - scale $scale ( $num )&#34;
	    set new_num [format &#34;%.3d&#34; $num]
	    set prev_num [expr $num-1]
	    set prev_new_num [format &#34;%.3d&#34; $prev_num]

	    eload max$new_num m$new_num
	    if {$thresh &gt; 0} {
		ekeep m$new_num m$new_num $thresh
	    }

	    hsearch m$new_num
	    ssm m$new_num -greatest

	    set box_size [expr int($boxRatio*log($scale)*2/log(2))]
	    if { $prev_num == $offset} {
		vchain m$prev_new_num m$new_num $box_size $similitude -first
	    } else {
		if {$prev_num &gt; $offset} {
		    vchain m$prev_new_num m$new_num $box_size $similitude
		}
	    }
	}   
    }
}

<strong><a name="hsvch6_2274">proc <a href="hpcal_proc.tcl-annot.html#hsvch6">hsvch6</a></a></strong><a name="hsvch6"></a> {amin noct nvox {offset 0} {boxRatio 1} {thresh 0}} {
    set similitude 0.8

    set no [expr $noct-1]
    set nv [expr $nvox-1]
    set scale_max [expr $amin*pow(2,$no+($nv/double($nvox)))]
    set scale_max [expr $scale_max*(6/0.86)]

    for { set oct 0;set num $offset; set file_num 0}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num; incr file_num} {
	    <font color="#208020"># Setting of local parameters</font>
	    set scale [expr $amin*pow(2,$oct+($vox/double($nvox)))]
	    set scale [expr $scale*(6/0.86)]
	    <a name="dputs(8)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;  Octave $oct - vox $vox - scale $scale ( $num )&#34;
	    set new_num [format &#34;%.3d&#34; $num]
	    set file_new_num [format &#34;%.3d&#34; $file_num]
	    set prev_num [expr $num-1]
	    set prev_new_num [format &#34;%.3d&#34; $prev_num]

	    eload max$file_new_num m$new_num
	    if {$thresh &gt; 0} {
		ekeep m$new_num m$new_num $thresh
	    }

	    hsearch m$new_num
	    ssm m$new_num -greatest

	    set box_size [expr int($boxRatio*log($scale)*2/log(2))]
	    if { $prev_num == $offset} {
		vchain m$prev_new_num m$new_num $box_size $similitude -first
	    } else {
		if {$prev_num &gt; $offset} {
		    vchain m$prev_new_num m$new_num $box_size $similitude
		}
	    }
	}   
    }
}

<strong><a name="fitfnpart_2317">proc <a href="hpcal_proc.tcl-annot.html#fitfnpart">fitfnpart</a></a></strong><a name="fitfnpart"></a> { } {
    source parameters.tcl
    for { set oct 0;set num 0}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num} {
	    set new_num [format &#34;%.3d&#34; $num]
	    sload histograms/h_log_max_line_mod$new_num
h_log_max_line_mod$new_num -sw
	}
    }   
    <a name="snh(1)"><a href="./hpcal_proc.tcl.html#snh_597">snh</a></a>
    for { set oct 0;set num 0}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num} {
	    set new_num [format &#34;%.3d&#34; $num]
	    <a name="h2logh(1)"><a href="./histogram.tcl.html#h2logh_284">h2logh</a></a> h_log_max_line_mod$new_num
	    set momLst &#34;&#34;
	    set momLst [<a name="smoment(2)"><a href="./histogram.tcl.html#smoment_604">smoment</a></a> h_log_max_line_mod$new_num 2]
	    set m1 [lindex $momLst 0]
	    set m2 [lindex $momLst 1]
	    set sigma [expr sqrt($m2-$m1*$m1)]    
	    <a name="gauss(1)"><a href="./hpcal_proc.tcl.html#gauss_1102">gauss</a></a> h_g$new_num $m1 $sigma -8 8 512	    
	}
    }
    <a name="snh(2)"><a href="./hpcal_proc.tcl.html#snh_597">snh</a></a>

<font color="#208020"># The computation of the fns of partition with the log-normal fit.</font>
set dx [expr 1.0/$nvox]
foreach q $q_lst {
	puts &#34;q=$q&#34;
	set zq_lst {}
	set hq_lst {}
	set dq_lst {}
	for { set oct 0;set num 0}\
		{ $oct &lt; $noct} \
		{ incr oct } {
	    for {set vox 0} \
		    { $vox &lt; $nvox } \
		    { incr vox ; incr num} {
		set new_num [format &#34;%.3d&#34; $num]
		<font color="#208020"># Pour Z(q,a) = somme T^q = somme exp(qln T)</font>
		s2fs h_g$new_num uu x y*exp($q*x)
		sintegrate uu uuu
		set result [ssize uuu]
		set res [sget uuu $result]
		set val [lindex $res 0]
		set val [format %f $val]
		set zq_)lst [lappend zq_lst $val]
		<font color="#208020"># Pour h(q,a) = somme (T^q*log T )/Z(q,a)</font>
		s2fs h_g$new_num uu x y*exp($q*x)*x/($val*log(2.0))
		sintegrate uu uuu
		set result [ssize uuu]
		set res [sget uuu $result]
		set valh [lindex $res 0]
		set hq_lst [lappend hq_lst $valh]
		<font color="#208020"># Pour D(q,a) = somme (T^q*log(T/Z(q,a)))/Z(q,a)</font>
		s2fs h_g$new_num uu x
y*exp($q*x)*($q*x-log($val))/($val*log(2.0))
		sintegrate uu uuu
		set result [ssize uuu]
		set res [sget uuu $result]
		set valD [lindex $res 0]
		set dq_lst [lappend dq_lst $valD]
	    }
	}
	screate z_$q 1 $dx $zq_lst
	screate h_$q 1 $dx $hq_lst
	screate d_$q 1 $dx $dq_lst	
	s2fs z_$q z_$q x log(y)/log(2.0)-2*x
	s2fs d_$q d_$q x y+2*x

	set q_str [<a name="get_q_str(7)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	ssave z_$q partition/fit_m_part_tau$q_str -sw
	ssave h_$q partition/fit_m_part_h$q_str -sw
	ssave d_$q partition/fit_m_part_D$q_str -sw

    }
}



<strong><a name="fitfnpart2_2404">proc <a href="hpcal_proc.tcl-annot.html#fitfnpart2">fitfnpart2</a></a></strong><a name="fitfnpart2"></a> { } {
    source parameters.tcl
    for { set oct 0;set num 0}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num} {
	    set new_num [format &#34;%.3d&#34; $num]
	    sload histograms/h_max_line_mod$new_num h_max_line_mod$new_num
-sw
	}
    }   
<font color="#208020">#    snh</font>

<font color="#208020"># The computation of the fns of partition with the log-normal fit.</font>
    set dx [expr 1.0/$nvox]
    foreach q {1.0 2.0} {
	puts &#34;q=$q&#34;
	set zq_lst {}
	set hq_lst {}
	set dq_lst {}
	for { set oct 0;set num 0}\
		{ $oct &lt; $noct} \
		{ incr oct } {
	    for {set vox 0} \
		    { $vox &lt; $nvox } \
		    { incr vox ; incr num} {
		set new_num [format &#34;%.3d&#34; $num]
		<font color="#208020"># Pour Z(q,a) = somme T^q = somme exp(qln T)</font>
		s2fs h_max_line_mod$new_num uu x y*x^$q
		sintegrate uu uuu
		set result [ssize uuu]
		set res [sget uuu $result]
		set val [lindex $res 0]
		set val [format %f $val]
		set zq_lst [lappend zq_lst $val]
		<font color="#208020"># Pour h(q,a) = somme (T^q*log T )/Z(q,a)</font>
<font color="#208020">#		s2fs h_max_line_mod$new_num uu x</font>
y*exp($q*log(abs(x)))*log(abs(x))/($val*log(2.0))
		s2fs h_max_line_mod$new_num uu x
y*x^$q*log(x)/($val*log(2.0))
		sintegrate uu uuu
		set result [ssize uuu]
		set res [sget uuu $result]
		set valh [lindex $res 0]
		set hq_lst [lappend hq_lst $valh]
		<font color="#208020"># Pour D(q,a) = somme (T^q*log(T^q/Z(q,a)))/Z(q,a)</font>
<font color="#208020">#		s2fs h_max_line_mod$new_num uu x</font>
y*exp($q*log(abs(x)))*($q*log(abs(x))-log($val))/$val
		s2fs h_max_line_mod$new_num uu x
y*x^$q*log(x^$q/$val)/($val*log(2.0))
		sintegrate uu uuu
		set result [ssize uuu]
		set res [sget uuu $result]
		set valD [lindex $res 0]
		set dq_lst [lappend dq_lst $valD]
	    }
	}
	
	screate z_$q 1 $dx $zq_lst
	screate h_$q 1 $dx $hq_lst
	screate d_$q 1 $dx $dq_lst
	s2fs z_$q z_$q x log(y)/log(2.0)
    }
}


<strong><a name="im2dat_2472">proc <a href="hpcal_proc.tcl-annot.html#im2dat">im2dat</a></a></strong><a name="im2dat"></a> {im fName} {
    set f [open $fName w]

    <a name="lassign(2)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {gah lx ly} [iinfo $im]

    puts $f &#34;$lx 0 0 1\nhaha\n$ly 0 0 1\nhoho&#34;

    imloop $im {
	puts $f [format &#34;%f&#34; $value]
    }

    close $f
}

<font color="#208020"># lvc2dat --</font>
<font color="#208020"># usage: lvc2dat extima string string string [real] </font>
<font color="#208020">#</font>
<font color="#208020"># </font>
<font color="#208020">#</font>
<font color="#208020">#</font>

<strong><a name="lvc2dat_2493">proc <a href="hpcal_proc.tcl-annot.html#lvc2dat">lvc2dat</a></a></strong><a name="lvc2dat"></a> {extImage lFileName aFileName cFileName {mult -1} {istag 0}} {
    set lFileId [open $lFileName w]
    set aFileId [open $aFileName w]
    set cFileId [open $cFileName w]
    <a name="lassign(3)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {scale lx ly extrNb chainNb nbOfLines stamp} [einfo $extImage]
    <a name="lassign(4)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {min max} [egetextr $extImage]
    if {$mult == -1} {
	set mult [expr 30.0/$max]
    }
    if {$istag == 0} {
	eiloop $extImage {
	    puts $lFileId &#34;$x $y&#34;
	    if {$type == &#34;vc&#34;} {
		puts $cFileId &#34;$x $y&#34;
		puts $aFileId &#34;$x $y&#34;
		set x1 [expr $x+$mult*$mod*cos($arg)]
		set y1 [expr $y+$mult*$mod*sin($arg)]
		puts $aFileId &#34;$x1 $y1&#34;
	    }
	}
	close $lFileId
	close $aFileId
	close $cFileId
	return $mult
    } else {
	eigrloop $extImage {
	    puts $lFileId &#34;$x $y&#34;
	    if {$type == &#34;tag vc&#34;} {
		puts $cFileId &#34;$x $y&#34;
		puts $aFileId &#34;$x $y&#34;
		set x1 [expr $x+$mult*$mod*cos($arg)]
		set y1 [expr $y+$mult*$mod*sin($arg)]
		puts $aFileId &#34;$x1 $y1&#34;
	    }
	}
	close $lFileId
	close $aFileId
	close $cFileId
	return $mult
    }

}

<strong><a name="gr2dat_2536">proc <a href="hpcal_proc.tcl-annot.html#gr2dat">gr2dat</a></a></strong><a name="gr2dat"></a> {extImage aFileName {mult -1}} {
    set aFileId [open $aFileName w]
    <a name="lassign(5)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {scale lx ly extrNb chainNb nbOfLines stamp} [einfo $extImage]
    <a name="lassign(6)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {min max} [egetextr $extImage]
    if {$mult == -1} {
	set mult [expr 30.0/$max]
    }
    eigrloop $extImage {
	puts $aFileId &#34;$x $y&#34;
	set x1 [expr $x+$mult*$mod*cos($arg)]
	set y1 [expr $y+$mult*$mod*sin($arg)]
	puts $aFileId &#34;$x1 $y1&#34;
    }
    close $aFileId
    return $mult
}

<strong><a name="ma2dat_2553">proc <a href="hpcal_proc.tcl-annot.html#ma2dat">ma2dat</a></a></strong><a name="ma2dat"></a> {mod arg aFileName cFileName {<a name="step(4)"><a href="./hpcal_proc.tcl.html#step_1590">step</a></a> 1}} {
    set aFileId [open $aFileName w]
    set cFileId [open $cFileName w]
    <a name="lassign(7)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {dummy lx ly} [iinfo $mod]
    <a name="lassign(8)"><a href="./tools.tcl.html#lassign_67">lassign</a></a> {min max} [im_extrema $mod]
    set mult [expr 30.0/$max]
    imloop $mod {
        if {[expr $x%$step] == 0 &amp;&amp; [expr $y%$step] == 0 } {
	    set m [expr $value]
	    set a [value $arg $x $y]
            puts $cFileId &#34;$x $y&#34;
            puts $aFileId &#34;$x $y&#34;
            set x1 [expr $x+$mult*$m*cos($a)]
            set y1 [expr $y+$mult*$m*sin($a)]
            puts $aFileId &#34;$x1 $y1&#34;
        }
    }
    close $aFileId
    close $cFileId

    return $mult
}

<strong><a name="hsvch2_2576">proc <a href="hpcal_proc.tcl-annot.html#hsvch2">hsvch2</a></a></strong><a name="hsvch2"></a> {name amin noct nvox {boxRatio 1}} {
    set similitude 0.8

    set no [expr $noct-1]
    set nv [expr $nvox-1]
    set scale_max [expr $amin*pow(2,$no+($nv/double($nvox)))]
    set scale_max [expr $scale_max*(6/0.86)]

    for { set oct 0;set num 0}\
	    { $oct &lt; $noct} \
	    { incr oct } {
	for {set vox 0} \
		{ $vox &lt; $nvox } \
		{ incr vox ; incr num} {
	    <font color="#208020"># Setting of local parameters</font>
	    set scale [expr $amin*pow(2,$oct+($vox/double($nvox)))]
	    set scale [expr $scale*(6/0.86)]
	    <a name="dputs(9)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;  Octave $oct - vox $vox - scale $scale ( $num )&#34;
	    set new_num [format &#34;%.3d&#34; $num]
	    set prev_num [expr $num-1]
	    set prev_new_num [format &#34;%.3d&#34; $prev_num]

	    <font color="#208020">#hsearch ${name}$new_num</font>
	    ssm ${name}$new_num

	    set box_size [expr int($boxRatio*log($scale)*2/log(2))]
	    if { $prev_num == 0} {
		vchain ${name}$prev_new_num ${name}$new_num $box_size $similitude -first
	    } else {
		if {$prev_num &gt; 0} {
		    vchain ${name}$prev_new_num ${name}$new_num $box_size $similitude
		}
	    }
	}   
    }
}

<strong><a name="reads_2613">proc <a href="hpcal_proc.tcl-annot.html#reads">reads</a></a></strong><a name="reads"></a> {name {res &#34;&#34;}} {
    if {$res == &#34;&#34;} {
	set res $name
    }
    set f [open $name r]
    set xLst {}
    set yLst {}
    while {[gets $f l] != -1} {
	lappend xLst [lindex $l 0]
	lappend yLst [lindex $l 1]
    }
    screate $res 0 1 $yLst -xy $xLst
    close $f
}


<strong><a name="legendre3_2629">proc <a href="hpcal_proc.tcl-annot.html#legendre3">legendre3</a></a></strong><a name="legendre3"></a> {name list} {
    set qlst {-6.0 -5.0 -4.0 -3.0 -2.0 -1.0 -0.2 0.0 0.2 0.5 0.8 1.0 1.2
1.5 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0}
    s2fs $name d$name x 0.05*x+.0001
    screate val 0 1 $list
    screate f$name 0 1 $qlst
<font color="#208020">#    set npoint [expr int(($max+10)*2+1)]</font>
<font color="#208020">#    exprr f$name x -10 $max $npoint</font>
    polyf $name d$name val res -fit f$name
    sderiv f$name h$name
<font color="#208020"># We verifie that h(q) is always decreasing</font>
    sderiv h$name uuu
    set i 0
    foreachs uuu {
        if {$y &gt; 0.0} {
            puts &#34;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; WARNING &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#34;
            puts &#34;  fit change for value above x =$x&#34;
            puts &#34;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; WARNING &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#34;
            break
        }
        incr i
    } 
    set imin [expr $i-2]
    set imax [expr $i+1]
    set xmin [lindex [sget f$name $imin] 1]  
    set xmax [lindex [sget f$name $imax] 1]  
    puts &#34;$xmin $xmax&#34;
    sthresh f$name uuu $xmin $xmax
    s2fs uuu s  x .00001
    screate newf 0 1 $qlst
<font color="#208020">#    exprr newf x -10 $max $npoint</font>
    puts $xmin
    sthresh newf newf $imin 1000
    screate v 0 1 $list
    polyf uuu s v r -fit newf
    set xx [expr $xmin -.001]
    puts $xx
    sthresh f$name f$name -100 $xx
    scolle f$name newf f$name
    sderiv f$name h$name

    s2fs h$name temp x y*x

<font color="#208020">#    set m [expr $max-0.001]</font>
    sthresh f$name f$name -11 10.2
    scomb temp f$name x-y dq$name
    smerge h$name dq$name dh$name
    return &#34;f$name h$name dh$name&#34; 
}

<font color="#208020"># boxwt --</font>
<font color="#208020"># usage : boxwt signal int</font>
<font color="#208020">#</font>
<font color="#208020"># take care signal must be of type REALXY !!!</font>
<font color="#208020">#</font>

<strong><a name="boxwt_2685">proc <a href="hpcal_proc.tcl-annot.html#boxwt">boxwt</a></a></strong><a name="boxwt"></a> {sig size } {

    set xLst [sgetlst $sig -x]
    set yLst [sgetlst $sig -y]

    exprr wt_2 0*x 0  [expr $size/2 *  $size/2  - 1] [expr $size/2*$size/2]
    exprr wt_4 0*x 0  [expr $size/4 *  $size/4  - 1] [expr $size/4*$size/4]
    exprr wt_8 0*x 0  [expr $size/8 *  $size/8  - 1] [expr $size/8*$size/8]
    exprr wt_16 0*x 0 [expr $size/16 * $size/16 - 1] [expr $size/16*$size/16]
    exprr wt_32 0*x 0 [expr $size/32 * $size/32 - 1] [expr $size/32*$size/32]
    exprr wt_64 0*x 0 [expr $size/64 * $size/64 - 1] [expr $size/64*$size/64]

<font color="#208020"># [expr int(log($size)/log(2))]</font>

    foreach i $xLst j $yLst {
	for {set logscale 1} {$logscale &lt; 7} {incr logscale} {
	    set scale  [expr int(pow(2,$logscale))]
	    set newi   [expr $i/$scale]
	    set newj   [expr $j/$scale]
	    set indice [expr $newi*$size/$scale+$newj]
	    sset wt_$scale $indice [expr [lindex [sget wt_$scale $indice] 0] + 1]
	}
    }


}
</pre>
<hr>
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#byfilename">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a><br>
<cite>File generated 2008-04-03 at 09:49.</cite>
</font>
</body>
</html>
