<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- Generated by TclDoc 0.3 -->
<html>
<head><title>cascades.tcl</title></head>
<body bgcolor="#ffffff">
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#cascades.tcl">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a>
</font>
<hr>
<strong>cascades.tcl</strong>
(<a href="cascades.tcl-annot.html">annotations</a> | <a href="cascades.tcl.txt">original source</a>)
<p>
<pre>
<font color="#208020"># cascades.tcl --</font>
<font color="#208020">#</font>
<font color="#208020">#       This file implements the Tcl code for cascades images commands.</font>
<font color="#208020">#</font>
<font color="#208020">#   Copyright 1999 Centre de Recherche Paul Pascal, Bordeaux, France.</font>
<font color="#208020">#   Written by Nicolas Decoster.</font>
<font color="#208020">#</font>
<font color="#208020">#  RCS : $Id$</font>
<font color="#208020">#</font>

package provide cascades


<font color="#208020"># ---------- Singular cascades with/without fractionnal integration ----------</font>


<font color="#208020"># scGetTauEps --</font>
<font color="#208020"># usage: scGetTauEps string real real real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Create a signal that contains the theoretical tau(q) specrtum of a 2D</font>
<font color="#208020"># singular cascade (p-model). </font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Value of p. Must be 0 &lt;= p &lt; 1/2.</font>
<font color="#208020">#   real   - First value of q.</font>
<font color="#208020">#   real   - Last value of q.</font>
<font color="#208020">#   real   - Value of the dq. Default is 0.1.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Name of the result.</font>

<strong><a name="scGetTauEps_33">proc <a href="cascades.tcl-annot.html#scGetTauEps">scGetTauEps</a></a></strong><a name="scGetTauEps"></a> {sig p qMin qMax {dx 0.1}} {
    if {$p &lt; 0 || $p &gt;= 0.5} {
	return -code error &#34;p must be 0 &lt;= p &lt; 1/2&#34;
    }

    set n [expr { int(($qMax - $qMin)/$dx + 1) }]
    exprr $sig -1-log(pow(2*$p,x)+pow(2-2*$p,x))/log(2) $qMin $qMax $n

    return $sig
}


<font color="#208020"># scGetDEps --</font>
<font color="#208020"># usage: scGetDEps string real real real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Create a signal that contains the theoretical D(h) spectrum of a 2D</font>
<font color="#208020"># singular cascade (p-model). This spectrum is computing using a legendre</font>
<font color="#208020"># transform of tau(q).</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Value of p. Must be 0 &lt;= p &lt; 1/2.</font>
<font color="#208020">#   real   - First value of q.</font>
<font color="#208020">#   real   - Last value of q.</font>
<font color="#208020">#   real   - Value of the dq. Default is 0.1.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Name of the result.</font>

<strong><a name="scGetDEps_62">proc <a href="cascades.tcl-annot.html#scGetDEps">scGetDEps</a></a></strong><a name="scGetDEps"></a> {sig p qMin qMax {dx 0.1}} {
    if {$p &lt; 0 || $p &gt;= 0.5} {
	return -code error &#34;p must be 0 &lt;= p &lt; 1/2&#34;
    }

    <a name="scGetTauEps(1)"><a href="./cascades.tcl.html#scGetTauEps_33">scGetTauEps</a></a> $sig $p $qMin $qMax $dx
    <a name="legendre(1)"><a href="./legendre.tcl.html#legendre_28">legendre</a></a> $sig 3 $sig
 
    return $sig
}


<font color="#208020"># scGetTau --</font>
<font color="#208020"># usage: scGetTau string real real real real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Create a signal that contains the theoretical tau(q) spectrum of a 2D</font>
<font color="#208020"># singular cascade (p-model) with a fractionnary integration. </font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Value of p. Must be 0 &lt;= p &lt; 1/2.</font>
<font color="#208020">#   real   - H* of the integration.</font>
<font color="#208020">#   real   - First value of q.</font>
<font color="#208020">#   real   - Last value of q.</font>
<font color="#208020">#   real   - Value of the dq. Default is 0.1.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Name of the result.</font>

<strong><a name="scGetTau_91">proc <a href="cascades.tcl-annot.html#scGetTau">scGetTau</a></a></strong><a name="scGetTau"></a> {sig p Hstar qMin qMax {dx 0.1}} {
    if {$p &lt; 0 || $p &gt;= 0.5} {
	return -code error &#34;p must be 0 &lt;= p &lt; 1/2&#34;
    }

    <a name="scGetTauEps(2)"><a href="./cascades.tcl.html#scGetTauEps_33">scGetTauEps</a></a> $sig $p $qMin $qMax $dx
    s2fs $sig $sig x y+$Hstar*x

    return $sig
}


<font color="#208020"># scGetD --</font>
<font color="#208020"># usage: scGetD string real real real real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Create a signal that contains the theoretical D(h) spectrum of a 2D singular</font>
<font color="#208020"># cascade (p-model) with a fractionnary integration. This spectrum is computing</font>
<font color="#208020"># using a legendre transform of tau(q).</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Value of p. Must be 0 &lt;= p &lt; 1/2.</font>
<font color="#208020">#   real   - H* of the integration.</font>
<font color="#208020">#   real   - First value of q.</font>
<font color="#208020">#   real   - Last value of q.</font>
<font color="#208020">#   real   - Value of the dq. Default is 0.1.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Name of the result.</font>

<strong><a name="scGetD_121">proc <a href="cascades.tcl-annot.html#scGetD">scGetD</a></a></strong><a name="scGetD"></a> {sig p Hstar qMin qMax {dx 0.1}} {
    if {$p &lt; 0 || $p &gt;= 0.5} {
	return -code error &#34;p must be 0 &lt;= p &lt; 1/2&#34;
    }

    <a name="scGetTau(1)"><a href="./cascades.tcl.html#scGetTau_91">scGetTau</a></a> $sig $p $Hstar $qMin $qMax $dx
    <a name="legendre(2)"><a href="./legendre.tcl.html#legendre_28">legendre</a></a> $sig 3 $sig
 
    return $sig
}


<font color="#208020"># scGetSpectra --</font>
<font color="#208020"># usage: scGetSpectra string real real real real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Create signals that contain the theoretical spectra (tau(a) and D(h)) of a</font>
<font color="#208020"># 2D singular cascade (p-model) before _and_ after a fractionnary integration.</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Value of p. Must be 0 &lt;= p &lt; 1/2.</font>
<font color="#208020">#   real   - H* of the integration.</font>
<font color="#208020">#   real   - First value of q.</font>
<font color="#208020">#   real   - Last value of q.</font>
<font color="#208020">#   real   - Value of the dq. Default is 0.1.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Name of the result.</font>

<strong><a name="scGetSpectra_150">proc <a href="cascades.tcl-annot.html#scGetSpectra">scGetSpectra</a></a></strong><a name="scGetSpectra"></a> {baseName p Hstar qMin qMax {dx 0.1}} {
    if {$p &lt; 0 || $p &gt;= 0.5} {
	return -code error &#34;p must be 0 &lt;= p &lt; 1/2&#34;
    }

    <a name="scGetTauEps(3)"><a href="./cascades.tcl.html#scGetTauEps_33">scGetTauEps</a></a> ${baseName}teq $p $qMin $qMax $dx
    <a name="scGetTau(2)"><a href="./cascades.tcl.html#scGetTau_91">scGetTau</a></a> ${baseName}tq $p $Hstar $qMin $qMax $dx
    <a name="scGetDEps(1)"><a href="./cascades.tcl.html#scGetDEps_62">scGetDEps</a></a> ${baseName}Deh $p $qMin $qMax $dx
    <a name="scGetD(1)"><a href="./cascades.tcl.html#scGetD_121">scGetD</a></a> ${baseName}Dh $p $Hstar $qMin $qMax $dx

    return [list ${baseName}teq ${baseName}tq ${baseName}Deh ${baseName}Dh]
}


<font color="#208020"># scH2BetaPhy --</font>
<font color="#208020"># usage: scH2BetaPhy real real</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the value of beta phi. This is needed by the fortran program that</font>
<font color="#208020"># generates the 2D singular cascade + integration. This program was written by</font>
<font color="#208020"># A. Davis. ** Warning **: The fortran program need the value of beta phi - 1 (I</font>
<font color="#208020"># guess it is in memory of 1D cascades).</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   real   - Value of p. Must be 0 &lt;= p &lt; 1/2.</font>
<font color="#208020">#   real   - H* of the integration.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Value of beta phy.</font>

<strong><a name="scH2BetaPhy_179">proc <a href="cascades.tcl-annot.html#scH2BetaPhy">scH2BetaPhy</a></a></strong><a name="scH2BetaPhy"></a> {p Hstar} {
    if {$p &lt; 0 || $p &gt;= 0.5} {
	return -code error &#34;p must be 0 &lt;= p &lt; 1/2&#34;
    }

    set betaEps2 [expr { 1 - log(2*$p*$p - 2*$p + 1)/log(2) }]
    return [expr { 2*$Hstar + $betaEps2 }]
}


<font color="#208020"># scBetaPhy2H --</font>
<font color="#208020"># usage: scBetaPhy2H real real</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute the value of H*.</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   real   - Value of p. Must be 0 &lt;= p &lt; 1/2.</font>
<font color="#208020">#   real   - Beta phy.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Value of H*.</font>

<strong><a name="scBetaPhy2H_201">proc <a href="cascades.tcl-annot.html#scBetaPhy2H">scBetaPhy2H</a></a></strong><a name="scBetaPhy2H"></a> {p betaPhy} {
    if {$p &lt; 0 || $p &gt;= 0.5} {
	return -code error &#34;p must be 0 &lt;= p &lt; 1/2&#34;
    }

    set betaEps2 [expr { 1 - log(2*$p*$p - 2*$p + 1)/log(2) }]
    return [expr { ($betaPhy - $betaEps2)/2 }]
}



<font color="#208020"># ---------- Cascades using orthogonal wavelets ----------</font>


<font color="#208020"># wcGetPhiStar --</font>
<font color="#208020"># usage: wcGetPhiStar real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Return an approximation (dichotomy) of Phi* and the value of c3. Phi* verifies</font>
<font color="#208020"># the following formula:</font>
<font color="#208020">#                                                </font>
<font color="#208020">#     sin(2 Phi*)       k                           (tau(2)/2 + 2)</font>
<font color="#208020">#    ------------- = ------- - 0.5, with k = 2 x cst              .</font>
<font color="#208020">#        4 Phi*       1 + k</font>
<font color="#208020">#</font>
<font color="#208020"># c3 verifies the following formula:</font>
<font color="#208020">#</font>
<font color="#208020">#            -(tau(2)/4 + 1)</font>
<font color="#208020">#    c3 = cst               .</font>
<font color="#208020">#</font>
<font color="#208020"># This is used to determine the Phi* angle and the largest scale coefficient</font>
<font color="#208020"># (c3) used to cascade the XY component on a wavelet base. The value of cst</font>
<font color="#208020"># reflect the...</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   real   - Value of tau(2).</font>
<font color="#208020">#   [real] - Value of cst. Default is 2.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Phi* and c3.</font>

<strong><a name="wcGetPhiStar_241">proc <a href="cascades.tcl-annot.html#wcGetPhiStar">wcGetPhiStar</a></a></strong><a name="wcGetPhiStar"></a> {tau2 {cst 2}} {
    <font color="#208020"># Precision on Phi*.</font>
    set eps 0.0000001

    set k [expr { 2*pow($cst,$tau2/2+2) }]
    set C [expr { $k/(1+$k)-0.5 }]

    if {$C == 0.5} {
	<font color="#208020"># 0.5 is the limit of sin(2 Phi*)/(4 Phi*) when Phi*-&gt;0.</font>

	return 0
    }

    set p1 $eps
    set val1 [expr { sin(2*$p1)/(4*$p1) - $C }]

    set p2 [expr { acos(-1)/2.0 }]
    set val2 [expr { sin(2*$p2)/(4*$p2) - $C }]

    set diff [expr { $p2-$p1 }]

    while {$diff &gt; $eps} {
	set p [expr { ($p2+$p1)/2.0 }]
	set val [expr { sin(2*$p)/(4*$p) - $C }]

	if {$val*$val1 &gt; 0} {
	    set p1 $p
	    set val1 $val
	} else {
	    set p2 $p
	    set val2 $val
	}

	set diff [expr { $p2-$p1 }]
    }

    set c3 [expr { pow($cst,-($tau2/4+1)) }]

    return [list $p1 $c3]
}



<font color="#208020"># ---------- Log-normal cascade using orthogonal wavelets ----------</font>


<font color="#208020"># lncGetTau --</font>
<font color="#208020"># usage: lncGetTau string real real real real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Create a signal that contains the theoretical tau(q) spectrum of a 2D</font>
<font color="#208020"># log-normal cascade using orthogonal wavelets. Here is the formula:</font>
<font color="#208020">#</font>
<font color="#208020">#                     2</font>
<font color="#208020">#                    s      2     m q</font>
<font color="#208020">#     tau(q) = - --------- q  - ------- - 2, with s = sigma and m = mean.</font>
<font color="#208020">#                 2 ln(2)        ln(2)</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Squared sigma.</font>
<font color="#208020">#   real   - Mean.</font>
<font color="#208020">#   real   - First value of q (qMin).</font>
<font color="#208020">#   real   - Last value of q (qMax).</font>
<font color="#208020">#   real   - Value of the dq. Default is 0.1.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Name of the result. If qMin equals qMax the result is tau(qMin).</font>

<strong><a name="lncGetTau_309">proc <a href="cascades.tcl-annot.html#lncGetTau">lncGetTau</a></a></strong><a name="lncGetTau"></a> {sig sigma2 mean qMin qMax {dq 0.1}} {

    if {$qMin == $qMax} {
	set q $qMin
	return [expr { -${sigma2}*$q*$q/(2*log(2))-${mean}*$q/log(2)-2 }]
    }

    set n [expr { int(($qMax - $qMin)/$dq + 1) }]

    <font color="#208020">#exprr $sig -${mean}*x-${sigma2}*x*x/2-2 $qMin $qMax $n</font>

    exprr $sig -${sigma2}*x*x/(2*log(2))-${mean}*x/log(2)-2 $qMin $qMax $n

    return $sig
}



<font color="#208020"># lncGetH --</font>
<font color="#208020"># usage: lncGetTau string real real real real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Create a signal that contains the theoretical h(q) of a 2D</font>
<font color="#208020"># log-normal cascade using orthogonal wavelets. Here is the formula:</font>
<font color="#208020">#</font>
<font color="#208020">#                     2</font>
<font color="#208020">#                   s              m</font>
<font color="#208020">#     tau(q) = - --------- q  - ------- , with s = sigma and m = mean.</font>
<font color="#208020">#                  ln(2)         ln(2)</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Squared sigma.</font>
<font color="#208020">#   real   - Mean.</font>
<font color="#208020">#   real   - First value of q (qMin).</font>
<font color="#208020">#   real   - Last value of q (qMax).</font>
<font color="#208020">#   real   - Value of the dq. Default is 0.1.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Name of the result. If qMin equals qMax the result is h(qMin).</font>

<strong><a name="lncGetH_349">proc <a href="cascades.tcl-annot.html#lncGetH">lncGetH</a></a></strong><a name="lncGetH"></a> {sig sigma2 mean qMin qMax {dq 0.1}} {

    if {$qMin == $qMax} {
	set q $qMin
	return [expr { -${sigma2}*$q/(log(2))-${mean}/log(2) }]
    }

    set n [expr { int(($qMax - $qMin)/$dq + 1) }]

    <font color="#208020">#exprr $sig -${mean}*x-${sigma2}*x*x/2-2 $qMin $qMax $n</font>

    exprr $sig -${sigma2}*x/(log(2))-${mean}/log(2) $qMin $qMax $n

    return $sig
}


<font color="#208020"># lncGetD --</font>
<font color="#208020"># usage: lncGetD string real real real real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Create a signal that contains the theoretical D(h) spectrum of a 2D</font>
<font color="#208020"># log-normal cascade using orthogonal wavelets. Here is the formula:</font>
<font color="#208020">#</font>
<font color="#208020">#                                2</font>
<font color="#208020">#             - ( h + m / ln(2) )</font>
<font color="#208020">#     D(h) = ---------------------- + 2, with s = sigma and m = mean.</font>
<font color="#208020">#                    2</font>
<font color="#208020">#                 2 s / ln(2)</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Squared sigma.</font>
<font color="#208020">#   real   - Mean.</font>
<font color="#208020">#   real   - First value of h (hMin).</font>
<font color="#208020">#   real   - Last value of h (hMax).</font>
<font color="#208020">#   real   - Value of the dh. Default is 0.1.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Name of the result. If hMin equals hMax the result is D(hMin).</font>

<strong><a name="lncGetD_389">proc <a href="cascades.tcl-annot.html#lncGetD">lncGetD</a></a></strong><a name="lncGetD"></a> {sig sigma2 mean hMin hMax {dh 0.1}} {

    if {$hMin == $hMax} {
	set h $hMin
	return [expr { -pow($h+${mean}/log(2),2)/(2*${sigma2}/log(2))+2 }]
    }

    set n [expr { int(($hMax - $hMin)/$dh + 1) }]

    exprr $sig -pow(x+${mean}/log(2),2)/(2*${sigma2}/log(2))+2 $hMin $hMax $n
 
    return $sig
}


<font color="#208020"># lncGetG --</font>
<font color="#208020"># usage: lncGetG string string real real real real real real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute 2 signals that contains the theoretical mod(G^) and phi(G^). Here is</font>
<font color="#208020"># the formula:</font>
<font color="#208020">#</font>
<font color="#208020">#                          2    2</font>
<font color="#208020">#     mod(G^(p)) = exp( - s  * p  s(a,a') ),</font>
<font color="#208020">#</font>
<font color="#208020">#     phi(G^(p)) = s(a,a') * p * m,</font>
<font color="#208020">#</font>
<font color="#208020">#     with s(a,a') = log2 (a/a'), s = sigma  and m = mean.</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   string - Name of signal for mod(G^).</font>
<font color="#208020">#   string - Name of signal for phi(G^).</font>
<font color="#208020">#   real   - Squared sigma.</font>
<font color="#208020">#   real   - Mean.</font>
<font color="#208020">#   real   - Value of a/a'.</font>
<font color="#208020">#   real   - First value of p (pMin).</font>
<font color="#208020">#   real   - Last value of p (pMax).</font>
<font color="#208020">#   real   - Value of the dp. Default is 0.01.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="lncGetG_430">proc <a href="cascades.tcl-annot.html#lncGetG">lncGetG</a></a></strong><a name="lncGetG"></a> {sigm siga sigma2 mean da pMin pMax {dp 0.01}} {
    set n [expr { int(($pMax - $pMin)/$dp + 1) }]

    exprr $sigm exp(-$sigma2*x*x*log($da)/(2*log(2))) $pMin $pMax $n
    exprr $siga (x*$mean)*log($da)/log(2)  $pMin $pMax $n

    return
}


<font color="#208020"># ---------- Log-Poisson cascade using orthogonal wavelets ----------</font>


<font color="#208020"># lpcGetTau --</font>
<font color="#208020"># usage: lpcGetTau string real real real real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Create a signal that contains the theoretical tau(q) spectrum of a 2D</font>
<font color="#208020"># log-Poisson cascade using orthogonal wavelets. Here is the formula:</font>
<font color="#208020">#</font>
<font color="#208020">#                 l           q       g</font>
<font color="#208020">#     tau(q) = ------- ( 1 - b ) - ------- q - 2, with b = beta, g = gamma</font>
<font color="#208020">#               ln(2)               ln(2)                       and l = lambda.</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Beta.</font>
<font color="#208020">#   real   - Gamma.</font>
<font color="#208020">#   real   - Lambda.</font>
<font color="#208020">#   real   - First value of q (qMin).</font>
<font color="#208020">#   real   - Last value of q (qMax).</font>
<font color="#208020">#   real   - Value of the dq. Default is 0.1.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Name of the result. If qMin equals qMax the result is tau(qMin).</font>

<strong><a name="lpcGetTau_465">proc <a href="cascades.tcl-annot.html#lpcGetTau">lpcGetTau</a></a></strong><a name="lpcGetTau"></a> {sig beta gamma lambda qMin qMax {dq 0.1}} {

    if {$qMin == $qMax} {
	set q $qMin
	return [expr { ${lambda}*(1-pow(${beta},$q))/log(2)-${gamma}*$q/log(2)-2 }]
    }

    set n [expr { int(($qMax - $qMin)/$dq + 1) }]

    exprr $sig ${lambda}*(1-pow(${beta},x))/log(2)-${gamma}*x/log(2)-2 \
	    $qMin $qMax $n

    return $sig
}


<font color="#208020"># lpcGetD --</font>
<font color="#208020"># usage: lpcGetD string real real real real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Create a signal that contains the theoretical D(h) spectrum of a 2D</font>
<font color="#208020"># log-Poisson cascade using orthogonal wavelets. Here is the formula:</font>
<font color="#208020">#</font>
<font color="#208020">#                h         g                h + g/ln(2)                  l</font>
<font color="#208020">#     D(h) = ( ----- + ---------- ) ( ln(----------------) - 1 ) + 2 - -----,</font>
<font color="#208020">#              ln(b)   ln(2)ln(b)        -l/ln(2) * ln(b)              ln(2)</font>
<font color="#208020">#</font>
<font color="#208020">#     with b = beta, g = gamma and l = lambda.</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   string - Name of the result.</font>
<font color="#208020">#   real   - Beta.</font>
<font color="#208020">#   real   - Gamma.</font>
<font color="#208020">#   real   - Lambda.</font>
<font color="#208020">#   real   - First value of h (hMin).</font>
<font color="#208020">#   real   - Last value of h (hMax).</font>
<font color="#208020">#   real   - Value of the dh. Default is 0.1.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   Name of the result. If hMin equals hMax the result is D(hMin).</font>

<strong><a name="lpcGetD_505">proc <a href="cascades.tcl-annot.html#lpcGetD">lpcGetD</a></a></strong><a name="lpcGetD"></a> {sig beta gamma lambda hMin hMax {dh 0.1}} {

    if {$hMin == $hMax} {
	set h $hMin
	return [expr { -pow($h+${mean}/log(2),2)/(2*${sigma2}/log(2))+2 }]
    }

    set n [expr { int(($hMax - $hMin)/$dh + 1) }]

    exprr $sig (x/log(${beta})+(${gamma})/(log(2)*log(${beta})))*(log((x+(${gamma})/log(2))/(-${lambda}*log(${beta})/log(2)))-1)+2-${lambda}/log(2) \
	    $hMin $hMax $n

    return $sig
}


<font color="#208020"># lpcGetG --</font>
<font color="#208020"># usage: lpcGetG string string real real real real real real [real]</font>
<font color="#208020">#</font>
<font color="#208020">#   Compute 2 signals that contains the theoretical mod(G^) and phi(G^). Here is</font>
<font color="#208020"># the formula:</font>
<font color="#208020">#</font>
<font color="#208020">#</font>
<font color="#208020">#     mod(G^(p)) = exp( s(a,a') l * (cos(p ln(b)) - 1) ),</font>
<font color="#208020">#</font>
<font color="#208020">#     phi(G^(p)) = s(a,a') (p * g + l * sin(p ln(b))),</font>
<font color="#208020">#</font>
<font color="#208020">#     with s(a,a') = log2 (a/a'), b = beta, g = gamma and l = lambda.</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   string - Name of signal for mod(G^).</font>
<font color="#208020">#   string - Name of signal for phi(G^).</font>
<font color="#208020">#   real   - Beta.</font>
<font color="#208020">#   real   - Gamma.</font>
<font color="#208020">#   real   - Lambda.</font>
<font color="#208020">#   real   - Value of a/a'.</font>
<font color="#208020">#   real   - First value of p (pMin).</font>
<font color="#208020">#   real   - Last value of p (pMax).</font>
<font color="#208020">#   real   - Value of the dp. Default is 0.01.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value:</font>
<font color="#208020">#   None.</font>

<strong><a name="lpcGetG_548">proc <a href="cascades.tcl-annot.html#lpcGetG">lpcGetG</a></a></strong><a name="lpcGetG"></a> {sigm siga beta gamma lambda da pMin pMax {dp 0.01}} {
    set n [expr { int(($pMax - $pMin)/$dp + 1) }]

    exprr $sigm exp($lambda*(cos(x*log($beta))-1)*log($da)/log(2)) $pMin $pMax $n
    exprr $siga (x*$gamma+$lambda*sin(x*log($beta)))*log($da)/log(2) $pMin $pMax $n

    return
}

</pre>
<hr>
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#byfilename">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a><br>
<cite>File generated 2008-04-03 at 09:49.</cite>
</font>
</body>
</html>
