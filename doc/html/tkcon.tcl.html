<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- Generated by TclDoc 0.3 -->
<html>
<head><title>tkcon.tcl</title></head>
<body bgcolor="#ffffff">
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#tkcon.tcl">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a>
</font>
<hr>
<strong>tkcon.tcl</strong>
(<a href="tkcon.tcl-annot.html">annotations</a> | <a href="tkcon.tcl.txt">original source</a>)
<p>
<pre>
<font color="#208020">#!/bin/sh</font>
<font color="#208020"># \exec wish &#34;$0&#34; ${1+&#34;$@&#34;}</font>

<font color="#208020">#</font>
<font color="#208020">## tkcon.tcl</font>
<font color="#208020">## Enhanced Tk Console, part of the VerTcl system</font>
<font color="#208020">##</font>
<font color="#208020">## Originally based off Brent Welch's Tcl Shell Widget</font>
<font color="#208020">## (from &#34;Practical Programming in Tcl and Tk&#34;)</font>
<font color="#208020">##</font>
<font color="#208020">## Thanks to the following (among many) for early bug reports &amp; code ideas:</font>
<font color="#208020">## Steven Wahl, Jan Nijtmans, Mark Crimmins, Wart</font>
<font color="#208020">##</font>
<font color="#208020">## Copyright (c) 1995-2004 Jeffrey Hobbs, jeff(a)hobbs(.)org</font>
<font color="#208020">## Initiated: Thu Aug 17 15:36:47 PDT 1995</font>
<font color="#208020">##</font>
<font color="#208020">## source standard_disclaimer.tcl</font>
<font color="#208020">## source bourbon_ware.tcl</font>
<font color="#208020">##</font>

<font color="#208020"># Proxy support for retrieving the current version of Tkcon.</font>
<font color="#208020">#</font>
<font color="#208020"># Mon Jun 25 12:19:56 2001 - Pat Thoyts</font>
<font color="#208020">#</font>
<font color="#208020"># In your tkcon.cfg or .tkconrc file put your proxy details into the</font>
<font color="#208020"># `proxy' member of the `PRIV' array. e.g.:</font>
<font color="#208020">#</font>
<font color="#208020">#    set ::tkcon::PRIV(proxy) wwwproxy:8080</font>
<font color="#208020">#</font>
<font color="#208020"># If you want to be prompted for proxy authentication details (eg for</font>
<font color="#208020"># an NT proxy server) make the second element of this variable non-nil - eg:</font>
<font color="#208020">#</font>
<font color="#208020">#    set ::tkcon::PRIV(proxy) {wwwproxy:8080 1}</font>
<font color="#208020">#</font>
<font color="#208020"># Or you can set the above variable from within tkcon by calling </font>
<font color="#208020">#</font>
<font color="#208020">#    tkcon master set ::tkcon:PRIV(proxy) wwwproxy:8080</font>
<font color="#208020">#</font>

if {$tcl_version &lt; 8.0} {
    return -code error &#34;tkcon requires at least Tcl/Tk8&#34;
} else {
    package require Tk
}

<font color="#208020"># We need to load some package to get what's available, and we</font>
<font color="#208020"># choose ctext because we'll use it if its available in the editor</font>
catch {package require ctext}
foreach pkg [info loaded {}] {
    set file [lindex $pkg 0]
    set name [lindex $pkg 1]
    if {![catch {set version [package require $name]}]} {
	if {[string match {} [package ifneeded $name $version]]} {
	    package ifneeded $name $version [list load $file $name]
	}
    }
}
catch {unset pkg file name version}

<font color="#208020"># Tk 8.4 makes previously exposed stuff private.</font>
<font color="#208020"># FIX: Update tkcon to not rely on the private Tk code.</font>
<font color="#208020">#</font>
if {![llength [info globals tkPriv]]} {
    ::tk::unsupported::ExposePrivateVariable tkPriv
}
foreach cmd {SetCursor UpDownLine Transpose ScrollPages} {
    if {![llength [info commands tkText$cmd]]} {
        ::tk::unsupported::ExposePrivateCommand tkText$cmd
    }
}

<font color="#208020"># Initialize the ::tkcon namespace</font>
<font color="#208020">#</font>
namespace eval ::tkcon {
    <font color="#208020"># when modifying this line, make sure that the auto-upgrade check</font>
    <font color="#208020"># for version still works.</font>
    variable VERSION &#34;2.4&#34;
    <font color="#208020"># The OPT variable is an array containing most of the optional</font>
    <font color="#208020"># info to configure.  COLOR has the color data.</font>
    variable OPT
    variable COLOR

    <font color="#208020"># PRIV is used for internal data that only tkcon should fiddle with.</font>
    variable PRIV
    set PRIV(WWW) [info exists embed_args]

    variable EXPECT 0
}

<font color="#208020">## ::tkcon::Init - inits tkcon</font>
<font color="#208020">#</font>
<font color="#208020"># Calls:	::tkcon::InitUI</font>
<font color="#208020"># Outputs:	errors found in tkcon's resource file</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::Init_95">proc <a href="tkcon.tcl-annot.html#::tkcon::Init">::tkcon::Init</a></a></strong><a name="::tkcon::Init"></a> {args} {
    variable VERSION
    variable OPT
    variable COLOR
    variable PRIV
    global tcl_platform env tcl_interactive errorInfo

    set tcl_interactive 1
    set argc [llength $args]

    <font color="#208020">##</font>
    <font color="#208020">## When setting up all the default values, we always check for</font>
    <font color="#208020">## prior existence.  This allows users who embed tkcon to modify</font>
    <font color="#208020">## the initial state before tkcon initializes itself.</font>
    <font color="#208020">##</font>

    <font color="#208020"># bg == {} will get bg color from the main toplevel (in InitUI)</font>
    foreach {key default} {
	bg		{}
	blink		\#FFFF00
	cursor		\#000000
	disabled	\#4D4D4D
	<strong><a name="\#008800_117">proc		<a href="tkcon.tcl-annot.html#\#008800">\#008800</a></a></strong><a name="\#008800"></a>
	var		\#FFC0D0
	prompt		\#8F4433
	stdin		\#000000
	stdout		\#0000FF
	stderr		\#FF0000
    } {
	if {![info exists COLOR($key)]} { set COLOR($key) $default }
    }

    <font color="#208020"># expandorder could also include 'Xotcl' (before Procname)</font>
    foreach {key default} {
	autoload	{}
	blinktime	500
	blinkrange	1
	buffer		512
	maxlinelen	0
	calcmode	0
	cols		80
	debugPrompt	{(level \#$level) debug [history nextid] &gt; }
	dead		{}
	<a name="edit(1)"><a href="./tkcon.tcl.html#edit_3734">edit</a></a>		edit
	expandorder	{Pathname Variable Procname}
	font		{}
	history		48
	hoterrors	1
	library		{}
	lightbrace	1
	lightcmd	1
	maineval	{}
	maxmenu		18
	nontcl		0
	prompt1		{ignore this, it's set below}
	rows		20
	scrollypos	right
	showmenu	1
	showmultiple	1
	showstatusbar	1
	slaveeval	{}
	slaveexit	close
	subhistory	1
	gc-delay	60000
	gets		{congets}
	overrideexit	1
	usehistory	1

	exec		slave
    } {
	if {![info exists OPT($key)]} { set OPT($key) $default }
    }

    foreach {key default} {
	app		{}
	appname		{}
	apptype		slave
	namesp		::
	cmd		{}
	cmdbuf		{}
	cmdsave		{}
	event		1
	deadapp		0
	deadsock	0
	debugging	0
	displayWin	.
	histid		0
	find		{}
	find,case	0
	find,reg	0
	errorInfo	{}
	protocol	exit
	showOnStartup	1
	slaveprocs	{
	    <a name="alias(1)"><a href="./tkcon.tcl.html#alias_3918">alias</a></a> clear dir dump echo idebug lremove
	    <a name="tkcon_puts(1)"><a href="./tkcon.tcl.html#tkcon_puts_3648">tkcon_puts</a></a> tkcon_gets observe observe_var unalias which what
	}
	RCS		{RCS: @(#) $Id: tkcon.tcl,v 1.98 2006/09/05 23:08:31 hobbs Exp $}
	HEADURL		{http://tkcon.cvs.sourceforge.net/tkcon/tkcon/tkcon.tcl?rev=HEAD}

	docs		&#34;http://tkcon.sourceforge.net/&#34;
	email		{jeff(a)hobbs(.)org}
	root		.
	uid		0
	tabs		{}
    } {
	if {![info exists PRIV($key)]} { set PRIV($key) $default }
    }
    foreach {key default} {
	slavealias	{ $OPT(edit) more less tkcon }
    } {
	if {![info exists PRIV($key)]} { set PRIV($key) [subst $default] }
    }
    set PRIV(version) $VERSION

    if {[info exists PRIV(name)]} {
	set title $PRIV(name)
    } else {
	MainInit
	<font color="#208020"># some main initialization occurs later in this proc,</font>
	<font color="#208020"># to go after the UI init</font>
	set MainInit 1
	set title Main
    }

    <font color="#208020">## NOTES FOR STAYING IN PRIMARY INTERPRETER:</font>
    <font color="#208020">##</font>
    <font color="#208020">## If you set ::tkcon::OPT(exec) to {}, then instead of a multiple</font>
    <font color="#208020">## interp model, you get tkcon operating in the main interp by default.</font>
    <font color="#208020">## This can be useful when attaching to programs that like to operate</font>
    <font color="#208020">## in the main interpter (for example, based on special wish'es).</font>
    <font color="#208020">## You can set this from the command line with -exec &#34;&#34;</font>
    <font color="#208020">## A side effect is that all tkcon command line args will be used</font>
    <font color="#208020">## by the first console only.</font>
    <font color="#208020">#set OPT(exec) {}</font>

    if {$PRIV(WWW)} {
	lappend PRIV(slavealias) history
	set OPT(prompt1) {[history nextid] % }
    } else {
	lappend PRIV(slaveprocs) tcl_unknown unknown
	set OPT(prompt1) {([file tail [pwd]]) [history nextid] % }
    }

    <font color="#208020">## If we are using the default '.' toplevel, and there appear to be</font>
    <font color="#208020">## children of '.', then make sure we use a disassociated toplevel.</font>
    if {$PRIV(root) == &#34;.&#34; &amp;&amp; [llength [winfo children .]]} {
	set PRIV(root) .tkcon
    }

    set root &#34;[<a name="tk(1)"><a href="./tkcon.tcl.html#tk_6296">tk</a></a> appname]$PRIV(root)&#34;
    option add $root*Menu.tearOff 0
    option add $root*takeFocus 0
    option add $root*Text.borderWidth 1
    option add $root*Listbox.borderWidth 1
    option add $root*Listbox.background white
    option add $root*Text.highlightThickness 1
    if {$::tcl_version &gt;= 8.4 &amp;&amp; [<a name="tk(2)"><a href="./tkcon.tcl.html#tk_6296">tk</a></a> windowingsystem] != &#34;aqua&#34;} {
	option add $root*Scrollbar.borderWidth 1
    }

    <font color="#208020">## Do platform specific configuration here, other than defaults</font>
    <font color="#208020">### Use tkcon.cfg filename for resource filename on non-unix systems</font>
    <font color="#208020">### Determine what directory the resource file should be in</font>
    switch $tcl_platform(platform) {
	macintosh	{
	    if {![interp issafe]} {cd [file dirname [info script]]}
	    set envHome		PREF_FOLDER
	    set rcfile		tkcon.cfg
	    set histfile	tkcon.hst
	    catch {console hide}
	}
	windows		{
	    set envHome		HOME
	    set rcfile		tkcon.cfg
	    set histfile	tkcon.hst
	}
	unix		{
	    set envHome		HOME
	    set rcfile		.tkconrc
	    set histfile	.tkcon_history
	}
    }
    if {[info exists env($envHome)]} {
	set home $env($envHome)
	if {[file pathtype $home] == &#34;volumerelative&#34;} {
	    <font color="#208020"># Convert 'C:' to 'C:/' if necessary, innocuous otherwise</font>
	    append home /
	}
	if {![info exists PRIV(rcfile)]} {
	    set PRIV(rcfile)	[file join $home $rcfile]
	}
	if {![info exists PRIV(histfile)]} {
	    set PRIV(histfile)	[file join $home $histfile]
	}
    }

    <font color="#208020">## Handle command line arguments before sourcing resource file to</font>
    <font color="#208020">## find if resource file is being specified (let other args pass).</font>
    if {[set i [lsearch -exact $args -rcfile]] != -1} {
	set PRIV(rcfile) [lindex $args [incr i]]
    }

    if {!$PRIV(WWW) &amp;&amp; [file exists $PRIV(rcfile)]} {
	set code [catch {uplevel \#0 [list source $PRIV(rcfile)]} err]
    }

    if {[info exists env(TK_CON_LIBRARY)]} {
	lappend ::auto_path $env(TK_CON_LIBRARY)
    } elseif {$OPT(library) != &#34;&#34;} {
	lappend ::auto_path $OPT(library)
    }

    if {![info exists ::tcl_pkgPath]} {
	set dir [file join [file dirname [info nameofexec]] lib]
	if {[llength [info commands @scope]]} {
	    set dir [file join $dir itcl]
	}
	catch {source [file join $dir pkgIndex.tcl]}
    }
    catch {tclPkgUnknown dummy-name dummy-version}

    <font color="#208020">## Handle rest of command line arguments after sourcing resource file</font>
    <font color="#208020">## and slave is created, but before initializing UI or setting packages.</font>
    set slaveargs {}
    set slavefiles {}
    set slaveargv0 {}
    set truth {^(1|yes|true|on)$}
    for {set i 0} {$i &lt; $argc} {incr i} {
	set arg [lindex $args $i]
	if {[string match {-*} $arg]} {
	    set val [lindex $args [incr i]]
	    <font color="#208020">## Handle arg based options</font>
	    switch -glob -- $arg {
		-- - -argv - -args {
		    set argv [concat -- [lrange $argv $i end]]
		    set argc [llength $argv]
		    break
		}
		-color-*	{ set COLOR([string range $arg 7 end]) $val }
		-exec		{ set OPT(exec) $val }
		-main - -e - -eval	{ append OPT(maineval) \n$val\n }
		-package - -load	{ lappend OPT(autoload) $val }
		-slave		{ append OPT(slaveeval) \n$val\n }
		-nontcl		{ set OPT(nontcl) [regexp -nocase $truth $val]}
		-root		{ set PRIV(root) $val }
		-font		{ set OPT(font) $val }
		-rcfile	{}
		default	{ lappend slaveargs $arg; incr i -1 }
	    }
	} elseif {[file isfile $arg]} {
	    if {$i == 0} {
		set slaveargv0 $arg
	    }
	    lappend slavefiles $arg
	} else {
	    lappend slaveargs $arg
	}
    }

    <font color="#208020">## Create slave executable</font>
    if {&#34;&#34; != $OPT(exec)} {
	InitSlave $OPT(exec) $slaveargs $slaveargv0
    } else {
	set argc [llength $slaveargs]
	set args $slaveargs
	uplevel \#0 $slaveargs
    }

    <font color="#208020">## Attach to the slave, EvalAttached will then be effective</font>
    Attach $PRIV(appname) $PRIV(apptype)
    InitUI $title
    if {&#34;&#34; != $OPT(exec)} {
	<font color="#208020"># override exit to DeleteTab now that tab has been created</font>
	$OPT(exec) alias exit ::tkcon::DeleteTab $PRIV(curtab) $OPT(exec)
    }

    <font color="#208020">## swap puts and gets with the tkcon versions to make sure all</font>
    <font color="#208020">## input and output is handled by tkcon</font>
    if {![catch {rename ::puts ::tkcon_tcl_puts}]} {
	interp alias {} ::puts {} ::tkcon_puts
    }
    if {($OPT(gets) != &#34;&#34;) &amp;&amp; ![catch {rename ::gets ::tkcon_tcl_gets}]} {
	interp alias {} ::gets {} ::tkcon_gets
    }

    EvalSlave history keep $OPT(history)
    if {[info exists MainInit]} {
	<font color="#208020"># Source history file only for the main console, as all slave</font>
	<font color="#208020"># consoles will adopt from the main's history, but still</font>
	<font color="#208020"># keep separate histories</font>
	if {!$PRIV(WWW) &amp;&amp; $OPT(usehistory) &amp;&amp; [file exists $PRIV(histfile)]} {
	    puts -nonewline &#34;loading history file ... &#34;
	    <font color="#208020"># The history file is built to be loaded in and</font>
	    <font color="#208020"># understood by tkcon</font>
	    if {[catch {uplevel \#0 [list source $PRIV(histfile)]} herr]} {
		puts stderr &#34;error:\n$herr&#34;
		append PRIV(errorInfo) $errorInfo\n
	    }
	    set PRIV(event) [EvalSlave history nextid]
	    puts &#34;[expr {$PRIV(event)-1}] events added&#34;
	}
    }

    <font color="#208020">## Autoload specified packages in slave</font>
    set pkgs [EvalSlave package names]
    foreach pkg $OPT(autoload) {
	puts -nonewline &#34;autoloading package \&#34;$pkg\&#34; ... &#34;
	if {[lsearch -exact $pkgs $pkg]&gt;-1} {
	    if {[catch {EvalSlave package require [list $pkg]} pkgerr]} {
		puts stderr &#34;error:\n$pkgerr&#34;
		append PRIV(errorInfo) $errorInfo\n
	    } else { puts &#34;OK&#34; }
	} else {
	    puts stderr &#34;error: package does not exist&#34;
	}
    }

    <font color="#208020">## Evaluate maineval in slave</font>
    if {[string compare {} $OPT(maineval)] &amp;&amp; \
	    [catch {uplevel \#0 $OPT(maineval)} merr]} {
	puts stderr &#34;error in eval:\n$merr&#34;
	append PRIV(errorInfo) $errorInfo\n
    }

    <font color="#208020">## Source extra command line argument files into slave executable</font>
    foreach fn $slavefiles {
	puts -nonewline &#34;slave sourcing \&#34;$fn\&#34; ... &#34;
	if {[catch {EvalSlave source [list $fn]} fnerr]} {
	    puts stderr &#34;error:\n$fnerr&#34;
	    append PRIV(errorInfo) $errorInfo\n
	} else { puts &#34;OK&#34; }
    }

    <font color="#208020">## Evaluate slaveeval in slave</font>
    if {[string compare {} $OPT(slaveeval)] &amp;&amp; \
	    [catch {interp eval $OPT(exec) $OPT(slaveeval)} serr]} {
	puts stderr &#34;error in slave eval:\n$serr&#34;
	append PRIV(errorInfo) $errorInfo\n
    }
    <font color="#208020">## Output any error/output that may have been returned from rcfile</font>
    if {[info exists code] &amp;&amp; $code &amp;&amp; [string compare {} $err]} {
	puts stderr &#34;error in $PRIV(rcfile):\n$err&#34;
	append PRIV(errorInfo) $errorInfo
    }
    if {[string compare {} $OPT(exec)]} {
	StateCheckpoint [concat $PRIV(name) $OPT(exec)] slave
    }
    StateCheckpoint $PRIV(name) slave

    puts &#34;buffer line limit:\
	[expr {$OPT(buffer)?$OPT(buffer):{unlimited}}]  \
	max line length:\
	[expr {$OPT(maxlinelen)?$OPT(maxlinelen):{unlimited}}]&#34;

    Prompt &#34;$title console display active (Tcl$::tcl_patchLevel / Tk$::tk_patchLevel)\n&#34;
}

<font color="#208020">## ::tkcon::InitSlave - inits the slave by placing key procs and aliases in it</font>
<font color="#208020">## It's arg[cv] are based on passed in options, while argv0 is the same as</font>
<font color="#208020">## the master.  tcl_interactive is the same as the master as well.</font>
<font color="#208020"># ARGS:	slave	- name of slave to init.  If it does not exist, it is created.</font>
<font color="#208020">#	args	- args to pass to a slave as argv/argc</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::InitSlave_459">proc <a href="tkcon.tcl-annot.html#::tkcon::InitSlave">::tkcon::InitSlave</a></a></strong><a name="::tkcon::InitSlave"></a> {slave {slaveargs {}} {slaveargv0 {}}} {
    variable OPT
    variable COLOR
    variable PRIV
    global argv0 tcl_interactive tcl_library env auto_path tk_library

    if {[string match {} $slave]} {
	return -code error &#34;Don't init the master interpreter, goofball&#34;
    }
    if {![interp exists $slave]} { interp create $slave }
    if {[interp eval $slave info command source] == &#34;&#34;} {
	$slave alias source SafeSource $slave
	$slave alias load SafeLoad $slave
	$slave alias open SafeOpen $slave
	$slave alias file file
	interp eval $slave \
	    [list set auto_path [<a name="lremove(1)"><a href="./tkcon.tcl.html#lremove_4738">lremove</a></a> $auto_path $tk_library]]
	interp eval $slave [<a name="dump(1)"><a href="./tkcon.tcl.html#dump_3955">dump</a></a> var -nocomplain tcl_library env]
	interp eval $slave { catch {source [file join $tcl_library init.tcl]} }
	interp eval $slave { catch unknown }
    }
    <font color="#208020"># This will likely be overridden to call DeleteTab where possible</font>
    $slave alias exit exit
    interp eval $slave {
	<font color="#208020"># Do package require before changing around puts/gets</font>
	catch {package require bogus-package-name}
	catch {rename ::puts ::tkcon_tcl_puts}
    }
    foreach cmd $PRIV(slaveprocs) { $slave eval [<a name="dump(2)"><a href="./tkcon.tcl.html#dump_3955">dump</a></a> proc $cmd] }
    foreach cmd $PRIV(slavealias) { $slave alias $cmd $cmd }
    interp alias $slave ::ls $slave ::dir -full
    interp alias $slave ::puts $slave ::tkcon_puts
    if {$OPT(gets) != &#34;&#34;} {
	interp eval $slave { catch {rename ::gets ::tkcon_tcl_gets} }
	interp alias $slave ::gets $slave ::tkcon_gets
    }
    if {$slaveargv0 != &#34;&#34;} {
	<font color="#208020"># If tkcon was invoked with 1 or more filenames, then make the</font>
	<font color="#208020"># first filename argv0 in the slave, as tclsh/wish would do it.</font>
	interp eval $slave [list set argv0 $slaveargv0]
    } else {
	if {[info exists argv0]} {interp eval $slave [list set argv0 $argv0]}
    }
    interp eval $slave set tcl_interactive $tcl_interactive \; \
	    set auto_path [list [<a name="lremove(2)"><a href="./tkcon.tcl.html#lremove_4738">lremove</a></a> $auto_path $tk_library]] \; \
	    set argc [llength $slaveargs] \; \
	    set argv  [list $slaveargs] \; {
	if {![llength [info command bgerror]]} {
	    <strong><a name="bgerror_507">proc <a href="tkcon.tcl-annot.html#bgerror">bgerror</a></a></strong> err {
		global errorInfo
		set body [info body bgerror]
		rename ::bgerror {}
		if {[auto_load bgerror]} { return [<a name="bgerror(1)"><a href="./tkcon.tcl.html#bgerror_512">bgerror</a></a> $err] }
		<strong><a name="bgerror_512">proc <a href="tkcon.tcl-annot.html#bgerror">bgerror</a></a></strong><a name="bgerror"></a> err $body
		<a name="tkcon(1)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> bgerror $err $errorInfo
	    }
	}
    }

    foreach pkg [<a name="lremove(3)"><a href="./tkcon.tcl.html#lremove_4738">lremove</a></a> [package names] Tcl] {
	foreach v [package versions $pkg] {
	    interp eval $slave [list package ifneeded $pkg $v \
		    [package ifneeded $pkg $v]]
	}
    }
}

<font color="#208020">## ::tkcon::InitInterp - inits an interpreter by placing key</font>
<font color="#208020">## procs and aliases in it.</font>
<font color="#208020"># ARGS: name	- interp name</font>
<font color="#208020">#	type	- interp type (slave|interp)</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::InitInterp_531">proc <a href="tkcon.tcl-annot.html#::tkcon::InitInterp">::tkcon::InitInterp</a></a></strong><a name="::tkcon::InitInterp"></a> {name type} {
    variable OPT
    variable PRIV

    <font color="#208020">## Don't allow messing up a local master interpreter</font>
    if {[string match namespace $type] || ([string match slave $type] &amp;&amp; \
	    [regexp {^([Mm]ain|Slave[0-9]+)$} $name])} return
    set old [Attach]
    set oldname $PRIV(namesp)
    catch {
	Attach $name $type
	EvalAttached { catch {rename ::puts ::tkcon_tcl_puts} }
	foreach cmd $PRIV(slaveprocs) { EvalAttached [<a name="dump(3)"><a href="./tkcon.tcl.html#dump_3955">dump</a></a> proc $cmd] }
	switch -exact $type {
	    slave {
		foreach cmd $PRIV(slavealias) {
		    Main interp alias $name ::$cmd $PRIV(name) ::$cmd
		}
	    }
	    interp {
		set thistkcon [<a name="::send::appname(1)"><a href="./tkcon.tcl.html#::send::appname_6269">::send::appname</a></a>]
		foreach cmd $PRIV(slavealias) {
		    EvalAttached &#34;proc $cmd args { <a name="::send::send(1)"><a href="./tkcon.tcl.html#::send::send_6186">::send::send</a></a> [list $thistkcon] $cmd \$args }&#34;
		}
	    }
	}
	<font color="#208020">## Catch in case it's a 7.4 (no 'interp alias') interp</font>
	EvalAttached {
	    catch {interp alias {} ::ls {} ::dir -full}
	    if {[catch {interp alias {} ::puts {} ::tkcon_puts}]} {
		catch {rename ::tkcon_puts ::puts}
	    }
	}
	if {$OPT(gets) != &#34;&#34;} {
	    EvalAttached {
		catch {rename ::gets ::tkcon_tcl_gets}
		if {[catch {interp alias {} ::gets {} ::tkcon_gets}]} {
		    catch {rename ::tkcon_gets ::gets}
		}
	    }
	}
	return
    } {err}
    eval Attach $old
    AttachNamespace $oldname
    if {[string compare {} $err]} { return -code error $err }
}

<font color="#208020">## ::tkcon::InitUI - inits UI portion (console) of tkcon</font>
<font color="#208020">## Creates all elements of the console window and sets up the text tags</font>
<font color="#208020"># ARGS:	root	- widget pathname of the tkcon console root</font>
<font color="#208020">#	title	- title for the console root and main (.) windows</font>
<font color="#208020"># Calls:	::tkcon::InitMenus, ::tkcon::Prompt</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::InitUI_585">proc <a href="tkcon.tcl-annot.html#::tkcon::InitUI">::tkcon::InitUI</a></a></strong><a name="::tkcon::InitUI"></a> {title} {
    variable OPT
    variable PRIV
    variable COLOR

    set root $PRIV(root)
    if {[string match . $root]} { set w {} } else { set w [<a name="toplevel(1)"><a href="./tkcon.tcl.html#toplevel_5837">toplevel</a></a> $root] }
    if {!$PRIV(WWW)} {
	wm withdraw $root
	wm protocol $root WM_DELETE_WINDOW $PRIV(protocol)
    }
    set PRIV(base) $w

    catch {font create tkconfixed -family Courier -size -12}
    catch {font create tkconfixedbold -family Courier -size -12 -weight bold}

    set PRIV(statusbar) [set sbar [frame $w.fstatus]]
    set PRIV(tabframe)  [frame $sbar.tabs]
    set PRIV(X) [button $sbar.deltab -text &#34;X&#34; -command ::tkcon::DeleteTab \
		     -activeforeground red -fg red -font tkconfixedbold \
		     -highlightthickness 0 -padx 2 -pady 0 -borderwidth 1 \
		     -state disabled -relief flat]
    catch {$PRIV(X) configure -overrelief raised}
    label $sbar.cursor -relief sunken -borderwidth 1 -anchor e -width 6 \
	    -textvariable ::tkcon::PRIV(StatusCursor)
    set padx [expr {![info exists ::tcl_platform(os)]
		    || ![string match &#34;Windows CE&#34; $::tcl_platform(os)]}]
    grid $PRIV(X) $PRIV(tabframe) $sbar.cursor -sticky news -padx $padx
    grid configure $PRIV(tabframe) -sticky nsw
    grid configure $PRIV(X) -pady 0 -padx 0
    grid columnconfigure $sbar 1 -weight 1
    grid rowconfigure $sbar 0 -weight 1
    grid rowconfigure $PRIV(tabframe) 0 -weight 1
    if {$::tcl_version &gt;= 8.4 &amp;&amp; [<a name="tk(3)"><a href="./tkcon.tcl.html#tk_6296">tk</a></a> windowingsystem] == &#34;aqua&#34;} {
	<font color="#208020"># resize control space</font>
	grid columnconfigure $sbar [lindex [grid size $sbar] 0] -minsize 16
    }

    <font color="#208020">## Create console tab</font>
    set con [InitTab $w]
    set PRIV(curtab) $con

    <font color="#208020"># Only apply this for the first console</font>
    $con configure -setgrid 1 -width $OPT(cols) -height $OPT(rows)
    bind $PRIV(root) &lt;Configure&gt; {
	if {&#34;%W&#34; == $::tkcon::PRIV(root)} {
	    scan [wm geometry [winfo toplevel %W]] &#34;%%dx%%d&#34; \
		::tkcon::OPT(cols) ::tkcon::OPT(rows)
	    if {[info exists ::tkcon::EXP(spawn_id)]} {
		catch {stty rows $::tkcon::OPT(rows) columns \
			   $::tkcon::OPT(cols) &lt; $::tkcon::EXP(slave,name)}
	    }
	}
    }

    <font color="#208020"># scrollbar</font>
    set sy [scrollbar $w.sy -takefocus 0 -command [list $con yview]]
    if {!$PRIV(WWW) &amp;&amp; [string match &#34;Windows CE&#34; $::tcl_platform(os)]} {
	$w.sy configure -width 10
    }

    $con configure -yscrollcommand [list $sy set]
    set PRIV(console) $con
    set PRIV(scrolly) $sy

    <font color="#208020">## Menus</font>
    <font color="#208020">## catch against use in plugin</font>
    if {[catch {menu $w.mbar} PRIV(menubar)]} {
	set PRIV(menubar) [frame $w.mbar -relief raised -borderwidth 1]
    }

    InitMenus $PRIV(menubar) $title
    Bindings

    if {$OPT(showmenu)} {
	$root configure -menu $PRIV(menubar)
    }

    grid $con  -row 1 -column 1 -sticky news
    grid $sy   -row 1 -column [expr {$OPT(scrollypos)==&#34;left&#34;?0:2}] -sticky ns
    grid $sbar -row 2 -column 0 -columnspan 3 -sticky ew

    grid columnconfigure $root 1 -weight 1
    grid rowconfigure    $root 1 -weight 1

    if {!$OPT(showstatusbar)} {
	grid remove $sbar
    }

    if {!$PRIV(WWW)} {
	wm title $root &#34;tkcon $PRIV(version) $title&#34;
	if {$PRIV(showOnStartup)} { wm deiconify $root }
    }
    if {$PRIV(showOnStartup)} { focus -force $PRIV(console) }
    if {$OPT(gc-delay)} {
	after $OPT(gc-delay) ::tkcon::GarbageCollect
    }
}

<strong><a name="::tkcon::InitTab_684">proc <a href="tkcon.tcl-annot.html#::tkcon::InitTab">::tkcon::InitTab</a></a></strong><a name="::tkcon::InitTab"></a> {w} {
    variable OPT
    variable PRIV
    variable COLOR
    variable ATTACH

    <font color="#208020"># text console</font>
    set con $w.tab[incr PRIV(uid)]
    text $con -wrap char -foreground $COLOR(stdin) \
	-insertbackground $COLOR(cursor)
    catch {
	if {[<a name="tk(4)"><a href="./tkcon.tcl.html#tk_6296">tk</a></a> windowingsystem] == &#34;aqua&#34;} {
	    $w.text configure -highlightthickness 0
	}
    }
    $con mark set output 1.0
    $con mark set limit 1.0
    if {[string compare {} $COLOR(bg)]} {
	$con configure -background $COLOR(bg)
    }
    set COLOR(bg) [$con cget -background]
    if {[string compare {} $OPT(font)]} {
	<font color="#208020">## Set user-requested font, if any</font>
	$con configure -font $OPT(font)
    } elseif {[string compare unix $::tcl_platform(platform)]} {
	<font color="#208020">## otherwise make sure the font is monospace</font>
	set font [$con cget -font]
	if {![font metrics $font -fixed]} {
	    $con configure -font tkconfixed
	}
    } else {
	$con configure -font tkconfixed
    }
    set OPT(font) [$con cget -font]
    bindtags $con [list $con TkConsole TkConsolePost $PRIV(root) all]

    <font color="#208020"># scrollbar</font>
    if {!$PRIV(WWW)} {
	if {[string match &#34;Windows CE&#34; $::tcl_platform(os)]} {
	    font configure tkconfixed -family Tahoma -size 8
	    $con configure -font tkconfixed -borderwidth 0 -padx 0 -pady 0
	    set cw [font measure tkconfixed &#34;0&#34;]
	    set ch [font metrics tkconfixed -linespace]
	    set sw [winfo screenwidth $con]
	    set sh [winfo screenheight $con]
	    <font color="#208020"># We need the magic hard offsets until I find a way to</font>
	    <font color="#208020"># correctly assume size</font>
	    if {$cw*($OPT(cols)+2) &gt; $sw} {
		set OPT(cols) [expr {($sw / $cw) - 2}]
	    }
	    if {$ch*($OPT(rows)+3) &gt; $sh} {
		set OPT(rows) [expr {($sh / $ch) - 3}]
	    }
	    <font color="#208020"># Place it so that the titlebar underlaps the CE titlebar</font>
	    wm geometry $PRIV(root) +0+0
	}
    }
    $con configure -height $OPT(rows) -width $OPT(cols)

    foreach col {prompt stdout stderr stdin proc} {
	$con tag configure $col -foreground $COLOR($col)
    }
    $con tag configure var -background $COLOR(var)
    $con tag raise sel
    $con tag configure blink -background $COLOR(blink)
    $con tag configure find -background $COLOR(blink)

    set ATTACH($con) [Attach]
    set rb [radiobutton $PRIV(tabframe).cb[winfo name $con] \
		-textvariable ::tkcon::ATTACH($con) \
		-selectcolor white -relief sunken \
		-indicatoron 0 -padx 0 -pady 0 -borderwidth 1 \
		-variable ::tkcon::PRIV(curtab) -value $con \
		-command [list ::tkcon::GotoTab $con]]
    if {$::tcl_version &gt;= 8.4} {
	$rb configure -offrelief flat -overrelief raised
    }
    grid $rb -row 0 -column [lindex [grid size $PRIV(tabframe)] 0] -sticky ns
    grid $con -row 1 -column 1 -sticky news

    lappend PRIV(tabs) $con
    return $con
}

<strong><a name="::tkcon::GotoTab_768">proc <a href="tkcon.tcl-annot.html#::tkcon::GotoTab">::tkcon::GotoTab</a></a></strong><a name="::tkcon::GotoTab"></a> {con} {
    variable PRIV
    variable ATTACH

    set numtabs [llength $PRIV(tabs)]
    <font color="#208020">#if {$numtabs == 1} { return }</font>

    if {[regexp {^[0-9]+$} $con]} {
	set curtab [lsearch -exact $PRIV(tabs) $PRIV(console)]
	set nexttab [expr {$curtab + $con}]
	if {$nexttab &gt;= $numtabs} {
	    set nexttab 0
	} elseif {$nexttab &lt; 0} {
	    set nexttab &#34;end&#34;
	}
	set con [lindex $PRIV(tabs) $nexttab]
    } elseif {$con == $PRIV(console)} {
	return
    }

    <font color="#208020"># adjust console</font>
    if {[winfo exists $PRIV(console)]} {
	lower $PRIV(console)
	$PRIV(console) configure -yscrollcommand {}
	set ATTACH($PRIV(console)) [Attach]
    }
    set PRIV(console) $con
    $con configure -yscrollcommand [list $PRIV(scrolly) set]
    $PRIV(scrolly) configure -command [list $con yview]

    <font color="#208020"># adjust attach</font>
    eval [linsert $ATTACH($con) 0 Attach]

    set PRIV(curtab) $con

    raise $con

    if {[$con compare 1.0 == end-1c]} {
	Prompt
    }

    <font color="#208020"># set StatusCursor</font>
    set PRIV(StatusCursor) [$con index insert]

    focus -force $con
}

<strong><a name="::tkcon::NewTab_815">proc <a href="tkcon.tcl-annot.html#::tkcon::NewTab">::tkcon::NewTab</a></a></strong><a name="::tkcon::NewTab"></a> {{con {}}} {
    variable PRIV
    variable ATTACH

    set con   [InitTab $PRIV(base)]
    set slave [GetSlave]
    InitSlave $slave
    $slave alias exit ::tkcon::DeleteTab $con $slave
    if {$PRIV(name) != &#34;&#34;} {
	set ATTACH($con) [list [list $PRIV(name) $slave] slave]
    } else {
	set ATTACH($con) [list $slave slave]
    }
    $PRIV(X) configure -state normal
    <a name="MenuConfigure(1)"><a href="./tkcon.tcl.html#MenuConfigure_1408">MenuConfigure</a></a> Console &#34;Delete Tab&#34; -state normal
    GotoTab $con
}

<font color="#208020"># The extra code arg is for the alias of exit to this function</font>
<strong><a name="::tkcon::DeleteTab_834">proc <a href="tkcon.tcl-annot.html#::tkcon::DeleteTab">::tkcon::DeleteTab</a></a></strong><a name="::tkcon::DeleteTab"></a> {{con {}} {slave {}} {code 0}} {
    variable PRIV

    set numtabs [llength $PRIV(tabs)]
    if {$numtabs &lt;= 2} {
	$PRIV(X) configure -state disabled
	<a name="MenuConfigure(2)"><a href="./tkcon.tcl.html#MenuConfigure_1408">MenuConfigure</a></a> Console &#34;Delete Tab&#34; -state disabled
    }
    if {$numtabs == 1} {
	<font color="#208020"># in the master, it should do the right thing</font>
	<font color="#208020"># currently the first master still exists - need rearch to fix</font>
	exit
	<font color="#208020"># we might end up here, depending on how exit is rerouted</font>
	return
    }

    if {$con == &#34;&#34;} {
	set con $PRIV(console)
    }
    catch {unset ATTACH($con)}
    set curtab  [lsearch -exact $PRIV(tabs) $con]
    set PRIV(tabs) [lreplace $PRIV(tabs) $curtab $curtab]

    set numtabs [llength $PRIV(tabs)]
    set nexttab $curtab
    if {$nexttab &gt;= $numtabs} {
	set nexttab end
    }
    set nexttab [lindex $PRIV(tabs) $nexttab]

    GotoTab $nexttab

    if {$slave != &#34;&#34; &amp;&amp; $slave != $::tkcon::OPT(exec)} {
	interp delete $slave
    }
    destroy $PRIV(tabframe).cb[winfo name $con]
    destroy $con
}

<font color="#208020">## ::tkcon::GarbageCollect - do various cleanup ops periodically to our setup</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::GarbageCollect_875">proc <a href="tkcon.tcl-annot.html#::tkcon::GarbageCollect">::tkcon::GarbageCollect</a></a></strong><a name="::tkcon::GarbageCollect"></a> {} {
    variable OPT
    variable PRIV

    foreach w $PRIV(tabs) {
	if {[winfo exists $w]} {
	    <font color="#208020">## Remove error tags that no longer span anything</font>
	    <font color="#208020">## Make sure the tag pattern matches the unique tag prefix</font>
	    foreach tag [$w tag names] {
		if {[string match _tag* $tag]
		    &amp;&amp; ![llength [$w tag ranges $tag]]} {
		    $w tag delete $tag
		}
	    }
	}
    }
    if {$OPT(gc-delay)} {
	after $OPT(gc-delay) ::tkcon::GarbageCollect
    }
}

<font color="#208020">## ::tkcon::Eval - evaluates commands input into console window</font>
<font color="#208020">## This is the first stage of the evaluating commands in the console.</font>
<font color="#208020">## They need to be broken up into consituent commands (by ::tkcon::CmdSep) in</font>
<font color="#208020">## case a multiple commands were pasted in, then each is eval'ed (by</font>
<font color="#208020">## ::tkcon::EvalCmd) in turn.  Any uncompleted command will not be eval'ed.</font>
<font color="#208020"># ARGS:	w	- console text widget</font>
<font color="#208020"># Calls:	::tkcon::CmdGet, ::tkcon::CmdSep, ::tkcon::EvalCmd</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::Eval_904">proc <a href="tkcon.tcl-annot.html#::tkcon::Eval">::tkcon::Eval</a></a></strong><a name="::tkcon::Eval"></a> {w} {
    set incomplete [CmdSep [CmdGet $w] cmds last]
    $w mark set insert end-1c
    $w insert end \n
    if {[llength $cmds]} {
	foreach c $cmds {EvalCmd $w $c}
	$w insert insert $last {}
    } elseif {!$incomplete} {
	EvalCmd $w $last
    }
    if {[winfo exists $w]} {
	$w see insert
    }
}

<font color="#208020">## ::tkcon::EvalCmd - evaluates a single command, adding it to history</font>
<font color="#208020"># ARGS:	w	- console text widget</font>
<font color="#208020"># 	cmd	- the command to evaluate</font>
<font color="#208020"># Calls:	::tkcon::Prompt</font>
<font color="#208020"># Outputs:	result of command to stdout (or stderr if error occured)</font>
<font color="#208020"># Returns:	next event number</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::EvalCmd_926">proc <a href="tkcon.tcl-annot.html#::tkcon::EvalCmd">::tkcon::EvalCmd</a></a></strong><a name="::tkcon::EvalCmd"></a> {w cmd} {
    variable OPT
    variable PRIV

    $w mark set output end
    if {[string compare {} $cmd]} {
	set code 0
	if {$OPT(subhistory)} {
	    set ev [EvalSlave history nextid]
	    incr ev -1
	    <font color="#208020">## FIX: calcmode doesn't work with requesting history events</font>
	    if {[string match !! $cmd]} {
		set code [catch {EvalSlave history event $ev} cmd]
		if {!$code} {$w insert output $cmd\n stdin}
	    } elseif {[regexp {^!(.+)$} $cmd dummy event]} {
		<font color="#208020">## Check last event because history event is broken</font>
		set code [catch {EvalSlave history event $ev} cmd]
		if {!$code &amp;&amp; ![string match ${event}* $cmd]} {
		    set code [catch {EvalSlave history event $event} cmd]
		}
		if {!$code} {$w insert output $cmd\n stdin}
	    } elseif {[regexp {^\^([^^]*)\^([^^]*)\^?$} $cmd dummy old new]} {
		set code [catch {EvalSlave history event $ev} cmd]
		if {!$code} {
		    regsub -all -- $old $cmd $new cmd
		    $w insert output $cmd\n stdin
		}
	    } elseif {$OPT(calcmode) &amp;&amp; ![catch {expr $cmd} err]} {
		AddSlaveHistory $cmd
		set cmd $err
		set code -1
	    }
	}
	if {$code} {
	    $w insert output $cmd\n stderr
	} else {
	    <font color="#208020">## We are about to evaluate the command, so move the limit</font>
	    <font color="#208020">## mark to ensure that further &lt;Return&gt;s don't cause double</font>
	    <font color="#208020">## evaluation of this command - for cases like the command</font>
	    <font color="#208020">## has a vwait or something in it</font>
	    $w mark set limit end
	    if {$OPT(nontcl) &amp;&amp; [string match interp $PRIV(apptype)]} {
		set code [catch {EvalSend $cmd} res]
		if {$code == 1} {
		    set PRIV(errorInfo) &#34;Non-Tcl errorInfo not available&#34;
		}
	    } elseif {[string match socket $PRIV(apptype)]} {
		set code [catch {EvalSocket $cmd} res]
		if {$code == 1} {
		    set PRIV(errorInfo) &#34;Socket-based errorInfo not available&#34;
		}
	    } else {
		set code [catch {EvalAttached $cmd} res]
		if {$code == 1} {
		    if {[catch {EvalAttached [list set errorInfo]} err]} {
			set PRIV(errorInfo) &#34;Error getting errorInfo:\n$err&#34;
		    } else {
			set PRIV(errorInfo) $err
		    }
		}
	    }
	    if {![winfo exists $w]} {
		<font color="#208020"># early abort - must be a deleted tab</font>
		return
	    }
	    AddSlaveHistory $cmd
	    catch {EvalAttached [list set _ $res]}
	    set maxlen $OPT(maxlinelen)
	    set trailer &#34;&#34;
	    if {($maxlen &gt; 0) &amp;&amp; ([string length $res] &gt; $maxlen)} {
		<font color="#208020"># If we exceed maximum desired output line length, truncate</font>
		<font color="#208020"># the result and add &#34;...+${num}b&#34; in error coloring</font>
		set trailer ...+[expr {[string length $res]-$maxlen}]b
		set res [string range $res 0 $maxlen]
	    }
	    if {$code} {
		if {$OPT(hoterrors)} {
		    set tag [UniqueTag $w]
		    $w insert output $res [list stderr $tag] \n$trailer stderr
		    $w tag bind $tag &lt;Enter&gt; \
			    [list $w tag configure $tag -under 1]
		    $w tag bind $tag &lt;Leave&gt; \
			    [list $w tag configure $tag -under 0]
		    $w tag bind $tag &lt;ButtonRelease-1&gt; \
			    &#34;if {!\[info exists tkPriv(mouseMoved)\] || !\$tkPriv(mouseMoved)} \
			    {[list $OPT(edit) -attach [Attach] -type error -- $PRIV(errorInfo)]}&#34;
		} else {
		    $w insert output $res\n$trailer stderr
		}
	    } elseif {[string compare {} $res]} {
		$w insert output $res stdout $trailer stderr \n stdout
	    }
	}
    }
    Prompt
    set PRIV(event) [EvalSlave history nextid]
}

<font color="#208020">## ::tkcon::EvalSlave - evaluates the args in the associated slave</font>
<font color="#208020">## args should be passed to this procedure like they would be at</font>
<font color="#208020">## the command line (not like to 'eval').</font>
<font color="#208020"># ARGS:	args	- the command and args to evaluate</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::EvalSlave_1029">proc <a href="tkcon.tcl-annot.html#::tkcon::EvalSlave">::tkcon::EvalSlave</a></a></strong><a name="::tkcon::EvalSlave"></a> args {
    interp eval $::tkcon::OPT(exec) $args
}

<font color="#208020">## ::tkcon::EvalOther - evaluate a command in a foreign interp or slave</font>
<font color="#208020">## without attaching to it.  No check for existence is made.</font>
<font color="#208020"># ARGS:	app	- interp/slave name</font>
<font color="#208020">#	type	- (slave|interp)</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::EvalOther_1038">proc <a href="tkcon.tcl-annot.html#::tkcon::EvalOther">::tkcon::EvalOther</a></a></strong><a name="::tkcon::EvalOther"></a> { app type args } {
    if {[string compare slave $type]==0} {
	return [Slave $app $args]
    } else {
	return [uplevel 1 ::send::send [list $app] $args]
    }
}

<font color="#208020">## ::tkcon::AddSlaveHistory - </font>
<font color="#208020">## Command is added to history only if different from previous command.</font>
<font color="#208020">## This also doesn't cause the history id to be incremented, although the</font>
<font color="#208020">## command will be evaluated.</font>
<font color="#208020"># ARGS: cmd	- command to add</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::AddSlaveHistory_1052">proc <a href="tkcon.tcl-annot.html#::tkcon::AddSlaveHistory">::tkcon::AddSlaveHistory</a></a></strong><a name="::tkcon::AddSlaveHistory"></a> cmd {
    set ev [EvalSlave history nextid]
    incr ev -1
    set code [catch {EvalSlave history event $ev} lastCmd]
    if {$code || [string compare $cmd $lastCmd]} {
	EvalSlave history add $cmd
    }
}

<font color="#208020">## ::tkcon::EvalSend - sends the args to the attached interpreter</font>
<font color="#208020">## Varies from 'send' by determining whether attachment is dead</font>
<font color="#208020">## when an error is received</font>
<font color="#208020"># ARGS:	cmd	- the command string to send across</font>
<font color="#208020"># Returns:	the result of the command</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::EvalSend_1067">proc <a href="tkcon.tcl-annot.html#::tkcon::EvalSend">::tkcon::EvalSend</a></a></strong><a name="::tkcon::EvalSend"></a> cmd {
    variable OPT
    variable PRIV

    if {$PRIV(deadapp)} {
	if {[lsearch -exact [<a name="::send::interps(1)"><a href="./tkcon.tcl.html#::send::interps_6231">::send::interps</a></a>] $PRIV(app)]&lt;0} {
	    return
	} else {
	    set PRIV(appname) [string range $PRIV(appname) 5 end]
	    set PRIV(deadapp) 0
	    Prompt &#34;\n\&#34;$PRIV(app)\&#34; alive\n&#34; [CmdGet $PRIV(console)]
	}
    }
    set code [catch {<a name="::send::send(2)"><a href="./tkcon.tcl.html#::send::send_6186">::send::send</a></a> -displayof $PRIV(displayWin) $PRIV(app) $cmd} result]
    if {$code &amp;&amp; [lsearch -exact [<a name="::send::interps(2)"><a href="./tkcon.tcl.html#::send::interps_6231">::send::interps</a></a>] $PRIV(app)]&lt;0} {
	<font color="#208020">## Interpreter disappeared</font>
	if {[string compare leave $OPT(dead)] &amp;&amp; \
		([string match ignore $OPT(dead)] || \
		     [tk_messageBox -title &#34;Dead Attachment&#34; -type yesno \
			  -icon info -message \
			  &#34;\&#34;$PRIV(app)\&#34; appears to have died.\
		\nReturn to primary slave interpreter?&#34;]==&#34;no&#34;)} {
	    set PRIV(appname) &#34;DEAD:$PRIV(appname)&#34;
	    set PRIV(deadapp) 1
	} else {
	    set err &#34;Attached Tk interpreter \&#34;$PRIV(app)\&#34; died.&#34;
	    Attach {}
	    set PRIV(deadapp) 0
	    EvalSlave set errorInfo $err
	}
	Prompt \n [CmdGet $PRIV(console)]
    }
    return -code $code $result
}

<font color="#208020">## ::tkcon::EvalSocket - sends the string to an interpreter attached via</font>
<font color="#208020">## a tcp/ip socket</font>
<font color="#208020">##</font>
<font color="#208020">## In the EvalSocket case, ::tkcon::PRIV(app) is the socket id</font>
<font color="#208020">##</font>
<font color="#208020">## Must determine whether socket is dead when an error is received</font>
<font color="#208020"># ARGS:	cmd	- the data string to send across</font>
<font color="#208020"># Returns:	the result of the command</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::EvalSocket_1111">proc <a href="tkcon.tcl-annot.html#::tkcon::EvalSocket">::tkcon::EvalSocket</a></a></strong><a name="::tkcon::EvalSocket"></a> cmd {
    variable OPT
    variable PRIV
    global tcl_version

    if {$PRIV(deadapp)} {
	if {![info exists PRIV(app)] || \
		[catch {eof $PRIV(app)} eof] || $eof} {
	    return
	} else {
	    set PRIV(appname) [string range $PRIV(appname) 5 end]
	    set PRIV(deadapp) 0
	    Prompt &#34;\n\&#34;$PRIV(app)\&#34; alive\n&#34; [CmdGet $PRIV(console)]
	}
    }
    <font color="#208020"># Sockets get \'s interpreted, so that users can</font>
    <font color="#208020"># send things like \n\r or explicit hex values</font>
    set cmd [subst -novariables -nocommands $cmd]
    <font color="#208020">#puts [list $PRIV(app) $cmd]</font>
    set code [catch {puts $PRIV(app) $cmd ; flush $PRIV(app)} result]
    if {$code &amp;&amp; [eof $PRIV(app)]} {
	<font color="#208020">## Interpreter died or disappeared</font>
	puts &#34;$code eof [eof $PRIV(app)]&#34;
	EvalSocketClosed $PRIV(app)
    }
    return -code $code $result
}

<font color="#208020">## ::tkcon::EvalSocketEvent - fileevent command for an interpreter attached</font>
<font color="#208020">## via a tcp/ip socket</font>
<font color="#208020">## Must determine whether socket is dead when an error is received</font>
<font color="#208020"># ARGS:	args	- the args to send across</font>
<font color="#208020"># Returns:	the result of the command</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::EvalSocketEvent_1145">proc <a href="tkcon.tcl-annot.html#::tkcon::EvalSocketEvent">::tkcon::EvalSocketEvent</a></a></strong><a name="::tkcon::EvalSocketEvent"></a> {sock} {
    variable PRIV

    if {[gets $sock line] == -1} {
	if {[eof $sock]} {
	    EvalSocketClosed $sock
	}
	return
    }
    puts $line
}

<font color="#208020">## ::tkcon::EvalSocketClosed - takes care of handling a closed eval socket</font>
<font color="#208020">##</font>
<font color="#208020"># ARGS:	args	- the args to send across</font>
<font color="#208020"># Returns:	the result of the command</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::EvalSocketClosed_1162">proc <a href="tkcon.tcl-annot.html#::tkcon::EvalSocketClosed">::tkcon::EvalSocketClosed</a></a></strong><a name="::tkcon::EvalSocketClosed"></a> {sock} {
    variable OPT
    variable PRIV

    catch {close $sock}
    if {![string match $sock $PRIV(app)]} {
	<font color="#208020"># If we are not still attached to that socket, just return.</font>
	<font color="#208020"># Might be nice to tell the user the socket closed ...</font>
	return
    }
    if {[string compare leave $OPT(dead)] &amp;&amp; \
	    ([string match ignore $OPT(dead)] || \
		 [tk_messageBox -title &#34;Dead Attachment&#34; -type yesno \
		      -icon question \
		      -message &#34;\&#34;$PRIV(app)\&#34; appears to have died.\
	    \nReturn to primary slave interpreter?&#34;] == &#34;no&#34;)} {
	set PRIV(appname) &#34;DEAD:$PRIV(appname)&#34;
	set PRIV(deadapp) 1
    } else {
	set err &#34;Attached Tk interpreter \&#34;$PRIV(app)\&#34; died.&#34;
	Attach {}
	set PRIV(deadapp) 0
	EvalSlave set errorInfo $err
    }
    Prompt \n [CmdGet $PRIV(console)]
}

<font color="#208020">## ::tkcon::EvalNamespace - evaluates the args in a particular namespace</font>
<font color="#208020">## This is an override for ::tkcon::EvalAttached for when the user wants</font>
<font color="#208020">## to attach to a particular namespace of the attached interp</font>
<font color="#208020"># ARGS:	attached	</font>
<font color="#208020">#	namespace	the namespace to evaluate in</font>
<font color="#208020">#	args		the args to evaluate</font>
<font color="#208020"># RETURNS:	the result of the command</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::EvalNamespace_1197">proc <a href="tkcon.tcl-annot.html#::tkcon::EvalNamespace">::tkcon::EvalNamespace</a></a></strong><a name="::tkcon::EvalNamespace"></a> { attached namespace args } {
    if {[llength $args]} {
	uplevel \#0 $attached \
		[list [concat [list namespace eval $namespace] $args]]
    }
}


<font color="#208020">## ::tkcon::Namespaces - return all the namespaces descendent from $ns</font>
<font color="#208020">##</font>
<font color="#208020">#</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::Namespaces_1209">proc <a href="tkcon.tcl-annot.html#::tkcon::Namespaces">::tkcon::Namespaces</a></a></strong><a name="::tkcon::Namespaces"></a> {{ns ::} {l {}}} {
    if {[string compare {} $ns]} { lappend l $ns }
    foreach i [EvalAttached [list namespace children $ns]] {
	set l [Namespaces $i $l]
    }
    return $l
}

<font color="#208020">## ::tkcon::CmdGet - gets the current command from the console widget</font>
<font color="#208020"># ARGS:	w	- console text widget</font>
<font color="#208020"># Returns:	text which compromises current command line</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::CmdGet_1221">proc <a href="tkcon.tcl-annot.html#::tkcon::CmdGet">::tkcon::CmdGet</a></a></strong><a name="::tkcon::CmdGet"></a> w {
    if {![llength [$w tag nextrange prompt limit end]]} {
	$w tag add stdin limit end-1c
	return [$w get limit end-1c]
    }
}

<font color="#208020">## ::tkcon::CmdSep - separates multiple commands into a list and remainder</font>
<font color="#208020"># ARGS:	cmd	- (possible) multiple command to separate</font>
<font color="#208020"># 	list	- varname for the list of commands that were separated.</font>
<font color="#208020">#	last	- varname of any remainder (like an incomplete final command).</font>
<font color="#208020">#		If there is only one command, it's placed in this var.</font>
<font color="#208020"># Returns:	constituent command info in varnames specified by list &amp; rmd.</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::CmdSep_1235">proc <a href="tkcon.tcl-annot.html#::tkcon::CmdSep">::tkcon::CmdSep</a></a></strong><a name="::tkcon::CmdSep"></a> {cmd list last} {
    upvar 1 $list cmds $last inc
    set inc {}
    set cmds {}
    foreach c [split [string trimleft $cmd] \n] {
	if {[string compare $inc {}]} {
	    append inc \n$c
	} else {
	    append inc [string trimleft $c]
	}
	if {[info complete $inc] &amp;&amp; ![regexp {[^\\]\\$} $inc]} {
	    if {[regexp &#34;^\[^#\]&#34; $inc]} {lappend cmds $inc}
	    set inc {}
	}
    }
    set i [string compare $inc {}]
    if {!$i &amp;&amp; [string compare $cmds {}] &amp;&amp; ![string match *\n $cmd]} {
	set inc [lindex $cmds end]
	set cmds [lreplace $cmds end end]
    }
    return $i
}

<font color="#208020">## ::tkcon::CmdSplit - splits multiple commands into a list</font>
<font color="#208020"># ARGS:	cmd	- (possible) multiple command to separate</font>
<font color="#208020"># Returns:	constituent commands in a list</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::CmdSplit_1262">proc <a href="tkcon.tcl-annot.html#::tkcon::CmdSplit">::tkcon::CmdSplit</a></a></strong><a name="::tkcon::CmdSplit"></a> {cmd} {
    set inc {}
    set cmds {}
    foreach cmd [split [string trimleft $cmd] \n] {
	if {[string compare {} $inc]} {
	    append inc \n$cmd
	} else {
	    append inc [string trimleft $cmd]
	}
	if {[info complete $inc] &amp;&amp; ![regexp {[^\\]\\$} $inc]} {
	    <font color="#208020">#set inc [string trimright $inc]</font>
	    if {[regexp &#34;^\[^#\]&#34; $inc]} {lappend cmds $inc}
	    set inc {}
	}
    }
    if {[regexp &#34;^\[^#\]&#34; $inc]} {lappend cmds $inc}
    return $cmds
}

<font color="#208020">## ::tkcon::UniqueTag - creates a uniquely named tag, reusing names</font>
<font color="#208020">## Called by ::tkcon::EvalCmd</font>
<font color="#208020"># ARGS:	w	- text widget</font>
<font color="#208020"># Outputs:	tag name guaranteed unique in the widget</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::UniqueTag_1286">proc <a href="tkcon.tcl-annot.html#::tkcon::UniqueTag">::tkcon::UniqueTag</a></a></strong><a name="::tkcon::UniqueTag"></a> {w} {
    set tags [$w tag names]
    set idx 0
    while {[lsearch -exact $tags _tag[incr idx]] != -1} {}
    return _tag$idx
}

<font color="#208020">## ::tkcon::ConstrainBuffer - This limits the amount of data in the text widget</font>
<font color="#208020">## Called by ::tkcon::Prompt and in tkcon proc buffer/console switch cases</font>
<font color="#208020"># ARGS:	w	- console text widget</font>
<font color="#208020">#	size	- # of lines to constrain to</font>
<font color="#208020"># Outputs:	may delete data in console widget</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::ConstrainBuffer_1299">proc <a href="tkcon.tcl-annot.html#::tkcon::ConstrainBuffer">::tkcon::ConstrainBuffer</a></a></strong><a name="::tkcon::ConstrainBuffer"></a> {w size} {
    if {$size &amp;&amp; ([$w index end] &gt; $size)} {
	$w delete 1.0 [expr {int([$w index end])-$size}].0
    }
}

<font color="#208020">## ::tkcon::Prompt - displays the prompt in the console widget</font>
<font color="#208020"># ARGS:	w	- console text widget</font>
<font color="#208020"># Outputs:	prompt (specified in ::tkcon::OPT(prompt1)) to console</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::Prompt_1309">proc <a href="tkcon.tcl-annot.html#::tkcon::Prompt">::tkcon::Prompt</a></a></strong><a name="::tkcon::Prompt"></a> {{pre {}} {post {}} {prompt {}}} {
    variable OPT
    variable PRIV

    set w $PRIV(console)
    if {![winfo exists $w]} { return }
    if {[string compare {} $pre]} { $w insert end $pre stdout }
    set i [$w index end-1c]
    if {!$OPT(showstatusbar)} {
	if {[string compare {} $PRIV(appname)]} {
	    $w insert end &#34;&gt;$PRIV(appname)&lt; &#34; prompt
	}
	if {[string compare :: $PRIV(namesp)]} {
	    $w insert end &#34;&lt;$PRIV(namesp)&gt; &#34; prompt
	}
    }
    if {[string compare {} $prompt]} {
	$w insert end $prompt prompt
    } else {
	$w insert end [EvalSlave subst $OPT(prompt1)] prompt
    }
    $w mark set output $i
    $w mark set insert end
    $w mark set limit insert
    $w mark gravity limit left
    if {[string compare {} $post]} { $w insert end $post stdin }
    ConstrainBuffer $w $OPT(buffer)
    set ::tkcon::PRIV(StatusCursor) [$w index insert]
    $w see end
}
<strong><a name="::tkcon::RePrompt_1339">proc <a href="tkcon.tcl-annot.html#::tkcon::RePrompt">::tkcon::RePrompt</a></a></strong><a name="::tkcon::RePrompt"></a> {{pre {}} {post {}} {prompt {}}} {
    <font color="#208020"># same as prompt, but does nothing for those actions where we</font>
    <font color="#208020"># only wanted to refresh the prompt on attach change when the</font>
    <font color="#208020"># statusbar is showing (which carries that info instead)</font>
    variable OPT
    if {!$OPT(showstatusbar)} {
	Prompt $pre $post $prompt
    }
}

<font color="#208020">## ::tkcon::About - gives about info for tkcon</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::About_1351">proc <a href="tkcon.tcl-annot.html#::tkcon::About">::tkcon::About</a></a></strong><a name="::tkcon::About"></a> {} {
    variable OPT
    variable PRIV
    variable COLOR

    set w $PRIV(base).about
    if {![winfo exists $w]} {
	global tk_patchLevel tcl_patchLevel tcl_version
	<a name="toplevel(2)"><a href="./tkcon.tcl.html#toplevel_5837">toplevel</a></a> $w
	wm withdraw $w
	wm transient $w $PRIV(root)
	wm group $w $PRIV(root)
	wm title $w &#34;About tkcon v$PRIV(version)&#34;
	button $w.b -text Dismiss -command [list wm withdraw $w]
	text $w.text -height 9 -width 60 \
		-foreground $COLOR(stdin) \
		-background $COLOR(bg) \
		-font $OPT(font)
	pack $w.b -fill x -side bottom
	pack $w.text -fill both -side left -expand 1
	$w.text tag config center -justify center
	$w.text tag config title -justify center -font {Courier -18 bold}
	<font color="#208020"># strip down the RCS info displayed in the about box</font>
	regexp {,v ([0-9\./: ]*)} $PRIV(RCS) -&gt; RCS
	$w.text insert 1.0 &#34;About tkcon v$PRIV(version)&#34; title \
		&#34;\n\nCopyright 1995-2002 Jeffrey Hobbs, $PRIV(email)\
		\nRelease Info: v$PRIV(version), CVS v$RCS\
		\nDocumentation available at:\n$PRIV(docs)\
		\nUsing: Tcl v$tcl_patchLevel / Tk v$tk_patchLevel&#34; center
	$w.text config -state disabled
	bind $w &lt;Escape&gt; [list destroy $w]
    }
    wm deiconify $w
}

<font color="#208020">## ::tkcon::InitMenus - inits the menubar and popup for the console</font>
<font color="#208020"># ARGS:	w	- console text widget</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::InitMenus_1389">proc <a href="tkcon.tcl-annot.html#::tkcon::InitMenus">::tkcon::InitMenus</a></a></strong><a name="::tkcon::InitMenus"></a> {w title} {
    variable OPT
    variable PRIV
    variable COLOR
    global tcl_platform

    if {[catch {menu $w.pop}]} {
	label $w.label -text &#34;Menus not available in plugin mode&#34;
	grid $w.label -sticky ew
	return
    }
    menu $w.context -disabledforeground $COLOR(disabled)
    set PRIV(context) $w.context
    set PRIV(popup) $w.pop

    <strong><a name="MenuButton_1404">proc <a href="tkcon.tcl-annot.html#MenuButton">MenuButton</a></a></strong><a name="MenuButton"></a> {w m l} {
	$w add cascade -label $m -underline 0 -menu $w.$l
	return $w.$l
    }
    <strong><a name="MenuConfigure_1408">proc <a href="tkcon.tcl-annot.html#MenuConfigure">MenuConfigure</a></a></strong><a name="MenuConfigure"></a> {m l args} {
	variable PRIV
	eval [list $PRIV(menubar).[string tolower $m] entryconfigure $l] $args
	eval [list $PRIV(popup).[string tolower $m] entryconfigure $l] $args
    }

    foreach m [list File Console Edit Interp Prefs History Help] {
 	set l [string tolower $m]
 	<a name="MenuButton(1)"><a href="./tkcon.tcl.html#MenuButton_1404">MenuButton</a></a> $w $m $l
 	$w.pop add cascade -label $m -underline 0 -menu $w.pop.$l
    }

    <font color="#208020">## File Menu</font>
    <font color="#208020">##</font>
    foreach m [list [menu $w.file -disabledforeground $COLOR(disabled)] \
	    [menu $w.pop.file -disabledforeground $COLOR(disabled)]] {
	$m add command -label &#34;Load File&#34; -underline 0 -command ::tkcon::Load
	$m add cascade -label &#34;Save ...&#34;  -underline 0 -menu $m.save
	$m add separator
	$m add command -label &#34;Quit&#34; -underline 0 -accel Ctrl-q -command exit

	<font color="#208020">## Save Menu</font>
	<font color="#208020">##</font>
	set s $m.save
	menu $s -disabledforeground $COLOR(disabled)
	$s add command -label &#34;All&#34;	-underline 0 \
		-command {<a name="::tkcon::Save(1)"><a href="./tkcon.tcl.html#::tkcon::Save_2340">::tkcon::Save</a></a> {} all}
	$s add command -label &#34;History&#34;	-underline 0 \
		-command {<a name="::tkcon::Save(2)"><a href="./tkcon.tcl.html#::tkcon::Save_2340">::tkcon::Save</a></a> {} history}
	$s add command -label &#34;Stdin&#34;	-underline 3 \
		-command {<a name="::tkcon::Save(3)"><a href="./tkcon.tcl.html#::tkcon::Save_2340">::tkcon::Save</a></a> {} stdin}
	$s add command -label &#34;Stdout&#34;	-underline 3 \
		-command {<a name="::tkcon::Save(4)"><a href="./tkcon.tcl.html#::tkcon::Save_2340">::tkcon::Save</a></a> {} stdout}
	$s add command -label &#34;Stderr&#34;	-underline 3 \
		-command {<a name="::tkcon::Save(5)"><a href="./tkcon.tcl.html#::tkcon::Save_2340">::tkcon::Save</a></a> {} stderr}
    }

    <font color="#208020">## Console Menu</font>
    <font color="#208020">##</font>
    foreach m [list [menu $w.console -disabledfore $COLOR(disabled)] \
	    [menu $w.pop.console -disabledfore $COLOR(disabled)]] {
	$m add command -label &#34;$title Console&#34;	-state disabled
	$m add command -label &#34;New Console&#34;	-underline 0 -accel Ctrl-N \
		-command ::tkcon::New
	$m add command -label &#34;New Tab&#34;		-underline 4 -accel Ctrl-T \
		-command ::tkcon::NewTab
	$m add command -label &#34;Delete Tab&#34;	-underline 0 \
		-command ::tkcon::DeleteTab -state disabled
	$m add command -label &#34;Close Console&#34;	-underline 0 -accel Ctrl-w \
		-command ::tkcon::Destroy
	$m add command -label &#34;Clear Console&#34;	-underline 1 -accel Ctrl-l \
		-command { <a name="clear(1)"><a href="./tkcon.tcl.html#clear_3900">clear</a></a>; <a name="::tkcon::Prompt(1)"><a href="./tkcon.tcl.html#::tkcon::Prompt_1309">::tkcon::Prompt</a></a> }
	if {[string match unix $tcl_platform(platform)]} {
	    $m add separator
	    $m add command -label &#34;Make Xauth Secure&#34; -und 5 \
		    -command ::tkcon::XauthSecure
	}
	$m add separator
	$m add cascade -label &#34;Attach To ...&#34; -underline 0 -menu $m.attach

	<font color="#208020">## Attach Console Menu</font>
	<font color="#208020">##</font>
	set sub [menu $m.attach -disabledforeground $COLOR(disabled)]
	$sub add cascade -label &#34;Interpreter&#34; -underline 0 -menu $sub.apps
	$sub add cascade -label &#34;Namespace&#34;   -underline 0 -menu $sub.name

	<font color="#208020">## Attach Console Menu</font>
	<font color="#208020">##</font>
	menu $sub.apps -disabledforeground $COLOR(disabled) \
		-postcommand [list ::tkcon::AttachMenu $sub.apps]

	<font color="#208020">## Attach Namespace Menu</font>
	<font color="#208020">##</font>
	menu $sub.name -disabledforeground $COLOR(disabled) \
		-postcommand [list ::tkcon::NamespaceMenu $sub.name]

	if {$::tcl_version &gt;= 8.3} {
	    <font color="#208020">## Attach Socket Menu</font>
	    <font color="#208020">##</font>
	    <font color="#208020"># This uses [file channels] to create the menu, so we only</font>
	    <font color="#208020"># want it for newer versions of Tcl.</font>
	    $sub add cascade -label &#34;Socket&#34; -underline 0 -menu $sub.sock
	    menu $sub.sock -disabledforeground $COLOR(disabled) \
		    -postcommand [list ::tkcon::SocketMenu $sub.sock]
	}

	if {![string compare &#34;unix&#34; $tcl_platform(platform)]} {
	    <font color="#208020">## Attach Display Menu</font>
	    <font color="#208020">##</font>
	    $sub add cascade -label &#34;Display&#34; -underline 0 -menu $sub.disp
	    menu $sub.disp -disabledforeground $COLOR(disabled) \
		    -postcommand [list ::tkcon::DisplayMenu $sub.disp]
	}
    }

    <font color="#208020">## Edit Menu</font>
    <font color="#208020">##</font>
    set text $PRIV(console)
    foreach m [list [menu $w.edit] [menu $w.pop.edit]] {
	$m add command -label &#34;Cut&#34;   -underline 2 -accel Ctrl-x \
		-command [list ::tkcon::Cut $text]
	$m add command -label &#34;Copy&#34;  -underline 0 -accel Ctrl-c \
		-command [list ::tkcon::Copy $text]
	$m add command -label &#34;Paste&#34; -underline 0 -accel Ctrl-v \
		 -command [list ::tkcon::Paste $text]
	$m add separator
	$m add command -label &#34;Find&#34;  -underline 0 -accel Ctrl-F \
		-command [list ::tkcon::FindBox $text]
    }

    <font color="#208020">## Interp Menu</font>
    <font color="#208020">##</font>
    foreach m [list $w.interp $w.pop.interp] {
	menu $m -disabledforeground $COLOR(disabled) \
		-postcommand [list ::tkcon::InterpMenu $m]
    }

    <font color="#208020">## Prefs Menu</font>
    <font color="#208020">##</font>
    foreach m [list [menu $w.prefs] [menu $w.pop.prefs]] {
	$m add check -label &#34;Brace Highlighting&#34; \
		-underline 0 -variable ::tkcon::OPT(lightbrace)
	$m add check -label &#34;Command Highlighting&#34; \
		-underline 0 -variable ::tkcon::OPT(lightcmd)
	$m add check -label &#34;History Substitution&#34; \
		-underline 0 -variable ::tkcon::OPT(subhistory)
	$m add check -label &#34;Hot Errors&#34; \
		-underline 4 -variable ::tkcon::OPT(hoterrors)
	$m add check -label &#34;Non-Tcl Attachments&#34; \
		-underline 0 -variable ::tkcon::OPT(nontcl)
	$m add check -label &#34;Calculator Mode&#34; \
		-underline 1 -variable ::tkcon::OPT(calcmode)
	$m add check -label &#34;Show Multiple Matches&#34; \
		-underline 0 -variable ::tkcon::OPT(showmultiple)
	$m add check -label &#34;Show Menubar&#34; \
		-underline 5 -variable ::tkcon::OPT(showmenu) \
		-command {$::tkcon::PRIV(root) configure -menu [expr \
		{$::tkcon::OPT(showmenu) ? $::tkcon::PRIV(menubar) : {}}]}
	$m add check -label &#34;Show Statusbar&#34; \
	    -underline 5 -variable ::tkcon::OPT(showstatusbar) \
	    -command {
		if {$::tkcon::OPT(showstatusbar)} {
		    grid $::tkcon::PRIV(statusbar)
		} else { grid remove $::tkcon::PRIV(statusbar) }
	    }
	$m add cascade -label &#34;Scrollbar&#34; -underline 2 -menu $m.scroll

	<font color="#208020">## Scrollbar Menu</font>
	<font color="#208020">##</font>
	set m [menu $m.scroll]
	$m add radio -label &#34;Left&#34; -value left \
		-variable ::tkcon::OPT(scrollypos) \
		-command { grid configure $::tkcon::PRIV(scrolly) -column 0 }
	$m add radio -label &#34;Right&#34; -value right \
		-variable ::tkcon::OPT(scrollypos) \
		-command { grid configure $::tkcon::PRIV(scrolly) -column 2 }
    }

    <font color="#208020">## History Menu</font>
    <font color="#208020">##</font>
    foreach m [list $w.history $w.pop.history] {
	menu $m -disabledforeground $COLOR(disabled) \
		-postcommand [list ::tkcon::HistoryMenu $m]
    }

    <font color="#208020">## Help Menu</font>
    <font color="#208020">##</font>
    foreach m [list [menu $w.help] [menu $w.pop.help]] {
	$m add command -label &#34;About &#34; -underline 0 -accel Ctrl-A \
		-command ::tkcon::About
	$m add command -label &#34;Retrieve Latest Version&#34; -underline 0 \
		-command ::tkcon::Retrieve
	if {![catch {package require ActiveTcl} ver]} {
	    set cmd &#34;&#34;
	    if {$tcl_platform(platform) == &#34;windows&#34;} {
		package require registry
		set ver [join [lrange [split $ver .] 0 3] .]
		set key {HKEY_LOCAL_MACHINE\SOFTWARE\ActiveState\ActiveTcl}
		if {![catch {registry get &#34;$key\\$ver\\Help&#34; &#34;&#34;} help]
		    &amp;&amp; [file exists $help]} {
		    set cmd [list exec $::env(COMSPEC) /c start {} $help]
		}
	    } elseif {$tcl_platform(os) == &#34;Darwin&#34;} {
		set ver ActiveTcl-[join [lrange [split $ver .] 0 1] .]
		set rsc &#34;/Library/Frameworks/Tcl.framework/Resources&#34;
		set help &#34;$rsc/English.lproj/$ver/index.html&#34;
		if {[file exists $help]} {
		    set cmd [list exec open $help]
		}
	    } elseif {$tcl_platform(platform) == &#34;unix&#34;} {
		set help [file dirname [info nameofexe]]
		append help /../html/index.html
		if {[file exists $help]} {
		    set cmd [list puts &#34;Start $help&#34;]
		}
	    }
	    if {$cmd != &#34;&#34;} {
		$m add separator
		$m add command -label &#34;ActiveTcl Help&#34; -underline 10 \
		    -command $cmd
	    }
	}
    }
}

<font color="#208020">## ::tkcon::HistoryMenu - dynamically build the menu for attached interpreters</font>
<font color="#208020">##</font>
<font color="#208020"># ARGS:	m	- menu widget</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::HistoryMenu_1617">proc <a href="tkcon.tcl-annot.html#::tkcon::HistoryMenu">::tkcon::HistoryMenu</a></a></strong><a name="::tkcon::HistoryMenu"></a> m {
    variable PRIV

    if {![winfo exists $m]} return
    set id [EvalSlave history nextid]
    if {$PRIV(histid)==$id} return
    set PRIV(histid) $id
    $m delete 0 end
    while {($id&gt;1) &amp;&amp; ($id&gt;$PRIV(histid)-10) &amp;&amp; \
	    ![catch {EvalSlave history event [incr id -1]} tmp]} {
	set lbl $tmp
	if {[string len $lbl]&gt;32} { set lbl [string range $tmp 0 28]... }
	$m add command -label &#34;$id: $lbl&#34; -command &#34;
	$::tkcon::PRIV(console) delete limit end
	$::tkcon::PRIV(console) insert limit [list $tmp]
	$::tkcon::PRIV(console) see end
	::tkcon::Eval $::tkcon::PRIV(console)&#34;
    }
}

<font color="#208020">## ::tkcon::InterpMenu - dynamically build the menu for attached interpreters</font>
<font color="#208020">##</font>
<font color="#208020"># ARGS:	w	- menu widget</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::InterpMenu_1641">proc <a href="tkcon.tcl-annot.html#::tkcon::InterpMenu">::tkcon::InterpMenu</a></a></strong><a name="::tkcon::InterpMenu"></a> w {
    variable OPT
    variable PRIV
    variable COLOR

    if {![winfo exists $w]} return
    $w delete 0 end
    foreach {app type} [Attach] break
    $w add command -label &#34;[string toupper $type]: $app&#34; -state disabled
    if {($OPT(nontcl) &amp;&amp; [string match interp $type]) || $PRIV(deadapp)} {
	$w add separator
	$w add command -state disabled -label &#34;Communication disabled to&#34;
	$w add command -state disabled -label &#34;dead or non-Tcl interps&#34;
	return
    }

    <font color="#208020">## Show Last Error</font>
    <font color="#208020">##</font>
    $w add separator
    $w add command -label &#34;Show Last Error&#34; \
	    -command [list tkcon error $app $type]

    <font color="#208020">## Packages Cascaded Menu</font>
    <font color="#208020">##</font>
    $w add separator
    $w add command -label &#34;Manage Packages&#34; -underline 0 \
	-command [list ::tkcon::InterpPkgs $app $type]

    <font color="#208020">## State Checkpoint/Revert</font>
    <font color="#208020">##</font>
    $w add separator
    $w add command -label &#34;Checkpoint State&#34; \
	    -command [list ::tkcon::StateCheckpoint $app $type]
    $w add command -label &#34;Revert State&#34; \
	    -command [list ::tkcon::StateRevert $app $type]
    $w add command -label &#34;View State Change&#34; \
	    -command [list ::tkcon::StateCompare $app $type]

    <font color="#208020">## Init Interp</font>
    <font color="#208020">##</font>
    $w add separator
    $w add command -label &#34;Send tkcon Commands&#34; \
	    -command [list ::tkcon::InitInterp $app $type]
}

<font color="#208020">## ::tkcon::PkgMenu - fill in  in the applications sub-menu</font>
<font color="#208020">## with a list of all the applications that currently exist.</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::InterpPkgs_1689">proc <a href="tkcon.tcl-annot.html#::tkcon::InterpPkgs">::tkcon::InterpPkgs</a></a></strong><a name="::tkcon::InterpPkgs"></a> {app type} {
    variable PRIV

    set t $PRIV(base).interppkgs
    if {![winfo exists $t]} {
	<a name="toplevel(3)"><a href="./tkcon.tcl.html#toplevel_5837">toplevel</a></a> $t
	wm withdraw $t
	wm title $t &#34;$app Packages&#34;
	wm transient $t $PRIV(root)
	wm group $t $PRIV(root)
	bind $t &lt;Escape&gt; [list destroy $t]

	label $t.ll -text &#34;Loadable:&#34; -anchor w
	label $t.lr -text &#34;Loaded:&#34; -anchor w
	listbox $t.loadable -font tkconfixed \
	    -yscrollcommand [list $t.llsy set] -selectmode extended
	listbox $t.loaded -font tkconfixed \
	    -yscrollcommand [list $t.lrsy set]
	scrollbar $t.llsy -command [list $t.loadable yview]
	scrollbar $t.lrsy -command [list $t.loaded yview]
	button $t.load -borderwidth 1 -text &#34;&gt;&gt;&#34; \
	    -command [list ::tkcon::InterpPkgLoad $app $type $t.loadable]
	if {$::tcl_version &gt;= 8.4} {
	    $t.load configure -relief flat -overrelief raised
	}

	set f [frame $t.btns]
	button $f.refresh -width 8 -text &#34;Refresh&#34; -command [info level 0]
	button $f.dismiss -width 8 -text &#34;Dismiss&#34; -command [list destroy $t]
	grid $f.refresh $f.dismiss -padx 4 -pady 3 -sticky ew

	grid $t.ll x x $t.lr x -sticky ew
	grid $t.loadable $t.llsy $t.load $t.loaded $t.lrsy -sticky news
	grid $t.btns -sticky e -columnspan 5
	grid columnconfigure $t {0 3} -weight 1
	grid rowconfigure $t 1 -weight 1
	grid configure $t.load -sticky &#34;&#34;

	bind $t.loadable &lt;Double-1&gt; &#34;[list $t.load invoke]; break&#34;
    }
    $t.loaded delete 0 end
    $t.loadable delete 0 end

    <font color="#208020"># just in case stuff has been added to the auto_path</font>
    <font color="#208020"># we have to make sure that the errorInfo doesn't get screwed up</font>
    EvalAttached {
	set __tkcon_error $errorInfo
	catch {package require bogus-package-name}
	set errorInfo ${__tkcon_error}
	unset __tkcon_error
    }
    <font color="#208020"># get all packages loaded into current interp</font>
    foreach pkg [EvalAttached [list info loaded {}]] {
	set pkg [lindex $pkg 1]
	set loaded($pkg) [package provide $pkg]
    }
    <font color="#208020"># get all package names currently visible</font>
    foreach pkg [<a name="lremove(4)"><a href="./tkcon.tcl.html#lremove_4738">lremove</a></a> [EvalAttached {package names}] Tcl] {
	set version [EvalAttached [list package provide $pkg]]
	if {[string compare {} $version]} {
	    set loaded($pkg) $version
	} elseif {![info exists loaded($pkg)]} {
	    set loadable($pkg) package
	}
    }
    <font color="#208020"># get packages that are loaded in any interp</font>
    foreach pkg [EvalAttached {info loaded}] {
	set pkg [lindex $pkg 1]
	if {![info exists loaded($pkg)] &amp;&amp; ![info exists loadable($pkg)]} {
	    set loadable($pkg) load
	}
    }
    foreach pkg [lsort -dictionary [array names loadable]] {
	foreach v [EvalAttached [list package version $pkg]] {
	    $t.loadable insert end [list $pkg $v &#34;($loadable($pkg))&#34;]
	}
    }
    foreach pkg [lsort -dictionary [array names loaded]] {
	$t.loaded insert end [list $pkg $loaded($pkg)]
    }

    wm deiconify $t
    raise $t
}

<strong><a name="::tkcon::InterpPkgLoad_1774">proc <a href="tkcon.tcl-annot.html#::tkcon::InterpPkgLoad">::tkcon::InterpPkgLoad</a></a></strong><a name="::tkcon::InterpPkgLoad"></a> {app type lb} {
    <font color="#208020"># load the lb entry items into the interp</font>
    foreach sel [$lb curselection] {
	foreach {pkg ver method} [$lb get $sel] { break }
	if {$method == &#34;(package)&#34;} {
	    set code [catch {<a name="::tkcon::EvalOther(1)"><a href="./tkcon.tcl.html#::tkcon::EvalOther_1038">::tkcon::EvalOther</a></a> $app $type \
				 package require $pkg $ver} msg]
	} elseif {$method == &#34;(load)&#34;} {
	    set code [catch {<a name="::tkcon::EvalOther(2)"><a href="./tkcon.tcl.html#::tkcon::EvalOther_1038">::tkcon::EvalOther</a></a> $app $type load {} $pkg} msg]
	} else {
	    set code 1
	    set msg &#34;Incorrect entry in Loadable selection&#34;
	}
	if {$code} {
	    tk_messageBox -icon error -title &#34;Error requiring $pkg&#34; -type ok \
		-message &#34;Error requiring $pkg $ver:\n$msg\n$::errorInfo&#34;
	}
    }
    <font color="#208020"># refresh package list</font>
    InterpPkgs $app $type
}

<font color="#208020">## ::tkcon::AttachMenu - fill in  in the applications sub-menu</font>
<font color="#208020">## with a list of all the applications that currently exist.</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::AttachMenu_1799">proc <a href="tkcon.tcl-annot.html#::tkcon::AttachMenu">::tkcon::AttachMenu</a></a></strong><a name="::tkcon::AttachMenu"></a> m {
    variable OPT
    variable PRIV

    array set interps [set tmp [Interps]]
    foreach {i j} $tmp { set tknames($j) {} }

    $m delete 0 end
    set cmd {<a name="::tkcon::RePrompt(1)"><a href="./tkcon.tcl.html#::tkcon::RePrompt_1339">::tkcon::RePrompt</a></a> \n [<a name="::tkcon::CmdGet(1)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> $::tkcon::PRIV(console)]}
    $m add radio -label {None (use local slave) } -accel Ctrl-1 \
	    -variable ::tkcon::PRIV(app) \
	    -value [concat $::tkcon::PRIV(name) $::tkcon::OPT(exec)] \
	    -command &#34;::tkcon::Attach {}; $cmd&#34;
    $m add separator
    $m add command -label &#34;Foreign Tk Interpreters&#34; -state disabled
    foreach i [lsort [<a name="lremove(5)"><a href="./tkcon.tcl.html#lremove_4738">lremove</a></a> [<a name="::send::interps(3)"><a href="./tkcon.tcl.html#::send::interps_6231">::send::interps</a></a>] [array names tknames]]] {
	$m add radio -label $i -variable ::tkcon::PRIV(app) -value $i \
		-command &#34;::tkcon::Attach [list $i] interp; $cmd&#34;
    }
    $m add separator

    $m add command -label &#34;tkcon Interpreters&#34; -state disabled
    foreach i [lsort [array names interps]] {
	if {[string match {} $interps($i)]} { set interps($i) &#34;no Tk&#34; }
	if {[regexp {^Slave[0-9]+} $i]} {
	    set opts [list -label &#34;$i ($interps($i))&#34; \
		    -variable ::tkcon::PRIV(app) -value $i \
		    -command &#34;::tkcon::Attach [list $i] slave; $cmd&#34;]
	    if {[string match $PRIV(name) $i]} {
		append opts &#34; -accel Ctrl-2&#34;
	    }
	    eval $m add radio $opts
	} else {
	    set name [concat Main $i]
	    if {[string match Main $name]} {
		$m add radio -label &#34;$name ($interps($i))&#34; -accel Ctrl-3 \
			-variable ::tkcon::PRIV(app) -value Main \
			-command &#34;::tkcon::Attach [list $name] slave; $cmd&#34;
	    } else {
		$m add radio -label &#34;$name ($interps($i))&#34; \
			-variable ::tkcon::PRIV(app) -value $i \
			-command &#34;::tkcon::Attach [list $name] slave; $cmd&#34;
	    }
	}
    }
}

<font color="#208020">## Displays Cascaded Menu</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::DisplayMenu_1848">proc <a href="tkcon.tcl-annot.html#::tkcon::DisplayMenu">::tkcon::DisplayMenu</a></a></strong><a name="::tkcon::DisplayMenu"></a> m {
    $m delete 0 end
    set cmd {<a name="::tkcon::RePrompt(2)"><a href="./tkcon.tcl.html#::tkcon::RePrompt_1339">::tkcon::RePrompt</a></a> \n [<a name="::tkcon::CmdGet(2)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> $::tkcon::PRIV(console)]}

    $m add command -label &#34;New Display&#34; -command ::tkcon::NewDisplay
    foreach disp [Display] {
	$m add separator
	$m add command -label $disp -state disabled
	set res [Display $disp]
	set win [lindex $res 0]
	foreach i [lsort [lindex $res 1]] {
	    $m add radio -label $i -variable ::tkcon::PRIV(app) -value $i \
		    -command &#34;::tkcon::Attach [list $i] [list dpy:$win]; $cmd&#34;
	}
    }
}

<font color="#208020">## Sockets Cascaded Menu</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::SocketMenu_1867">proc <a href="tkcon.tcl-annot.html#::tkcon::SocketMenu">::tkcon::SocketMenu</a></a></strong><a name="::tkcon::SocketMenu"></a> m {
    $m delete 0 end
    set cmd {<a name="::tkcon::RePrompt(3)"><a href="./tkcon.tcl.html#::tkcon::RePrompt_1339">::tkcon::RePrompt</a></a> \n [<a name="::tkcon::CmdGet(3)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> $::tkcon::PRIV(console)]}

    $m add command -label &#34;Create Connection&#34; \
	    -command &#34;::tkcon::NewSocket; $cmd&#34;
    foreach sock [file channels sock*] {
	$m add radio -label $sock -variable ::tkcon::PRIV(app) -value $sock \
		-command &#34;::tkcon::Attach $sock socket; $cmd&#34;
    }
}

<font color="#208020">## Namepaces Cascaded Menu</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::NamespaceMenu_1881">proc <a href="tkcon.tcl-annot.html#::tkcon::NamespaceMenu">::tkcon::NamespaceMenu</a></a></strong><a name="::tkcon::NamespaceMenu"></a> m {
    variable PRIV
    variable OPT

    $m delete 0 end
    if {($PRIV(deadapp) || [string match socket $PRIV(apptype)] || \
	    ($OPT(nontcl) &amp;&amp; [string match interp $PRIV(apptype)]))} {
	$m add command -label &#34;No Namespaces&#34; -state disabled
	return
    }

    <font color="#208020">## Same command as for ::tkcon::AttachMenu items</font>
    set cmd {<a name="::tkcon::RePrompt(4)"><a href="./tkcon.tcl.html#::tkcon::RePrompt_1339">::tkcon::RePrompt</a></a> \n [<a name="::tkcon::CmdGet(4)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> $::tkcon::PRIV(console)]}

    set names [lsort [Namespaces ::]]
    if {[llength $names] &gt; $OPT(maxmenu)} {
	$m add command -label &#34;Attached to $PRIV(namesp)&#34; -state disabled
	$m add command -label &#34;List Namespaces&#34; \
		-command [list ::tkcon::NamespacesList $names]
    } else {
	foreach i $names {
	    if {[string match :: $i]} {
		$m add radio -label &#34;Main&#34; -value $i \
			-variable ::tkcon::PRIV(namesp) \
			-command &#34;::tkcon::AttachNamespace [list $i]; $cmd&#34;
	    } else {
		$m add radio -label $i -value $i \
			-variable ::tkcon::PRIV(namesp) \
			-command &#34;::tkcon::AttachNamespace [list $i]; $cmd&#34;
	    }
	}
    }
}

<font color="#208020">## Namepaces List </font>
<font color="#208020">##</font>
<strong><a name="::tkcon::NamespacesList_1917">proc <a href="tkcon.tcl-annot.html#::tkcon::NamespacesList">::tkcon::NamespacesList</a></a></strong><a name="::tkcon::NamespacesList"></a> {names} {
    variable PRIV

    set f $PRIV(base).namespaces
    catch {destroy $f}
    <a name="toplevel(4)"><a href="./tkcon.tcl.html#toplevel_5837">toplevel</a></a> $f
    listbox $f.names -width 30 -height 15 -selectmode single \
	    -yscrollcommand [list $f.scrollv set] \
	    -xscrollcommand [list $f.scrollh set]
    scrollbar $f.scrollv -command [list $f.names yview]
    scrollbar $f.scrollh -command [list $f.names xview] -orient horizontal
    frame $f.buttons
    button $f.cancel -text &#34;Cancel&#34; -command [list destroy $f]

    grid $f.names $f.scrollv -sticky nesw
    grid $f.scrollh -sticky ew
    grid $f.buttons -sticky nesw
    grid $f.cancel -in $f.buttons -pady 6

    grid columnconfigure $f 0 -weight 1
    grid rowconfigure $f  0 -weight 1
    <font color="#208020">#fill the listbox</font>
    foreach i $names {
	if {[string match :: $i]} {
	    $f.names insert 0 Main
	} else {
	    $f.names insert end $i
	}
    }
    <font color="#208020">#Bindings</font>
    bind $f.names &lt;Double-1&gt; {
	<font color="#208020">## Catch in case the namespace disappeared on us</font>
	catch { <a name="::tkcon::AttachNamespace(1)"><a href="./tkcon.tcl.html#::tkcon::AttachNamespace_2221">::tkcon::AttachNamespace</a></a> [%W get [%W nearest %y]] }
	<a name="::tkcon::RePrompt(5)"><a href="./tkcon.tcl.html#::tkcon::RePrompt_1339">::tkcon::RePrompt</a></a> &#34;\n&#34; [<a name="::tkcon::CmdGet(5)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> $::tkcon::PRIV(console)]
	destroy [winfo toplevel %W]
    }
}

<font color="#208020"># ::tkcon::XauthSecure --</font>
<font color="#208020">#</font>
<font color="#208020">#   This removes all the names in the xhost list, and secures</font>
<font color="#208020">#   the display for Tk send commands.  Of course, this prevents</font>
<font color="#208020">#   what might have been otherwise allowable X connections</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   none</font>
<font color="#208020"># Results:</font>
<font color="#208020">#   Returns nothing</font>
<font color="#208020">#</font>
<strong><a name="::tkcon::XauthSecure_1966">proc <a href="tkcon.tcl-annot.html#::tkcon::XauthSecure">::tkcon::XauthSecure</a></a></strong><a name="::tkcon::XauthSecure"></a> {} {
    global tcl_platform

    if {[string compare unix $tcl_platform(platform)]} {
	<font color="#208020"># This makes no sense outside of Unix</font>
	return
    }
    set hosts [exec xhost]
    <font color="#208020"># the first line is info only</font>
    foreach host [lrange [split $hosts \n] 1 end] {
	exec xhost -$host
    }
    exec xhost -
    tk_messageBox -title &#34;Xhost secured&#34; -message &#34;Xhost secured&#34; -icon info
}

<font color="#208020">## ::tkcon::FindBox - creates minimal dialog interface to ::tkcon::Find</font>
<font color="#208020"># ARGS:	w	- text widget</font>
<font color="#208020">#	str	- optional seed string for ::tkcon::PRIV(find)</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::FindBox_1986">proc <a href="tkcon.tcl-annot.html#::tkcon::FindBox">::tkcon::FindBox</a></a></strong><a name="::tkcon::FindBox"></a> {w {str {}}} {
    variable PRIV

    set base $PRIV(base).find
    if {![winfo exists $base]} {
	<a name="toplevel(5)"><a href="./tkcon.tcl.html#toplevel_5837">toplevel</a></a> $base
	wm withdraw $base
	wm title $base &#34;tkcon Find&#34;

	pack [frame $base.f] -fill x -expand 1
	label $base.f.l -text &#34;Find:&#34;
	entry $base.f.e -textvariable ::tkcon::PRIV(find)
	pack [frame $base.opt] -fill x
	checkbutton $base.opt.c -text &#34;Case Sensitive&#34; \
		-variable ::tkcon::PRIV(find,case)
	checkbutton $base.opt.r -text &#34;Use Regexp&#34; -variable ::tkcon::PRIV(find,reg)
	pack $base.f.l -side left
	pack $base.f.e $base.opt.c $base.opt.r -side left -fill both -expand 1
	pack [frame $base.sep -borderwidth 2 -relief sunken -height 4] -fill x
	pack [frame $base.btn] -fill both
	button $base.btn.fnd -text &#34;Find&#34; -width 6
	button $base.btn.clr -text &#34;Clear&#34; -width 6
	button $base.btn.dis -text &#34;Dismiss&#34; -width 6
	eval pack [winfo children $base.btn] -padx 4 -pady 2 \
		-side left -fill both

	focus $base.f.e

	bind $base.f.e &lt;Return&gt; [list $base.btn.fnd invoke]
	bind $base.f.e &lt;Escape&gt; [list $base.btn.dis invoke]
    }
    $base.btn.fnd config -command &#34;::tkcon::Find [list $w] \$::tkcon::PRIV(find) \
	    -case \$::tkcon::PRIV(find,case) -reg \$::tkcon::PRIV(find,reg)&#34;
    $base.btn.clr config -command &#34;
    [list $w] tag remove find 1.0 end
    set ::tkcon::PRIV(find) {}
    &#34;
    $base.btn.dis config -command &#34;
    [list $w] tag remove find 1.0 end
    wm withdraw [list $base]
    &#34;
    if {[string compare {} $str]} {
	set PRIV(find) $str
	$base.btn.fnd invoke
    }

    if {[string compare normal [wm state $base]]} {
	wm deiconify $base
    } else { raise $base }
    $base.f.e select range 0 end
}

<font color="#208020">## ::tkcon::Find - searches in text widget $w for $str and highlights it</font>
<font color="#208020">## If $str is empty, it just deletes any highlighting</font>
<font color="#208020"># ARGS: w	- text widget</font>
<font color="#208020">#	str	- string to search for</font>
<font color="#208020">#	-case	TCL_BOOLEAN	whether to be case sensitive	DEFAULT: 0</font>
<font color="#208020">#	-regexp	TCL_BOOLEAN	whether to use $str as pattern	DEFAULT: 0</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::Find_2045">proc <a href="tkcon.tcl-annot.html#::tkcon::Find">::tkcon::Find</a></a></strong><a name="::tkcon::Find"></a> {w str args} {
    $w tag remove find 1.0 end
    set truth {^(1|yes|true|on)$}
    set opts  {}
    foreach {key val} $args {
	switch -glob -- $key {
	    -c* { if {[regexp -nocase $truth $val]} { set case 1 } }
	    -r* { if {[regexp -nocase $truth $val]} { lappend opts -regexp } }
	    default { return -code error &#34;Unknown option $key&#34; }
	}
    }
    if {![info exists case]} { lappend opts -nocase }
    if {[string match {} $str]} return
    $w mark set findmark 1.0
    while {[string compare {} [set ix [eval $w search $opts -count numc -- \
	    [list $str] findmark end]]]} {
	$w tag add find $ix ${ix}+${numc}c
	$w mark set findmark ${ix}+1c
    }
    $w tag configure find -background $::tkcon::COLOR(blink)
    catch {$w see find.first}
    return [expr {[llength [$w tag ranges find]]/2}]
}

<font color="#208020">## ::tkcon::Attach - called to attach tkcon to an interpreter</font>
<font color="#208020"># ARGS:	name	- application name to which tkcon sends commands</font>
<font color="#208020">#		  This is either a slave interperter name or tk appname.</font>
<font color="#208020">#	type	- (slave|interp) type of interpreter we're attaching to</font>
<font color="#208020">#		  slave means it's a tkcon interpreter</font>
<font color="#208020">#		  interp means we'll need to 'send' to it.</font>
<font color="#208020"># Results:	::tkcon::EvalAttached is recreated to evaluate in the</font>
<font color="#208020">#		appropriate interpreter</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::Attach_2078">proc <a href="tkcon.tcl-annot.html#::tkcon::Attach">::tkcon::Attach</a></a></strong><a name="::tkcon::Attach"></a> {{name &lt;NONE&gt;} {type slave} {ns {}}} {
    variable PRIV
    variable OPT
    variable ATTACH

    if {[llength [info level 0]] == 1} {
	<font color="#208020"># no args were specified, return the attach info instead</font>
	return [AttachId]
    }
    set path [concat $PRIV(name) $OPT(exec)]

    set PRIV(displayWin) .
    if {[string match namespace $type]} {
	return [uplevel 1 ::tkcon::AttachNamespace $name]
    } elseif {[string match dpy:* $type]} {
	set PRIV(displayWin) [string range $type 4 end]
    } elseif {[string match sock* $type]} {
	global tcl_version
	if {[catch {eof $name} res]} {
	    return -code error &#34;No known channel \&#34;$name\&#34;&#34;
	} elseif {$res} {
	    catch {close $name}
	    return -code error &#34;Channel \&#34;$name\&#34; returned EOF&#34;
	}
	set app $name
	set type socket
    } elseif {[string compare {} $name]} {
	array set interps [Interps]
	if {[string match {[Mm]ain} [lindex $name 0]]} {
	    set name [lrange $name 1 end]
	}
	if {[string match $path $name]} {
	    set name {}
	    set app $path
	    set type slave
	} elseif {[info exists interps($name)]} {
	    if {[string match {} $name]} { set name Main; set app Main }
	    set type slave
	} elseif {[interp exists $name]} {
	    set name [concat $PRIV(name) $name]
	    set type slave
	} elseif {[interp exists [concat $OPT(exec) $name]]} {
	    set name [concat $path $name]
	    set type slave
	} elseif {[lsearch -exact [<a name="::send::interps(4)"><a href="./tkcon.tcl.html#::send::interps_6231">::send::interps</a></a>] $name] &gt; -1} {
	    if {[EvalSlave info exists tk_library] \
		    &amp;&amp; [string match $name [EvalSlave tk appname]]} {
		set name {}
		set app $path
		set type slave
	    } elseif {[set i [lsearch -exact \
		    [Main set ::tkcon::PRIV(interps)] $name]] != -1} {
		set name [lindex [Main set ::tkcon::PRIV(slaves)] $i]
		if {[string match {[Mm]ain} $name]} { set app Main }
		set type slave
	    } else {
		set type interp
	    }
	} else {
	    return -code error &#34;No known interpreter \&#34;$name\&#34;&#34;
	}
    } else {
	set app $path
    }
    if {![info exists app]} { set app $name }
    array set PRIV [list app $app appname $name apptype $type deadapp 0]

    <font color="#208020">## ::tkcon::EvalAttached - evaluates the args in the attached interp</font>
    <font color="#208020">## args should be passed to this procedure as if they were being</font>
    <font color="#208020">## passed to the 'eval' procedure.  This procedure is dynamic to</font>
    <font color="#208020">## ensure evaluation occurs in the right interp.</font>
    <font color="#208020"># ARGS:	args	- the command and args to evaluate</font>
    <font color="#208020">##</font>
    set PRIV(namesp) ::
    set namespOK 0
    switch -glob -- $type {
	slave {
	    if {[string match {} $name]} {
		interp alias {} ::tkcon::EvalAttached {} \
			::tkcon::EvalSlave uplevel \#0
	    } elseif {[string match Main $PRIV(app)]} {
		interp alias {} ::tkcon::EvalAttached {} ::tkcon::Main
	    } elseif {[string match $PRIV(name) $PRIV(app)]} {
		interp alias {} ::tkcon::EvalAttached {} uplevel \#0
	    } else {
		interp alias {} ::tkcon::EvalAttached {} \
			::tkcon::Slave $::tkcon::PRIV(app)
	    }
	    set namespOK 1
	}
	sock* {
	    interp alias {} ::tkcon::EvalAttached {} \
		    ::tkcon::EvalSlave uplevel \#0
	    <font color="#208020"># The file event will just puts whatever data is found</font>
	    <font color="#208020"># into the interpreter</font>
	    fconfigure $name -buffering line -blocking 0
	    fileevent $name readable [list ::tkcon::EvalSocketEvent $name]
	}
	dpy:* -
	interp {
	    if {$OPT(nontcl)} {
		interp alias {} ::tkcon::EvalAttached {} ::tkcon::EvalSlave
	    } else {
		interp alias {} ::tkcon::EvalAttached {} ::tkcon::EvalSend
		set namespOK 1
	    }
	}
	default {
	    return -code error &#34;[lindex [info level 0] 0] did not specify\
		    a valid type: must be slave or interp&#34;
	}
    }
    if {![string match {} $ns] &amp;&amp; $namespOK} {
	AttachNamespace $ns
    }
    return [AttachId]
}

<strong><a name="::tkcon::AttachId_2196">proc <a href="tkcon.tcl-annot.html#::tkcon::AttachId">::tkcon::AttachId</a></a></strong><a name="::tkcon::AttachId"></a> {} {
    <font color="#208020"># return Attach info in a form that Attach accepts again</font>
    variable PRIV

    if {[string match {} $PRIV(appname)]} {
	variable OPT
	set appname [concat $PRIV(name) $OPT(exec)]
    } else {
	set appname $PRIV(appname)
    }
    set id [list $appname $PRIV(apptype)]
    <font color="#208020"># only display ns info if it isn't &#34;::&#34; as that is what is also</font>
    <font color="#208020"># used to indicate no eval in namespace</font>
    if {![string match :: $PRIV(namesp)]} { lappend id $PRIV(namesp) }
    if {[info exists PRIV(console)]} {
	variable ATTACH
	set ATTACH($PRIV(console)) $id
    }
    return $id
}

<font color="#208020">## ::tkcon::AttachNamespace - called to attach tkcon to a namespace</font>
<font color="#208020"># ARGS:	name	- namespace name in which tkcon should eval commands</font>
<font color="#208020"># Results:	::tkcon::EvalAttached will be modified</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::AttachNamespace_2221">proc <a href="tkcon.tcl-annot.html#::tkcon::AttachNamespace">::tkcon::AttachNamespace</a></a></strong><a name="::tkcon::AttachNamespace"></a> { name } {
    variable PRIV
    variable OPT

    <font color="#208020"># We could enable 'socket' bound Tcl interps, but we'd have to create</font>
    <font color="#208020"># a return listening socket</font>
    if {($OPT(nontcl) &amp;&amp; [string match interp $PRIV(apptype)]) \
	    || [string match socket $PRIV(apptype)] \
	    || $PRIV(deadapp)} {
	return -code error &#34;can't attach to namespace in attached environment&#34;
    }
    if {[string match Main $name]} {set name ::}
    if {[string compare {} $name] &amp;&amp; \
	    [lsearch [Namespaces ::] $name] == -1} {
	return -code error &#34;No known namespace \&#34;$name\&#34;&#34;
    }
    if {[regexp {^(|::)$} $name]} {
	<font color="#208020">## If name=={} || ::, we want the primary namespace</font>
	set alias [interp alias {} ::tkcon::EvalAttached]
	if {[string match ::tkcon::EvalNamespace* $alias]} {
	    eval [list interp alias {} ::tkcon::EvalAttached {}] \
		    [lindex $alias 1]
	}
	set name ::
    } else {
	interp alias {} ::tkcon::EvalAttached {} ::tkcon::EvalNamespace \
		[interp alias {} ::tkcon::EvalAttached] [list $name]
    }
    set PRIV(namesp) $name
    return [AttachId]
}

<font color="#208020">## ::tkcon::NewSocket - called to create a socket to connect to</font>
<font color="#208020"># ARGS:	none</font>
<font color="#208020"># Results:	It will create a socket, and attach if requested</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::NewSocket_2257">proc <a href="tkcon.tcl-annot.html#::tkcon::NewSocket">::tkcon::NewSocket</a></a></strong><a name="::tkcon::NewSocket"></a> {} {
    variable PRIV

    set t $PRIV(base).newsock
    if {![winfo exists $t]} {
	<a name="toplevel(6)"><a href="./tkcon.tcl.html#toplevel_5837">toplevel</a></a> $t
	wm withdraw $t
	wm title $t &#34;tkcon Create Socket&#34;
	label $t.lhost -text &#34;Host: &#34;
	entry $t.host -width 16 -takefocus 1
	label $t.lport -text &#34;Port: &#34;
	entry $t.port -width 4 -takefocus 1
	button $t.ok -text &#34;OK&#34; -command {set ::tkcon::PRIV(grab) 1} -width 4 \
	    -takefocus 1
	bind $t.host &lt;Return&gt; [list focus $t.port]
	bind $t.port &lt;Return&gt; [list focus $t.ok]
	bind $t.ok   &lt;Return&gt; [list $t.ok invoke]
	grid $t.lhost $t.host $t.lport $t.port $t.ok -sticky ew
	grid configure $t.ok -padx 4 -pady 2
	grid columnconfig $t 1 -weight 1
	grid rowconfigure $t 1 -weight 1
	wm transient $t $PRIV(root)
	wm group $t $PRIV(root)
	wm geometry $t +[expr {([winfo screenwidth $t]-[winfo \
		reqwidth $t]) / 2}]+[expr {([winfo \
		screenheight $t]-[winfo reqheight $t]) / 2}]
	bind $t &lt;Escape&gt; [list destroy $t]
    }
    <font color="#208020">#$t.host delete 0 end</font>
    <font color="#208020">#$t.port delete 0 end</font>
    wm deiconify $t
    raise $t
    grab $t
    focus $t.host
    vwait ::tkcon::PRIV(grab)
    grab release $t
    wm withdraw $t
    set host [$t.host get]
    set port [$t.port get]
    if {$host == &#34;&#34;} { return }
    if {[catch {
	set sock [socket $host $port]
    } err]} {
	tk_messageBox -title &#34;Socket Connection Error&#34; \
		-message &#34;Unable to connect to \&#34;$host:$port\&#34;:\n$err&#34; \
		-icon error -type ok
    } else {
	Attach $sock socket
    }
}

<font color="#208020">## ::tkcon::Load - sources a file into the console</font>
<font color="#208020">## The file is actually sourced in the currently attached's interp</font>
<font color="#208020"># ARGS:	fn	- (optional) filename to source in</font>
<font color="#208020"># Returns:	selected filename ({} if nothing was selected)</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::Load_2313">proc <a href="tkcon.tcl-annot.html#::tkcon::Load">::tkcon::Load</a></a></strong><a name="::tkcon::Load"></a> { {fn &#34;&#34;} } {
    set types {
	{{Tcl Files}	{.tcl .tk}}
	{{Text Files}	{.txt}}
	{{All Files}	*}
    }
    <font color="#208020"># Allow for VFS directories, use Tk dialogs automatically when in</font>
    <font color="#208020"># VFS-based areas</font>
    set check [expr {$fn == &#34;&#34; ? [pwd] : $fn}]
    if {$::tcl_version &gt;= 8.4 &amp;&amp; [lindex [file system $check] 0] == &#34;tclvfs&#34;} {
	set opencmd [list ::tk::dialog::file:: open]
    } else {
	set opencmd [list tk_getOpenFile]
    }
    if {
	[string match {} $fn] &amp;&amp;
	([catch {tk_getOpenFile -filetypes $types \
	    -title &#34;Source File&#34;} fn] || [string match {} $fn])
    } { return }
    EvalAttached [list source $fn]
}

<font color="#208020">## ::tkcon::Save - saves the console or other widget buffer to a file</font>
<font color="#208020">## This does not eval in a slave because it's not necessary</font>
<font color="#208020"># ARGS:	w	- console text widget</font>
<font color="#208020"># 	fn	- (optional) filename to save to</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::Save_2340">proc <a href="tkcon.tcl-annot.html#::tkcon::Save">::tkcon::Save</a></a></strong><a name="::tkcon::Save"></a> { {fn &#34;&#34;} {type &#34;&#34;} {opt &#34;&#34;} {mode w} } {
    variable PRIV

    if {![regexp -nocase {^(all|history|stdin|stdout|stderr|widget)$} $type]} {
	array set s { 0 All 1 History 2 Stdin 3 Stdout 4 Stderr 5 Cancel }
	<font color="#208020">## Allow user to specify what kind of stuff to save</font>
	set type [tk_dialog $PRIV(base).savetype &#34;Save Type&#34; \
		&#34;What part of the text do you want to save?&#34; \
		questhead 0 $s(0) $s(1) $s(2) $s(3) $s(4) $s(5)]
	if {$type == 5 || $type == -1} return
	set type $s($type)
    }
    <font color="#208020"># Allow for VFS directories, use Tk dialogs automatically when in</font>
    <font color="#208020"># VFS-based areas</font>
    set check [expr {$opt == &#34;&#34; ? [pwd] : $opt}]
    if {$::tcl_version &gt;= 8.4 &amp;&amp; [lindex [file system $check] 0] == &#34;tclvfs&#34;} {
	set savecmd [list ::tk::dialog::file:: save]
    } else {
	set savecmd [list tk_getSaveFile]
    }
    if {[string match {} $fn]} {
	set types {
	    {{Tcl Files}	{.tcl .tk}}
	    {{Text Files}	{.txt}}
	    {{All Files}	*}
	}
	if {[catch {eval $savecmd [list -defaultextension .tcl \
				       -filetypes $types \
				       -title &#34;Save $type&#34;]} fn]
	     || [string match {} $fn]} return
    }
    set type [string tolower $type]
    switch $type {
	stdin -	stdout - stderr {
	    set data {}
	    foreach {first last} [$PRIV(console) tag ranges $type] {
		lappend data [$PRIV(console) get $first $last]
	    }
	    set data [join $data \n]
	}
	history		{ set data [<a name="tkcon(2)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> history] }
	all - default	{ set data [$PRIV(console) get 1.0 end-1c] }
	widget		{
	    set data [$opt get 1.0 end-1c]
	}
    }
    if {[catch {open $fn $mode} fid]} {
	return -code error &#34;Save Error: Unable to open '$fn' for writing\n$fid&#34;
    }
    puts -nonewline $fid $data
    close $fid
}

<font color="#208020">## ::tkcon::MainInit</font>
<font color="#208020">## This is only called for the main interpreter to include certain procs</font>
<font color="#208020">## that we don't want to include (or rather, just alias) in slave interps.</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::MainInit_2397">proc <a href="tkcon.tcl-annot.html#::tkcon::MainInit">::tkcon::MainInit</a></a></strong><a name="::tkcon::MainInit"></a> {} {
    variable PRIV
    variable OPT

    if {![info exists PRIV(slaves)]} {
	array set PRIV [list slave 0 slaves Main name {} \
		interps [list [<a name="tk(5)"><a href="./tkcon.tcl.html#tk_6296">tk</a></a> appname]]]
    }
    interp alias {} ::tkcon::Main {} ::tkcon::InterpEval Main
    interp alias {} ::tkcon::Slave {} ::tkcon::InterpEval

    <strong><a name="::tkcon::GetSlave_2408">proc <a href="tkcon.tcl-annot.html#::tkcon::GetSlave">::tkcon::GetSlave</a></a></strong><a name="::tkcon::GetSlave"></a> {{slave {}}} {
	set i 0
	puts [info level 0]
	while {[Slave $slave [list interp exists Slave[incr i]]]} {
	    <font color="#208020"># oh my god, an empty loop!</font>
	}
	set interp [Slave $slave [list interp create Slave$i]]
	return $interp
    }

    <font color="#208020">## ::tkcon::New - create new console window</font>
    <font color="#208020">## Creates a slave interpreter and sources in this script.</font>
    <font color="#208020">## All other interpreters also get a command to eval function in the</font>
    <font color="#208020">## new interpreter.</font>
    <font color="#208020">## </font>
    <strong><a name="::tkcon::New_2423">proc <a href="tkcon.tcl-annot.html#::tkcon::New">::tkcon::New</a></a></strong><a name="::tkcon::New"></a> {} {
	variable PRIV
	global argv0 argc argv

	set tmp [GetSlave]
	lappend PRIV(slaves) $tmp
	load {} Tk $tmp
	<font color="#208020"># If we have tbcload, then that should be autoloaded into slaves.</font>
	set idx [lsearch [info loaded] &#34;* Tbcload&#34;]
	if {$idx != -1} { catch {load {} Tbcload $tmp} }
	lappend PRIV(interps) [$tmp eval [list tk appname \
		&#34;[<a name="tk(6)"><a href="./tkcon.tcl.html#tk_6296">tk</a></a> appname] $tmp&#34;]]
	if {[info exists argv0]} {$tmp eval [list set argv0 $argv0]}
	if {[info exists argc]}  {$tmp eval [list set argc $argc]}
	if {[info exists argv]}  {$tmp eval [list set argv $argv]}
	$tmp eval [list namespace eval ::tkcon {}]
	$tmp eval [list set ::tkcon::PRIV(name) $tmp]
	$tmp eval [list set ::tkcon::PRIV(SCRIPT) $::tkcon::PRIV(SCRIPT)]
	$tmp alias exit				::tkcon::Exit $tmp
	$tmp alias ::tkcon::Destroy		::tkcon::Destroy $tmp
	$tmp alias ::tkcon::New			::tkcon::New
	$tmp alias ::tkcon::GetSlave		::tkcon::GetSlave $tmp
	$tmp alias ::tkcon::Main		::tkcon::InterpEval Main
	$tmp alias ::tkcon::Slave		::tkcon::InterpEval
	$tmp alias ::tkcon::Interps		::tkcon::Interps
	$tmp alias ::tkcon::NewDisplay		::tkcon::NewDisplay
	$tmp alias ::tkcon::Display		::tkcon::Display
	$tmp alias ::tkcon::StateCheckpoint	::tkcon::StateCheckpoint
	$tmp alias ::tkcon::StateCleanup	::tkcon::StateCleanup
	$tmp alias ::tkcon::StateCompare	::tkcon::StateCompare
	$tmp alias ::tkcon::StateRevert		::tkcon::StateRevert
	$tmp eval {
	    if [catch {source -rsrc tkcon}] { source $::tkcon::PRIV(SCRIPT) }
	}
	return $tmp
    }

    <font color="#208020">## ::tkcon::Exit - full exit OR destroy slave console</font>
    <font color="#208020">## This proc should only be called in the main interpreter from a slave.</font>
    <font color="#208020">## The master determines whether we do a full exit or just kill the slave.</font>
    <font color="#208020">## </font>
    <strong><a name="::tkcon::Exit_2464">proc <a href="tkcon.tcl-annot.html#::tkcon::Exit">::tkcon::Exit</a></a></strong><a name="::tkcon::Exit"></a> {slave args} {
	variable PRIV
	variable OPT

	<font color="#208020">## Slave interpreter exit request</font>
	if {[string match exit $OPT(slaveexit)]
	    || [llength $PRIV(interps)] == 1} {
	    <font color="#208020">## Only exit if it specifically is stated to do so, or this</font>
	    <font color="#208020">## is the last interp</font>
	    uplevel 1 exit $args
	} else {
	    <font color="#208020">## Otherwise we will delete the slave interp and associated data</font>
	    Destroy $slave
	}
    }

    <font color="#208020">## ::tkcon::Destroy - destroy console window</font>
    <font color="#208020">## This proc should only be called by the main interpreter.  If it is</font>
    <font color="#208020">## called from there, it will ask before exiting tkcon.  All others</font>
    <font color="#208020">## (slaves) will just have their slave interpreter deleted, closing them.</font>
    <font color="#208020">## </font>
    <strong><a name="::tkcon::Destroy_2485">proc <a href="tkcon.tcl-annot.html#::tkcon::Destroy">::tkcon::Destroy</a></a></strong><a name="::tkcon::Destroy"></a> {{slave {}}} {
	variable PRIV

	<font color="#208020"># Just close on the last one</font>
	if {[llength $PRIV(interps)] == 1} { exit }
	if {&#34;&#34; == $slave} {
	    <font color="#208020">## Main interpreter close request</font>
	    if {[tk_messageBox -parent $PRIV(root) -title &#34;Quit tkcon?&#34; \
		     -message &#34;Close all windows and exit tkcon?&#34; \
		     -icon question -type yesno] == &#34;yes&#34;} { exit }
	    return
	} elseif {$slave == $::tkcon::OPT(exec)} {
	    set name  [<a name="tk(7)"><a href="./tkcon.tcl.html#tk_6296">tk</a></a> appname]
	    set slave &#34;Main&#34;
	} else {
	    <font color="#208020">## Slave interpreter close request</font>
	    set name [InterpEval $slave]
	    interp delete $slave
	}
	set PRIV(interps) [<a name="lremove(6)"><a href="./tkcon.tcl.html#lremove_4738">lremove</a></a> $PRIV(interps) [list $name]]
	set PRIV(slaves)  [<a name="lremove(7)"><a href="./tkcon.tcl.html#lremove_4738">lremove</a></a> $PRIV(slaves) [list $slave]]
	StateCleanup $slave
    }

    if {$OPT(overrideexit)} {
	<font color="#208020">## We want to do a couple things before exiting...</font>
	if {[catch {rename ::exit ::tkcon::FinalExit} err]} {
	    puts stderr &#34;tkcon might panic:\n$err&#34;
	}
	<strong><a name="::exit_2514">proc <a href="tkcon.tcl-annot.html#::exit">::exit</a></a></strong><a name="::exit"></a> args {
	    if {$::tkcon::OPT(usehistory)} {
		if {[catch {open $::tkcon::PRIV(histfile) w} fid]} {
		    puts stderr &#34;unable to save history file:\n$fid&#34;
		    <font color="#208020"># pause a moment, because we are about to die finally...</font>
		    after 1000
		} else {
		    set max [<a name="::tkcon::EvalSlave(1)"><a href="./tkcon.tcl.html#::tkcon::EvalSlave_1029">::tkcon::EvalSlave</a></a> history nextid]
		    set id [expr {$max - $::tkcon::OPT(history)}]
		    if {$id &lt; 1} { set id 1 }
		    <font color="#208020">## FIX: This puts history in backwards!!</font>
		    while {($id &lt; $max) &amp;&amp; ![catch \
			    {<a name="::tkcon::EvalSlave(2)"><a href="./tkcon.tcl.html#::tkcon::EvalSlave_1029">::tkcon::EvalSlave</a></a> history event $id} cmd]} {
			if {[string compare {} $cmd]} {
			    puts $fid &#34;::tkcon::EvalSlave\
				    history add [list $cmd]&#34;
			}
			incr id
		    }
		    close $fid
		}
	    }
	    uplevel 1 ::tkcon::FinalExit $args
	}
    }

    <font color="#208020">## ::tkcon::InterpEval - passes evaluation to another named interpreter</font>
    <font color="#208020">## If the interpreter is named, but no args are given, it returns the</font>
    <font color="#208020">## [tk appname] of that interps master (not the associated eval slave).</font>
    <font color="#208020">##</font>
    <strong><a name="::tkcon::InterpEval_2544">proc <a href="tkcon.tcl-annot.html#::tkcon::InterpEval">::tkcon::InterpEval</a></a></strong><a name="::tkcon::InterpEval"></a> {{slave {}} args} {
	variable PRIV

	if {[llength [info level 0]] == 1} {
	    <font color="#208020"># no args given</font>
	    return $PRIV(slaves)
	} elseif {[string match {[Mm]ain} $slave]} {
	    set slave {}
	}
	if {[llength $args]} {
	    return [interp eval $slave uplevel \#0 $args]
	} else {
	    <font color="#208020"># beware safe interps with Tk</font>
	    if {[interp eval $slave {llength [info commands tk]}]} {
		if {[catch {interp eval $slave tk appname} name]} {
		    return &#34;safetk&#34;
		}
		return $name
	    }
	}
    }

    <strong><a name="::tkcon::Interps_2566">proc <a href="tkcon.tcl-annot.html#::tkcon::Interps">::tkcon::Interps</a></a></strong><a name="::tkcon::Interps"></a> {{ls {}} {interp {}}} {
	if {[string match {} $interp]} {
	    lappend ls {} [<a name="tk(8)"><a href="./tkcon.tcl.html#tk_6296">tk</a></a> appname]
	}
	foreach i [interp slaves $interp] {
	    if {[string compare {} $interp]} { set i &#34;$interp $i&#34; }
	    if {[string compare {} [interp eval $i package provide Tk]]} {
		<font color="#208020"># beware safe interps with Tk</font>
		if {[catch {interp eval $i tk appname} name]} {
		    set name {}
		}
		lappend ls $i $name
	    } else {
		lappend ls $i {}
	    }
	    set ls [Interps $ls $i]
	}
	return $ls
    }

    <strong><a name="::tkcon::Display_2586">proc <a href="tkcon.tcl-annot.html#::tkcon::Display">::tkcon::Display</a></a></strong><a name="::tkcon::Display"></a> {{disp {}}} {
	variable DISP

	set res {}
	if {$disp != &#34;&#34;} {
	    if {![info exists DISP($disp)]} { return }
	    return [list $DISP($disp) [winfo interps -displayof $DISP($disp)]]
	}
	return [lsort -dictionary [array names DISP]]
    }

    <strong><a name="::tkcon::NewDisplay_2597">proc <a href="tkcon.tcl-annot.html#::tkcon::NewDisplay">::tkcon::NewDisplay</a></a></strong><a name="::tkcon::NewDisplay"></a> {} {
	variable PRIV
	variable DISP

	set t $PRIV(base).newdisp
	if {![winfo exists $t]} {
	    <a name="toplevel(7)"><a href="./tkcon.tcl.html#toplevel_5837">toplevel</a></a> $t
	    wm withdraw $t
	    wm title $t &#34;tkcon Attach to Display&#34;
	    label $t.gets -text &#34;New Display: &#34;
	    entry $t.data -width 32
	    button $t.ok -text &#34;OK&#34; -command {set ::tkcon::PRIV(grab) 1}
	    bind $t.data &lt;Return&gt; [list $t.ok invoke]
	    bind $t.ok   &lt;Return&gt; [list $t.ok invoke]
	    grid $t.gets $t.data -sticky ew
	    grid $t.ok   -	 -sticky ew
	    grid columnconfig $t 1 -weight 1
	    grid rowconfigure $t 1 -weight 1
	    wm transient $t $PRIV(root)
	    wm geometry $t +[expr {([winfo screenwidth $t]-[winfo \
		    reqwidth $t]) / 2}]+[expr {([winfo \
		    screenheight $t]-[winfo reqheight $t]) / 2}]
	}
	$t.data delete 0 end
	wm deiconify $t
	raise $t
	grab $t
	focus $t.data
	vwait ::tkcon::PRIV(grab)
	grab release $t
	wm withdraw $t
	set disp [$t.data get]
	if {$disp == &#34;&#34;} { return }
	regsub -all {\.} [string tolower $disp] ! dt
	set dt $PRIV(base).$dt
	destroy $dt
	if {[catch {
	    <a name="toplevel(8)"><a href="./tkcon.tcl.html#toplevel_5837">toplevel</a></a> $dt -screen $disp
	    set interps [winfo interps -displayof $dt]
	    if {![llength $interps]} {
		error &#34;No other Tk interpreters on $disp&#34;
	    }
	    <a name="::send::send(3)"><a href="./tkcon.tcl.html#::send::send_6186">::send::send</a></a> -displayof $dt [lindex $interps 0] [list info tclversion]
	} err]} {
	    global env
	    if {[info exists env(DISPLAY)]} {
		set myd $env(DISPLAY)
	    } else {
		set myd &#34;myDisplay:0&#34;
	    }
	    tk_messageBox -title &#34;Display Connection Error&#34; \
		    -message &#34;Unable to connect to \&#34;$disp\&#34;:\n$err\
		    \nMake sure you have xauth-based permissions\
		    (xauth add $myd . `mcookie`), and xhost is disabled\
		    (xhost -) on \&#34;$disp\&#34;&#34; \
		    -icon error -type ok
	    destroy $dt
	    return
	}
	set DISP($disp) $dt
	wm withdraw $dt
	bind $dt &lt;Destroy&gt; [subst {catch {unset ::tkcon::DISP($disp)}}]
	tk_messageBox -title &#34;$disp Connection&#34; \
		-message &#34;Connected to \&#34;$disp\&#34;, found:\n[join $interps \n]&#34; \
		-type ok
    }

    <font color="#208020">##</font>
    <font color="#208020">## The following state checkpoint/revert procedures are very sketchy</font>
    <font color="#208020">## and prone to problems.  They do not track modifications to currently</font>
    <font color="#208020">## existing procedures/variables, and they can really screw things up</font>
    <font color="#208020">## if you load in libraries (especially Tk) between checkpoint and</font>
    <font color="#208020">## revert.  Only with this knowledge in mind should you use these.</font>
    <font color="#208020">##</font>

    <font color="#208020">## ::tkcon::StateCheckpoint - checkpoints the current state of the system</font>
    <font color="#208020">## This allows you to return to this state with ::tkcon::StateRevert</font>
    <font color="#208020"># ARGS:</font>
    <font color="#208020">##</font>
    <strong><a name="::tkcon::StateCheckpoint_2676">proc <a href="tkcon.tcl-annot.html#::tkcon::StateCheckpoint">::tkcon::StateCheckpoint</a></a></strong><a name="::tkcon::StateCheckpoint"></a> {app type} {
	variable CPS
	variable PRIV

	if {[info exists CPS($type,$app,cmd)] &amp;&amp; \
		[tk_dialog $PRIV(base).warning &#34;Overwrite Previous State?&#34; \
		&#34;Are you sure you want to lose previously checkpointed\
		state of $type \&#34;$app\&#34;?&#34; questhead 1 &#34;Do It&#34; &#34;Cancel&#34;]} return
	set CPS($type,$app,cmd) [EvalOther $app $type info commands *]
	set CPS($type,$app,var) [EvalOther $app $type info vars *]
	return
    }

    <font color="#208020">## ::tkcon::StateCompare - compare two states and output difference</font>
    <font color="#208020"># ARGS:</font>
    <font color="#208020">##</font>
    <strong><a name="::tkcon::StateCompare_2692">proc <a href="tkcon.tcl-annot.html#::tkcon::StateCompare">::tkcon::StateCompare</a></a></strong><a name="::tkcon::StateCompare"></a> {app type {verbose 0}} {
	variable CPS
	variable PRIV
	variable OPT
	variable COLOR

	if {![info exists CPS($type,$app,cmd)]} {
	    return -code error \
		    &#34;No previously checkpointed state for $type \&#34;$app\&#34;&#34;
	}
	set w $PRIV(base).compare
	if {[winfo exists $w]} {
	    $w.text config -state normal
	    $w.text delete 1.0 end
	} else {
	    <a name="toplevel(9)"><a href="./tkcon.tcl.html#toplevel_5837">toplevel</a></a> $w
	    frame $w.btn
	    scrollbar $w.sy -command [list $w.text yview]
	    text $w.text -yscrollcommand [list $w.sy set] -height 12 \
		    -foreground $COLOR(stdin) \
		    -background $COLOR(bg) \
		    -insertbackground $COLOR(cursor) \
		    -font $OPT(font)
	    pack $w.btn -side bottom -fill x
	    pack $w.sy -side right -fill y
	    pack $w.text -fill both -expand 1
	    button $w.btn.close -text &#34;Dismiss&#34; -width 11 \
		    -command [list destroy $w]
	    button $w.btn.check  -text &#34;Recheckpoint&#34; -width 11
	    button $w.btn.revert -text &#34;Revert&#34; -width 11
	    button $w.btn.expand -text &#34;Verbose&#34; -width 11
	    button $w.btn.update -text &#34;Update&#34; -width 11
	    pack $w.btn.check $w.btn.revert $w.btn.expand $w.btn.update \
		    $w.btn.close -side left -fill x -padx 4 -pady 2 -expand 1
	    $w.text tag config red -foreground red
	}
	wm title $w &#34;Compare State: $type [list $app]&#34;

	$w.btn.check config \
		-command &#34;::tkcon::StateCheckpoint [list $app] $type; \
		::tkcon::StateCompare [list $app] $type $verbose&#34;
	$w.btn.revert config \
		-command &#34;::tkcon::StateRevert [list $app] $type; \
		::tkcon::StateCompare [list $app] $type $verbose&#34;
	$w.btn.update config -command [info level 0]
	if {$verbose} {
	    $w.btn.expand config -text Brief \
		    -command [list ::tkcon::StateCompare $app $type 0]
	} else {
	    $w.btn.expand config -text Verbose \
		    -command [list ::tkcon::StateCompare $app $type 1]
	}
	<font color="#208020">## Don't allow verbose mode unless 'dump' exists in $app</font>
	<font color="#208020">## We're assuming this is tkcon's dump command</font>
	set hasdump [llength [EvalOther $app $type info commands dump]]
	if {$hasdump} {
	    $w.btn.expand config -state normal
	} else {
	    $w.btn.expand config -state disabled
	}

	set cmds [<a name="lremove(8)"><a href="./tkcon.tcl.html#lremove_4738">lremove</a></a> [EvalOther $app $type info commands *] \
		$CPS($type,$app,cmd)]
	set vars [<a name="lremove(9)"><a href="./tkcon.tcl.html#lremove_4738">lremove</a></a> [EvalOther $app $type info vars *] \
		$CPS($type,$app,var)]

	if {$hasdump &amp;&amp; $verbose} {
	    set cmds [EvalOther $app $type eval dump c -nocomplain $cmds]
	    set vars [EvalOther $app $type eval dump v -nocomplain $vars]
	}
	$w.text insert 1.0 &#34;NEW COMMANDS IN \&#34;$app\&#34;:\n&#34; red \
		$cmds {} &#34;\n\nNEW VARIABLES IN \&#34;$app\&#34;:\n&#34; red $vars {}

	raise $w
	$w.text config -state disabled
    }

    <font color="#208020">## ::tkcon::StateRevert - reverts interpreter to previous state</font>
    <font color="#208020"># ARGS:</font>
    <font color="#208020">##</font>
    <strong><a name="::tkcon::StateRevert_2772">proc <a href="tkcon.tcl-annot.html#::tkcon::StateRevert">::tkcon::StateRevert</a></a></strong><a name="::tkcon::StateRevert"></a> {app type} {
	variable CPS
	variable PRIV

	if {![info exists CPS($type,$app,cmd)]} {
	    return -code error \
		    &#34;No previously checkpointed state for $type \&#34;$app\&#34;&#34;
	}
	if {![tk_dialog $PRIV(base).warning &#34;Revert State?&#34; \
		&#34;Are you sure you want to revert the state in $type \&#34;$app\&#34;?&#34;\
		questhead 1 &#34;Do It&#34; &#34;Cancel&#34;]} {
	    foreach i [<a name="lremove(10)"><a href="./tkcon.tcl.html#lremove_4738">lremove</a></a> [EvalOther $app $type info commands *] \
		    $CPS($type,$app,cmd)] {
		catch {EvalOther $app $type rename $i {}}
	    }
	    foreach i [<a name="lremove(11)"><a href="./tkcon.tcl.html#lremove_4738">lremove</a></a> [EvalOther $app $type info vars *] \
		    $CPS($type,$app,var)] {
		catch {EvalOther $app $type unset $i}
	    }
	}
    }

    <font color="#208020">## ::tkcon::StateCleanup - cleans up state information in master array</font>
    <font color="#208020">#</font>
    <font color="#208020">##</font>
    <strong><a name="::tkcon::StateCleanup_2797">proc <a href="tkcon.tcl-annot.html#::tkcon::StateCleanup">::tkcon::StateCleanup</a></a></strong><a name="::tkcon::StateCleanup"></a> {args} {
	variable CPS

	if {![llength $args]} {
	    foreach state [array names CPS slave,*] {
		if {![interp exists [string range $state 6 end]]} {
		    unset CPS($state)
		}
	    }
	} else {
	    set app  [lindex $args 0]
	    set type [lindex $args 1]
	    if {[regexp {^(|slave)$} $type]} {
		foreach state [array names CPS &#34;slave,$app\[, \]*&#34;] {
		    if {![interp exists [string range $state 6 end]]} {
			unset CPS($state)
		    }
		}
	    } else {
		catch {unset CPS($type,$app)}
	    }
	}
    }
}

<font color="#208020">## ::tkcon::Event - get history event, search if string != {}</font>
<font color="#208020">## look forward (next) if $int&gt;0, otherwise look back (prev)</font>
<font color="#208020"># ARGS:	W	- console widget</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::Event_2826">proc <a href="tkcon.tcl-annot.html#::tkcon::Event">::tkcon::Event</a></a></strong><a name="::tkcon::Event"></a> {int {str {}}} {
    if {!$int} return

    variable PRIV
    set w $PRIV(console)

    set nextid [EvalSlave history nextid]
    if {[string compare {} $str]} {
	<font color="#208020">## String is not empty, do an event search</font>
	set event $PRIV(event)
	if {$int &lt; 0 &amp;&amp; $event == $nextid} { set PRIV(cmdbuf) $str }
	set len [string len $PRIV(cmdbuf)]
	incr len -1
	if {$int &gt; 0} {
	    <font color="#208020">## Search history forward</font>
	    while {$event &lt; $nextid} {
		if {[incr event] == $nextid} {
		    $w delete limit end
		    $w insert limit $PRIV(cmdbuf)
		    break
		} elseif {
		    ![catch {EvalSlave history event $event} res] &amp;&amp;
		    [set p [string first $PRIV(cmdbuf) $res]] &gt; -1
		} {
		    set p2 [expr {$p + [string length $PRIV(cmdbuf)]}]
		    $w delete limit end
		    $w insert limit $res
		    Blink $w &#34;limit + $p c&#34; &#34;limit + $p2 c&#34;
		    break
		}
	    }
	    set PRIV(event) $event
	} else {
	    <font color="#208020">## Search history reverse</font>
	    while {![catch {EvalSlave history event [incr event -1]} res]} {
		if {[set p [string first $PRIV(cmdbuf) $res]] &gt; -1} {
		    set p2 [expr {$p + [string length $PRIV(cmdbuf)]}]
		    $w delete limit end
		    $w insert limit $res
		    set PRIV(event) $event
		    Blink $w &#34;limit + $p c&#34; &#34;limit + $p2 c&#34;
		    break
		}
	    }
	}
    } else {
	<font color="#208020">## String is empty, just get next/prev event</font>
	if {$int &gt; 0} {
	    <font color="#208020">## Goto next command in history</font>
	    if {$PRIV(event) &lt; $nextid} {
		$w delete limit end
		if {[incr PRIV(event)] == $nextid} {
		    $w insert limit $PRIV(cmdbuf)
		} else {
		    $w insert limit [EvalSlave history event $PRIV(event)]
		}
	    }
	} else {
	    <font color="#208020">## Goto previous command in history</font>
	    if {$PRIV(event) == $nextid} {
		set PRIV(cmdbuf) [CmdGet $w]
	    }
	    if {[catch {EvalSlave history event [incr PRIV(event) -1]} res]} {
		incr PRIV(event)
	    } else {
		$w delete limit end
		$w insert limit $res
	    }
	}
    }
    $w mark set insert end
    $w see end
}

<font color="#208020">## ::tkcon::Highlight - magic highlighting</font>
<font color="#208020">## beware: voodoo included</font>
<font color="#208020"># ARGS:</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::Highlight_2904">proc <a href="tkcon.tcl-annot.html#::tkcon::Highlight">::tkcon::Highlight</a></a></strong><a name="::tkcon::Highlight"></a> {w type} {
    variable COLOR
    variable OPT

    switch -exact $type {
	&#34;error&#34; { HighlightError $w }
	&#34;tcl&#34; - &#34;test&#34; {
	    if {[winfo class $w] != &#34;Ctext&#34;} { return }

	    foreach {app type} [<a name="tkcon(3)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> attach] {break}
	    set cmds [<a name="::tkcon::EvalOther(3)"><a href="./tkcon.tcl.html#::tkcon::EvalOther_1038">::tkcon::EvalOther</a></a> $app $type info commands]

	    set classes [list \
		 [list comment ClassForRegexp &#34;^\\s*#\[^\n\]*&#34; $COLOR(stderr)] \
		 [list var     ClassWithOnlyCharStart &#34;\$&#34; $COLOR(stdout)] \
		 [list syntax  ClassForSpecialChars &#34;\[\]{}\&#34;&#34; $COLOR(prompt)] \
		 [list command Class $cmds $COLOR(proc)] \
		]

	    <font color="#208020"># Remove all highlight classes from a widget</font>
	    ctext::clearHighlightClasses $w
	    foreach class $classes {
		foreach {cname ctype cptn ccol} $class break
		ctext::addHighlight$ctype $w $cname $ccol $cptn
	    }
	    $w highlight 1.0 end
	}
    }
}

<font color="#208020">## ::tkcon::HighlightError - magic error highlighting</font>
<font color="#208020">## beware: voodoo included</font>
<font color="#208020"># ARGS:</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::HighlightError_2938">proc <a href="tkcon.tcl-annot.html#::tkcon::HighlightError">::tkcon::HighlightError</a></a></strong><a name="::tkcon::HighlightError"></a> w {
    variable COLOR
    variable OPT

    <font color="#208020">## do voodoo here</font>
    set app [Attach]
    <font color="#208020"># we have to pull the text out, because text regexps are screwed on \n's.</font>
    set info [$w get 1.0 end-1c]
    <font color="#208020"># Check for specific line error in a proc</font>
    set exp(proc) &#34;\&#34;(\[^\&#34;\]+)\&#34;\n\[\t \]+\\\(procedure \&#34;(\[^\&#34;\]+)\&#34;&#34;
    <font color="#208020"># Check for too few args to a proc</font>
    set exp(param) &#34;parameter \&#34;(\[^\&#34;\]+)\&#34; to \&#34;(\[^\&#34;\]+)\&#34;&#34;
    set start 1.0
    while {
	[regexp -indices -- $exp(proc) $info junk what cmd] ||
	[regexp -indices -- $exp(param) $info junk what cmd]
    } {
	foreach {w0 w1} $what {c0 c1} $cmd {break}
	set what [string range $info $w0 $w1]
	set cmd  [string range $info $c0 $c1]
	if {[string match *::* $cmd]} {
	    set res [uplevel 1 ::tkcon::EvalOther $app namespace eval \
		    [list [namespace qualifiers $cmd] \
		    [list info procs [namespace tail $cmd]]]]
	} else {
	    set res [uplevel 1 ::tkcon::EvalOther $app info procs [list $cmd]]
	}
	if {[llength $res]==1} {
	    set tag [UniqueTag $w]
	    $w tag add $tag $start+${c0}c $start+1c+${c1}c
	    $w tag configure $tag -foreground $COLOR(stdout)
	    $w tag bind $tag &lt;Enter&gt; [list $w tag configure $tag -under 1]
	    $w tag bind $tag &lt;Leave&gt; [list $w tag configure $tag -under 0]
	    $w tag bind $tag &lt;ButtonRelease-1&gt; &#34;if {!\$tkPriv(mouseMoved)} \
		    {[list $OPT(edit) -attach $app -type proc -find $what -- $cmd]}&#34;
	}
	set info [string range $info $c1 end]
	set start [$w index $start+${c1}c]
    }
    <font color="#208020">## Next stage, check for procs that start a line</font>
    set start 1.0
    set exp(cmd) &#34;^\&#34;\[^\&#34; \t\n\]+&#34;
    while {
	[string compare {} [set ix \
		[$w search -regexp -count numc -- $exp(cmd) $start end]]]
    } {
	set start [$w index $ix+${numc}c]
	<font color="#208020"># +1c to avoid the first quote</font>
	set cmd [$w get $ix+1c $start]
	if {[string match *::* $cmd]} {
	    set res [uplevel 1 ::tkcon::EvalOther $app namespace eval \
		    [list [namespace qualifiers $cmd] \
		    [list info procs [namespace tail $cmd]]]]
	} else {
	    set res [uplevel 1 ::tkcon::EvalOther $app info procs [list $cmd]]
	}
	if {[llength $res]==1} {
	    set tag [UniqueTag $w]
	    $w tag add $tag $ix+1c $start
	    $w tag configure $tag -foreground $COLOR(proc)
	    $w tag bind $tag &lt;Enter&gt; [list $w tag configure $tag -under 1]
	    $w tag bind $tag &lt;Leave&gt; [list $w tag configure $tag -under 0]
	    $w tag bind $tag &lt;ButtonRelease-1&gt; &#34;if {!\$tkPriv(mouseMoved)} \
		    {[list $OPT(edit) -attach $app -type proc -- $cmd]}&#34;
	}
    }
}

<strong><a name="::tkcon::ExpectInit_3006">proc <a href="tkcon.tcl-annot.html#::tkcon::ExpectInit">::tkcon::ExpectInit</a></a></strong><a name="::tkcon::ExpectInit"></a> {{termcap 1} {terminfo 1}} {
    global env

    if {$termcap} {
	set env(TERM) &#34;tt&#34;
	set env(TERMCAP) {tt:
 :ks=\E[KS:
 :ke=\EKE:
 :cm=\E%d;%dH:
 :up=\EA:
 :nd=\EC:
 :cl=\EH\EJ:
 :do=^J:
 :so=\E7m:
 :se=\Em:
 :k1=\EOP:
 :k2=\EOQ:
 :k3=\EOR:
 :k4=\EOS:
 :k5=\EOT:
 :k6=\EOU:
 :k7=\EOV:
 :k8=\EOW:
 :k9=\EOX:
    }
    }

    if {$terminfo} {
	set env(TERM) &#34;tkterm&#34;
	if {![info exists env(TEMP)]} { set env(TEMP) /tmp }
	set env(TERMINFO) $env(TEMP)

	set ttsrc [file join $env(TEMP) tt.src]
	set file [open $ttsrc w]
	puts $file {tkterm|Don Libes' tk text widget terminal emulator,
 smkx=\E[KS,
 rmkx=\EKE,
 cup=\E%p1%d;%p2%dH,
 cuu1=\EA,
 cuf1=\EC,
 clear=\EH\EJ,
 ind=\n,
 cr=\r,
 smso=\E7m,
 rmso=\Em,
 kf1=\EOP,
 kf2=\EOQ,
 kf3=\EOR,
 kf4=\EOS,
 kf5=\EOT,
 kf6=\EOU,
 kf7=\EOV,
 kf8=\EOW,
 kf9=\EOX,
    }
	close $file

	if {[catch {exec tic $ttsrc} msg]} {
	    return -code error \
		&#34;tic failed, you may not have terminfo support:\n$msg&#34;
	}

	file delete $ttsrc
    }
}

<font color="#208020"># term_exit is called if the spawned process exits</font>
<strong><a name="::tkcon::term_exit_3073">proc <a href="tkcon.tcl-annot.html#::tkcon::term_exit">::tkcon::term_exit</a></a></strong><a name="::tkcon::term_exit"></a> {w} {
    variable EXP
    catch {exp_close -i $EXP(spawn_id)}
    set EXP(forever) 1
    unset EXP
}

<font color="#208020"># term_chars_changed is called after every change to the displayed chars</font>
<font color="#208020"># You can use if you want matches to occur in the background (a la bind)</font>
<font color="#208020"># If you want to test synchronously, then just do so - you don't need to</font>
<font color="#208020"># redefine this procedure.</font>
<strong><a name="::tkcon::term_chars_changed_3084">proc <a href="tkcon.tcl-annot.html#::tkcon::term_chars_changed">::tkcon::term_chars_changed</a></a></strong><a name="::tkcon::term_chars_changed"></a> {w args} {
}

<font color="#208020"># term_cursor_changed is called after the cursor is moved</font>
<strong><a name="::tkcon::term_cursor_changed_3088">proc <a href="tkcon.tcl-annot.html#::tkcon::term_cursor_changed">::tkcon::term_cursor_changed</a></a></strong><a name="::tkcon::term_cursor_changed"></a> {w args} {
}

<strong><a name="::tkcon::term_update_cursor_3091">proc <a href="tkcon.tcl-annot.html#::tkcon::term_update_cursor">::tkcon::term_update_cursor</a></a></strong><a name="::tkcon::term_update_cursor"></a> {w args} {
    variable OPT
    variable EXP

    $w mark set insert $EXP(row).$EXP(col)
    $w see insert
    term_cursor_changed $w
}

<strong><a name="::tkcon::term_clear_3100">proc <a href="tkcon.tcl-annot.html#::tkcon::term_clear">::tkcon::term_clear</a></a></strong><a name="::tkcon::term_clear"></a> {w args} {
    $w delete 1.0 end
    term_init $w
}

<strong><a name="::tkcon::term_init_3105">proc <a href="tkcon.tcl-annot.html#::tkcon::term_init">::tkcon::term_init</a></a></strong><a name="::tkcon::term_init"></a> {w args} {
    variable OPT
    variable EXP

    <font color="#208020"># initialize it with blanks to make insertions later more easily</font>
    set blankline [string repeat &#34; &#34; $OPT(cols)]\n
    for {set i 1} {$i &lt;= $OPT(rows)} {incr i} {
	$w insert $i.0 $blankline
    }

    set EXP(row) 1
    set EXP(col) 0

    $w mark set insert $EXP(row).$EXP(col)
}

<strong><a name="::tkcon::term_down_3121">proc <a href="tkcon.tcl-annot.html#::tkcon::term_down">::tkcon::term_down</a></a></strong><a name="::tkcon::term_down"></a> {w args} {
    variable OPT
    variable EXP

    if {$EXP(row) &lt; $OPT(rows)} {
	incr EXP(row)
    } else {
	<font color="#208020"># already at last line of term, so scroll screen up</font>
	$w delete 1.0 2.0

	<font color="#208020"># recreate line at end</font>
	$w insert end [string repeat &#34; &#34; $OPT(cols)]\n
    }
}

<strong><a name="::tkcon::term_insert_3136">proc <a href="tkcon.tcl-annot.html#::tkcon::term_insert">::tkcon::term_insert</a></a></strong><a name="::tkcon::term_insert"></a> {w s} {
    variable OPT
    variable EXP

    set chars_rem_to_write [string length $s]
    set space_rem_on_line  [expr {$OPT(cols) - $EXP(col)}]

    set tag_action [expr {$EXP(standout) ? &#34;add&#34; : &#34;remove&#34;}]

    <font color="#208020">##################</font>
    <font color="#208020"># write first line</font>
    <font color="#208020">##################</font>

    if {$chars_rem_to_write &gt; $space_rem_on_line} {
	set chars_to_write $space_rem_on_line
	set newline 1
    } else {
	set chars_to_write $chars_rem_to_write
	set newline 0
    }

    $w delete $EXP(row).$EXP(col) \
	$EXP(row).[expr {$EXP(col) + $chars_to_write}]
    $w insert $EXP(row).$EXP(col) \
	[string range $s 0 [expr {$space_rem_on_line-1}]]

    $w tag $tag_action standout $EXP(row).$EXP(col) \
	$EXP(row).[expr {$EXP(col) + $chars_to_write}]

    <font color="#208020"># discard first line already written</font>
    incr chars_rem_to_write -$chars_to_write
    set s [string range $s $chars_to_write end]

    <font color="#208020"># update EXP(col)</font>
    incr EXP(col) $chars_to_write
    <font color="#208020"># update EXP(row)</font>
    if {$newline} { term_down $w }

    <font color="#208020">##################</font>
    <font color="#208020"># write full lines</font>
    <font color="#208020">##################</font>
    while {$chars_rem_to_write &gt;= $OPT(cols)} {
	$w delete $EXP(row).0 $EXP(row).end
	$w insert $EXP(row).0 [string range $s 0 [expr {$OPT(cols)-1}]]
	$w tag $tag_action standout $EXP(row).0 $EXP(row).end

	<font color="#208020"># discard line from buffer</font>
	set s [string range $s $OPT(cols) end]
	incr chars_rem_to_write -$OPT(cols)

	set EXP(col) 0
	term_down $w
    }

    <font color="#208020">#################</font>
    <font color="#208020"># write last line</font>
    <font color="#208020">#################</font>

    if {$chars_rem_to_write} {
	$w delete $EXP(row).0 $EXP(row).$chars_rem_to_write
	$w insert $EXP(row).0 $s
	$w tag $tag_action standout $EXP(row).0 $EXP(row).$chars_rem_to_write
	set EXP(col) $chars_rem_to_write
    }

    term_chars_changed $w
}

<strong><a name="::tkcon::Expect_3204">proc <a href="tkcon.tcl-annot.html#::tkcon::Expect">::tkcon::Expect</a></a></strong><a name="::tkcon::Expect"></a> {cmd} {
    variable OPT
    variable PRIV
    variable EXP

    set EXP(standout) 0
    set EXP(row) 0
    set EXP(col) 0

    set env(LINES)   $OPT(rows)
    set env(COLUMNS) $OPT(cols)

    ExpectInit
    log_user 0
    set ::stty_init &#34;-tabs&#34;
    uplevel \#0 [linsert $cmd 0 spawn]
    set EXP(spawn_id) $::spawn_id
    if {[info exists ::spawn_out(slave,name)]} {
	set EXP(slave,name) $::spawn_out(slave,name)
	catch {stty rows $OPT(rows) columns $OPT(cols) &lt; $::spawn_out(slave,name)}
    }
    if {[string index $cmd end] == &#34;&amp;&#34;} {
	set cmd expect_background
    } else {
	set cmd expect
    }
    bind $PRIV(console) &lt;Meta-KeyPress&gt; {
	if {&#34;%A&#34; != &#34;&#34;} {
	    exp_send -i $::tkcon::EXP(spawn_id) &#34;\033%A&#34;
	    break
	}
    }
    bind $PRIV(console) &lt;KeyPress&gt; {
	exp_send -i $::tkcon::EXP(spawn_id) -- %A
	break
    }
    bind $PRIV(console) &lt;Control-space&gt;	{exp_send -null}
    set code [catch {
	term_init $PRIV(console)
	while {[info exists EXP(spawn_id)]} {
	$cmd {
	    -i $::tkcon::EXP(spawn_id)
	    -re &#34;^\[^\x01-\x1f\]+&#34; {
		<font color="#208020"># Text</font>
		<a name="::tkcon::term_insert(1)"><a href="./tkcon.tcl.html#::tkcon::term_insert_3136">::tkcon::term_insert</a></a> $::tkcon::PRIV(console) \
		    $expect_out(0,string)
		<a name="::tkcon::term_update_cursor(1)"><a href="./tkcon.tcl.html#::tkcon::term_update_cursor_3091">::tkcon::term_update_cursor</a></a> $::tkcon::PRIV(console)
	    } &#34;^\r&#34; {
		<font color="#208020"># (cr,) Go to beginning of line</font>
		update idle
		set ::tkcon::EXP(col) 0
		<a name="::tkcon::term_update_cursor(2)"><a href="./tkcon.tcl.html#::tkcon::term_update_cursor_3091">::tkcon::term_update_cursor</a></a> $::tkcon::PRIV(console)
	    } &#34;^\n&#34; {
		<font color="#208020"># (ind,do) Move cursor down one line</font>
		if {$::tcl_platform(platform) eq &#34;windows&#34;} {
		    <font color="#208020"># Windows seems to get the LF without the CR</font>
		    update idle
		    set ::tkcon::EXP(col) 0
		}
		<a name="::tkcon::term_down(1)"><a href="./tkcon.tcl.html#::tkcon::term_down_3121">::tkcon::term_down</a></a> $::tkcon::PRIV(console)
		<a name="::tkcon::term_update_cursor(3)"><a href="./tkcon.tcl.html#::tkcon::term_update_cursor_3091">::tkcon::term_update_cursor</a></a> $::tkcon::PRIV(console)
	    } &#34;^\b&#34; {
		<font color="#208020"># Backspace nondestructively</font>
		incr ::tkcon::EXP(col) -1
		<a name="::tkcon::term_update_cursor(4)"><a href="./tkcon.tcl.html#::tkcon::term_update_cursor_3091">::tkcon::term_update_cursor</a></a> $::tkcon::PRIV(console)
	    } &#34;^\a&#34; {
		bell
	    } &#34;^\t&#34; {
		<font color="#208020"># Tab, shouldn't happen</font>
		send_error &#34;got a tab!?&#34;
	    } eof {
		<a name="::tkcon::term_exit(1)"><a href="./tkcon.tcl.html#::tkcon::term_exit_3073">::tkcon::term_exit</a></a> $::tkcon::PRIV(console)
	    } &#34;^\x1b\\\[A&#34; {
		<font color="#208020"># Cursor Up (cuu1,up)</font>
		incr ::tkcon::EXP(row) -1
		<a name="::tkcon::term_update_cursor(5)"><a href="./tkcon.tcl.html#::tkcon::term_update_cursor_3091">::tkcon::term_update_cursor</a></a> $::tkcon::PRIV(console)
	    } &#34;^\x1b\\\[B&#34; {
		<font color="#208020"># Cursor Down</font>
		incr ::tkcon::EXP(row)
		<a name="::tkcon::term_update_cursor(6)"><a href="./tkcon.tcl.html#::tkcon::term_update_cursor_3091">::tkcon::term_update_cursor</a></a> $::tkcon::PRIV(console)
	    } &#34;^\x1b\\\[C&#34; {
		<font color="#208020"># Cursor Right (cuf1,nd)</font>
		incr ::tkcon::EXP(col)
		<a name="::tkcon::term_update_cursor(7)"><a href="./tkcon.tcl.html#::tkcon::term_update_cursor_3091">::tkcon::term_update_cursor</a></a> $::tkcon::PRIV(console)
	    } &#34;^\x1b\\\[D&#34; {
		<font color="#208020"># Cursor Left</font>
		incr ::tkcon::EXP(col)
		<a name="::tkcon::term_update_cursor(8)"><a href="./tkcon.tcl.html#::tkcon::term_update_cursor_3091">::tkcon::term_update_cursor</a></a> $::tkcon::PRIV(console)
	    } &#34;^\x1b\\\[H&#34; {
		<font color="#208020"># Cursor Home</font>
	    } -re &#34;^\x1b\\\[(\[0-9\]*);(\[0-9\]*)H&#34; {
		<font color="#208020"># (cup,cm) Move to row y col x</font>
		set ::tkcon::EXP(row) [expr {$expect_out(1,string)+1}]
		set ::tkcon::EXP(col) $expect_out(2,string)
		<a name="::tkcon::term_update_cursor(9)"><a href="./tkcon.tcl.html#::tkcon::term_update_cursor_3091">::tkcon::term_update_cursor</a></a> $::tkcon::PRIV(console)
	    } &#34;^\x1b\\\[H\x1b\\\[J&#34; {
		<font color="#208020"># (clear,cl) Clear screen</font>
		<a name="::tkcon::term_clear(1)"><a href="./tkcon.tcl.html#::tkcon::term_clear_3100">::tkcon::term_clear</a></a> $::tkcon::PRIV(console)
		<a name="::tkcon::term_update_cursor(10)"><a href="./tkcon.tcl.html#::tkcon::term_update_cursor_3091">::tkcon::term_update_cursor</a></a> $::tkcon::PRIV(console)
	    } &#34;^\x1b\\\[7m&#34; {
		<font color="#208020"># (smso,so) Begin standout mode</font>
		set ::tkcon::EXP(standout) 1
	    } &#34;^\x1b\\\[m&#34; {
		<font color="#208020"># (rmso,se) End standout mode</font>
		set ::tkcon::EXP(standout) 0
	    } &#34;^\x1b\\\[KS&#34; {
		<font color="#208020"># (smkx,ks) start keyboard-transmit mode</font>
		<font color="#208020"># terminfo invokes these when going in/out of graphics mode</font>
		<font color="#208020"># In graphics mode, we should have no scrollbars</font>
		<font color="#208020">#graphicsSet 1</font>
	    } &#34;^\x1b\\\[KE&#34; {
		<font color="#208020"># (rmkx,ke) end keyboard-transmit mode</font>
		<font color="#208020"># Out of graphics mode, we should have scrollbars</font>
		<font color="#208020">#graphicsSet 0</font>
	    }
	}
	}
	<font color="#208020">#vwait ::tkcon::EXP(forever)</font>
    } err]
    bind $PRIV(console) &lt;Meta-KeyPress&gt; {}
    bind $PRIV(console) &lt;KeyPress&gt;      {}
    bind $PRIV(console) &lt;Control-space&gt;	{}
    catch {unset EXP}
    if {$code} {
	return -code $code -errorinfo $::errorInfo $err
    }
}

<font color="#208020">## tkcon - command that allows control over the console</font>
<font color="#208020">## This always exists in the main interpreter, and is aliased into</font>
<font color="#208020">## other connected interpreters</font>
<font color="#208020"># ARGS:	totally variable, see internal comments</font>
<font color="#208020">## </font>
<strong><a name="tkcon_3337">proc <a href="tkcon.tcl-annot.html#tkcon">tkcon</a></a></strong><a name="tkcon"></a> {cmd args} {
    variable ::tkcon::PRIV
    variable ::tkcon::OPT
    global errorInfo

    switch -glob -- $cmd {
	buf* {
	    <font color="#208020">## 'buffer' Sets/Query the buffer size</font>
	    if {[llength $args]} {
		if {[regexp {^[1-9][0-9]*$} $args]} {
		    set OPT(buffer) $args
		    <font color="#208020"># catch in case the console doesn't exist yet</font>
		    catch {<a name="::tkcon::ConstrainBuffer(1)"><a href="./tkcon.tcl.html#::tkcon::ConstrainBuffer_1299">::tkcon::ConstrainBuffer</a></a> $PRIV(console) \
			    $OPT(buffer)}
		} else {
		    return -code error &#34;buffer must be a valid integer&#34;
		}
	    }
	    return $OPT(buffer)
	}
	linelen* {
	    <font color="#208020">## 'linelength' Sets/Query the maximum line length</font>
	    if {[llength $args]} {
		if {[regexp {^-?[0-9]+$} $args]} {
		    set OPT(maxlinelen) $args
		} else {
		    return -code error &#34;buffer must be a valid integer&#34;
		}
	    }
	    return $OPT(maxlinelen)
	}
	bg* {
	    <font color="#208020">## 'bgerror' Brings up an error dialog</font>
	    set errorInfo [lindex $args 1]
	    <a name="bgerror(2)"><a href="./tkcon.tcl.html#bgerror_512">bgerror</a></a> [lindex $args 0]
	}
	cl* {
	    <font color="#208020">## 'close' Closes the console</font>
	    <a name="::tkcon::Destroy(1)"><a href="./tkcon.tcl.html#::tkcon::Destroy_2485">::tkcon::Destroy</a></a>
	}
	cons* {
	    <font color="#208020">## 'console' - passes the args to the text widget of the console.</font>
	    set result [uplevel 1 $PRIV(console) $args]
	    <a name="::tkcon::ConstrainBuffer(2)"><a href="./tkcon.tcl.html#::tkcon::ConstrainBuffer_1299">::tkcon::ConstrainBuffer</a></a> $PRIV(console) \
		    $OPT(buffer)
	    return $result
	}
	congets {
	    <font color="#208020">## 'congets' a replacement for [gets stdin]</font>
	    <font color="#208020"># Use the 'gets' alias of 'tkcon_gets' command instead of</font>
	    <font color="#208020"># calling the *get* methods directly for best compatability</font>
	    if {[llength $args]} {
		return -code error &#34;wrong # args: must be \&#34;tkcon congets\&#34;&#34;
	    }
	    <a name="tkcon(4)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> show
	    set old [bind TkConsole &lt;&lt;TkCon_Eval&gt;&gt;]
	    bind TkConsole &lt;&lt;TkCon_Eval&gt;&gt; { set ::tkcon::PRIV(wait) 0 }
	    set w $PRIV(console)
	    <font color="#208020"># Make sure to move the limit to get the right data</font>
	    $w mark set limit end-1c
	    $w mark gravity limit left
	    $w mark set insert end
	    $w see end
	    vwait ::tkcon::PRIV(wait)
	    set line [<a name="::tkcon::CmdGet(6)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> $w]
	    $w insert end \n
	    bind TkConsole &lt;&lt;TkCon_Eval&gt;&gt; $old
	    return $line
	}
	exp* {
	    <a name="::tkcon::Expect(1)"><a href="./tkcon.tcl.html#::tkcon::Expect_3204">::tkcon::Expect</a></a> [lindex $args 0]
	}
	getc* {
	    <font color="#208020">## 'getcommand' a replacement for [gets stdin]</font>
	    <font color="#208020">## This forces a complete command to be input though</font>
	    if {[llength $args]} {
		return -code error &#34;wrong # args: must be \&#34;tkcon getcommand\&#34;&#34;
	    }
	    <a name="tkcon(5)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> show
	    set old [bind TkConsole &lt;&lt;TkCon_Eval&gt;&gt;]
	    bind TkConsole &lt;&lt;TkCon_Eval&gt;&gt; { set ::tkcon::PRIV(wait) 0 }
	    set w $PRIV(console)
	    <font color="#208020"># Make sure to move the limit to get the right data</font>
	    $w mark set insert end
	    $w mark set limit insert
	    $w see end
	    vwait ::tkcon::PRIV(wait)
	    set line [<a name="::tkcon::CmdGet(7)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> $w]
	    $w insert end \n
	    while {![info complete $line] || [regexp {[^\\]\\$} $line]} {
		vwait ::tkcon::PRIV(wait)
		set line [<a name="::tkcon::CmdGet(8)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> $w]
		$w insert end \n
		$w see end
	    }
	    bind TkConsole &lt;&lt;TkCon_Eval&gt;&gt; $old
	    return $line
	}
	get - gets {
	    <font color="#208020">## 'gets' - a replacement for [gets stdin]</font>
	    <font color="#208020">## This pops up a text widget to be used for stdin (local grabbed)</font>
	    if {[llength $args]} {
		return -code error &#34;wrong # args: should be \&#34;tkcon gets\&#34;&#34;
	    }
	    set t $PRIV(base).gets
	    if {![winfo exists $t]} {
		<a name="toplevel(10)"><a href="./tkcon.tcl.html#toplevel_5837">toplevel</a></a> $t
		wm withdraw $t
		wm title $t &#34;tkcon gets stdin request&#34;
		label $t.gets -text &#34;\&#34;gets stdin\&#34; request:&#34;
		text $t.data -width 32 -height 5 -wrap none \
			-xscrollcommand [list $t.sx set] \
			-yscrollcommand [list $t.sy set]
		scrollbar $t.sx -orient h -takefocus 0 -highlightthick 0 \
			-command [list $t.data xview]
		scrollbar $t.sy -orient v -takefocus 0 -highlightthick 0 \
			-command [list $t.data yview]
		button $t.ok -text &#34;OK&#34; -command {set ::tkcon::PRIV(grab) 1}
		bind $t.ok &lt;Return&gt; { %W invoke }
		grid $t.gets -		-sticky ew
		grid $t.data $t.sy	-sticky news
		grid $t.sx		-sticky ew
		grid $t.ok   -		-sticky ew
		grid columnconfig $t 0 -weight 1
		grid rowconfig    $t 1 -weight 1
		wm transient $t $PRIV(root)
		wm geometry $t +[expr {([winfo screenwidth $t]-[winfo \
			reqwidth $t]) / 2}]+[expr {([winfo \
			screenheight $t]-[winfo reqheight $t]) / 2}]
	    }
	    $t.data delete 1.0 end
	    wm deiconify $t
	    raise $t
	    grab $t
	    focus $t.data
	    vwait ::tkcon::PRIV(grab)
	    grab release $t
	    wm withdraw $t
	    return [$t.data get 1.0 end-1c]
	}
	err* {
	    <font color="#208020">## Outputs stack caused by last error.</font>
	    <font color="#208020">## error handling with pizazz (but with pizza would be nice too)</font>
	    if {[llength $args]==2} {
		set app  [lindex $args 0]
		set type [lindex $args 1]
		if {[catch {<a name="::tkcon::EvalOther(4)"><a href="./tkcon.tcl.html#::tkcon::EvalOther_1038">::tkcon::EvalOther</a></a> $app $type set errorInfo} info]} {
		    set info &#34;error getting info from $type $app:\n$info&#34;
		}
	    } else {
		set info $PRIV(errorInfo)
	    }
	    if {[string match {} $info]} { set info &#34;errorInfo empty&#34; }
	    <font color="#208020">## If args is empty, the -attach switch just ignores it</font>
	    $OPT(edit) -attach $args -type error -- $info
	}
	fi* {
	    <font color="#208020">## 'find' string</font>
	    <a name="::tkcon::Find(1)"><a href="./tkcon.tcl.html#::tkcon::Find_2045">::tkcon::Find</a></a> $PRIV(console) $args
	}
	fo* {
	    <font color="#208020">## 'font' ?fontname? - gets/sets the font of the console</font>
	    if {[llength $args]} {
		if {[info exists PRIV(console)] &amp;&amp; \
			[winfo exists $PRIV(console)]} {
		    $PRIV(console) config -font $args
		    set OPT(font) [$PRIV(console) cget -font]
		} else {
		    set OPT(font) $args
		}
	    }
	    return $OPT(font)
	}
	hid* - with* {
	    <font color="#208020">## 'hide' 'withdraw' - hides the console.</font>
	    if {[info exists PRIV(root)] &amp;&amp; [winfo exists $PRIV(root)]} {
		wm withdraw $PRIV(root)
	    }
	}
	his* {
	    <font color="#208020">## 'history'</font>
	    set sub {\2}
	    if {[string match -new* $args]} { append sub &#34;\n&#34;}
	    set h [<a name="::tkcon::EvalSlave(3)"><a href="./tkcon.tcl.html#::tkcon::EvalSlave_1029">::tkcon::EvalSlave</a></a> history]
	    regsub -all &#34;( *\[0-9\]+  |\t)(\[^\n\]*\n?)&#34; $h $sub h
	    return $h
	}
	ico* {
	    <font color="#208020">## 'iconify' - iconifies the console with 'iconify'.</font>
	    if {[info exists PRIV(root)] &amp;&amp; [winfo exists $PRIV(root)]} {
		wm iconify $PRIV(root)
	    }
	}
	mas* - eval {
	    <font color="#208020">## 'master' - evals contents in master interpreter</font>
	    uplevel \#0 $args
	}
	set {
	    <font color="#208020">## 'set' - set (or get, or unset) simple vars (not whole arrays)</font>
	    <font color="#208020">## from the master console interpreter</font>
	    <font color="#208020">## possible formats:</font>
	    <font color="#208020">##    tkcon set &lt;var&gt;</font>
	    <font color="#208020">##    tkcon set &lt;var&gt; &lt;value&gt;</font>
	    <font color="#208020">##    tkcon set &lt;var&gt; &lt;interp&gt; &lt;var1&gt; &lt;var2&gt; w</font>
	    <font color="#208020">##    tkcon set &lt;var&gt; &lt;interp&gt; &lt;var1&gt; &lt;var2&gt; u</font>
	    <font color="#208020">##    tkcon set &lt;var&gt; &lt;interp&gt; &lt;var1&gt; &lt;var2&gt; r</font>
	    if {[llength $args]==5} {
		<font color="#208020">## This is for use w/ 'tkcon upvar' and only works with slaves</font>
		foreach {var i var1 var2 op} $args break
		if {[string compare {} $var2]} { append var1 &#34;($var2)&#34; }
		switch $op {
		    u { uplevel \#0 [list unset $var] }
		    w {
			return [uplevel \#0 [list set $var \
				[interp eval $i [list set $var1]]]]
		    }
		    r {
			return [interp eval $i [list set $var1 \
				[uplevel \#0 [list set $var]]]]
		    }
		}
	    } elseif {[llength $args] == 1} {
		upvar \#0 [lindex $args 0] var
		if {[array exists var]} {
		    return [array get var]
		} else {
		    return $var
		}
	    }
	    return [uplevel \#0 set $args]
	}
	append {
	    <font color="#208020">## Modify a var in the master environment using append</font>
	    return [uplevel \#0 append $args]
	}
	lappend {
	    <font color="#208020">## Modify a var in the master environment using lappend</font>
	    return [uplevel \#0 lappend $args]
	}
	sh* - dei* {
	    <font color="#208020">## 'show|deiconify' - deiconifies the console.</font>
	    if {![info exists PRIV(root)]} {
		<font color="#208020"># We are likely in some embedded console configuration.</font>
		<font color="#208020"># Make default setup reflect that.</font>
		set PRIV(showOnStartup) 0
		set PRIV(protocol) {<a name="tkcon(6)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> hide}
		set PRIV(root) .tkcon
		set OPT(exec) &#34;&#34;
	    }
	    if {![winfo exists $PRIV(root)]} {
		<a name="::tkcon::Init(1)"><a href="./tkcon.tcl.html#::tkcon::Init_95">::tkcon::Init</a></a>
	    }
	    wm deiconify $PRIV(root)
	    raise $PRIV(root)
	    focus -force $PRIV(console)
	}
	ti* {
	    <font color="#208020">## 'title' ?title? - gets/sets the console's title</font>
	    if {[llength $args]} {
		return [wm title $PRIV(root) [join $args]]
	    } else {
		return [wm title $PRIV(root)]
	    }
	}
	upv* {
	    <font color="#208020">## 'upvar' masterVar slaveVar</font>
	    <font color="#208020">## link slave variable slaveVar to the master variable masterVar</font>
	    <font color="#208020">## only works masters&lt;-&gt;slave</font>
	    set masterVar [lindex $args 0]
	    set slaveVar  [lindex $args 1]
	    if {[info exists $masterVar]} {
		interp eval $OPT(exec) \
			[list set $slaveVar [set $masterVar]]
	    } else {
		catch {interp eval $OPT(exec) [list unset $slaveVar]}
	    }
	    interp eval $OPT(exec) \
		    [list trace variable $slaveVar rwu \
		    [list tkcon set $masterVar $OPT(exec)]]
	    return
	}
	v* {
	    return $PRIV(version)
	}
	default {
	    <font color="#208020">## tries to determine if the command exists, otherwise throws error</font>
	    set new ::tkcon::[string toupper \
		    [string index $cmd 0]][string range $cmd 1 end]
	    if {[llength [info command $new]]} {
		uplevel \#0 $new $args
	    } else {
		return -code error &#34;bad option \&#34;$cmd\&#34;: must be\
			[join [lsort [list attach close console destroy \
			font hide iconify load main master new save show \
			slave deiconify version title bgerror]] {, }]&#34;
	    }
	}
    }
}

<font color="#208020">##</font>
<font color="#208020">## Some procedures to make up for lack of built-in shell commands</font>
<font color="#208020">##</font>

<font color="#208020">## tkcon_puts -</font>
<font color="#208020">## This allows me to capture all stdout/stderr to the console window</font>
<font color="#208020">## This will be renamed to 'puts' at the appropriate time during init</font>
<font color="#208020">##</font>
<font color="#208020"># ARGS:	same as usual	</font>
<font color="#208020"># Outputs:	the string with a color-coded text tag</font>
<font color="#208020">## </font>
<strong><a name="tkcon_puts_3648">proc <a href="tkcon.tcl-annot.html#tkcon_puts">tkcon_puts</a></a></strong><a name="tkcon_puts"></a> args {
    set len [llength $args]
    foreach {arg1 arg2 arg3} $args { break }

    if {$len == 1} {
	<a name="tkcon(7)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> console insert output &#34;$arg1\n&#34; stdout
    } elseif {$len == 2} {
	if {![string compare $arg1 -nonewline]} {
	    <a name="tkcon(8)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> console insert output $arg2 stdout
	} elseif {![string compare $arg1 stdout] \
		|| ![string compare $arg1 stderr]} {
	    <a name="tkcon(9)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> console insert output &#34;$arg2\n&#34; $arg1
	} else {
	    set len 0
	}
    } elseif {$len == 3} {
	if {![string compare $arg1 -nonewline] \
		&amp;&amp; (![string compare $arg2 stdout] \
		|| ![string compare $arg2 stderr])} {
	    <a name="tkcon(10)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> console insert output $arg3 $arg2
	} elseif {(![string compare $arg1 stdout] \
		|| ![string compare $arg1 stderr]) \
		&amp;&amp; ![string compare $arg3 nonewline]} {
	    <a name="tkcon(11)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> console insert output $arg2 $arg1
	} else {
	    set len 0
	}
    } else {
	set len 0
    }

    <font color="#208020">## $len == 0 means it wasn't handled by tkcon above.</font>
    <font color="#208020">##</font>
    if {$len == 0} {
	global errorCode errorInfo
	if {[catch &#34;tkcon_tcl_puts $args&#34; msg]} {
	    regsub tkcon_tcl_puts $msg puts msg
	    regsub -all tkcon_tcl_puts $errorInfo puts errorInfo
	    return -code error $msg
	}
	return $msg
    }

    <font color="#208020">## WARNING: This update should behave well because it uses idletasks,</font>
    <font color="#208020">## however, if there are weird looping problems with events, or</font>
    <font color="#208020">## hanging in waits, try commenting this out.</font>
    if {$len} {
	<a name="tkcon(12)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> console see output
	update idletasks
    }
}

<font color="#208020">## tkcon_gets -</font>
<font color="#208020">## This allows me to capture all stdin input without needing to stdin</font>
<font color="#208020">## This will be renamed to 'gets' at the appropriate time during init</font>
<font color="#208020">##</font>
<font color="#208020"># ARGS:		same as gets	</font>
<font color="#208020"># Outputs:	same as gets</font>
<font color="#208020">##</font>
<strong><a name="tkcon_gets_3707">proc <a href="tkcon.tcl-annot.html#tkcon_gets">tkcon_gets</a></a></strong><a name="tkcon_gets"></a> args {
    set len [llength $args]
    if {$len != 1 &amp;&amp; $len != 2} {
	return -code error \
		&#34;wrong # args: should be \&#34;gets channelId ?varName?\&#34;&#34;
    }
    if {[string compare stdin [lindex $args 0]]} {
	return [uplevel 1 tkcon_tcl_gets $args]
    }
    set gtype [<a name="tkcon(13)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> set ::tkcon::OPT(gets)]
    if {$gtype == &#34;&#34;} { set gtype congets }
    set data [<a name="tkcon(14)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> $gtype]
    if {$len == 2} {
	upvar 1 [lindex $args 1] var
	set var $data
	return [string length $data]
    }
    return $data
}

<font color="#208020">## edit - opens a file/proc/var for reading/editing</font>
<font color="#208020">## </font>
<font color="#208020"># Arguments:</font>
<font color="#208020">#   type	proc/file/var</font>
<font color="#208020">#   what	the actual name of the item</font>
<font color="#208020"># Returns:	nothing</font>
<font color="#208020">## </font>
<strong><a name="edit_3734">proc <a href="tkcon.tcl-annot.html#edit">edit</a></a></strong><a name="edit"></a> {args} {
    array set opts {-find {} -type {} -attach {}}
    while {[string match -* [lindex $args 0]]} {
	switch -glob -- [lindex $args 0] {
	    -f*	{ set opts(-find) [lindex $args 1] }
	    -a*	{ set opts(-attach) [lindex $args 1] }
	    -t*	{ set opts(-type) [lindex $args 1] }
	    --	{ set args [lreplace $args 0 0]; break }
	    default {return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;}
	}
	set args [lreplace $args 0 1]
    }
    <font color="#208020"># determine who we are dealing with</font>
    if {[llength $opts(-attach)]} {
	foreach {app type} $opts(-attach) {break}
    } else {
	foreach {app type} [<a name="tkcon(15)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> attach] {break}
    }

    set word [lindex $args 0]
    if {[string match {} $opts(-type)]} {
	if {[llength [<a name="::tkcon::EvalOther(5)"><a href="./tkcon.tcl.html#::tkcon::EvalOther_1038">::tkcon::EvalOther</a></a> $app $type info commands [list $word]]]} {
	    set opts(-type) &#34;proc&#34;
	} elseif {[llength [<a name="::tkcon::EvalOther(6)"><a href="./tkcon.tcl.html#::tkcon::EvalOther_1038">::tkcon::EvalOther</a></a> $app $type info vars [list $word]]]} {
	    set opts(-type) &#34;var&#34;
	} elseif {[<a name="::tkcon::EvalOther(7)"><a href="./tkcon.tcl.html#::tkcon::EvalOther_1038">::tkcon::EvalOther</a></a> $app $type file isfile [list $word]]} {
	    set opts(-type) &#34;file&#34;
	}
    }
    if {[string compare $opts(-type) {}]} {
	<font color="#208020"># Create unique edit window toplevel</font>
	set w $::tkcon::PRIV(base).__edit
	set i 0
	while {[winfo exists $w[incr i]]} {}
	append w $i
	<a name="toplevel(11)"><a href="./tkcon.tcl.html#toplevel_5837">toplevel</a></a> $w
	wm withdraw $w
	if {[string length $word] &gt; 20} {
	    wm title $w &#34;[string range $word 0 16]... - tkcon Edit&#34;
	} else {
	    wm title $w &#34;$word - tkcon Edit&#34;
	}

	if {[package provide ctext] != &#34;&#34;} {
	    set txt [ctext $w.text]
	} else {
	    set txt [text $w.text]
	}
	$w.text configure -wrap none \
		-xscrollcommand [list $w.sx set] \
		-yscrollcommand [list $w.sy set] \
		-foreground $::tkcon::COLOR(stdin) \
		-background $::tkcon::COLOR(bg) \
		-insertbackground $::tkcon::COLOR(cursor) \
		-font $::tkcon::OPT(font)
	catch {
	    <font color="#208020"># 8.4+ stuff</font>
	    $w.text configure -undo 1
	    if {[<a name="tk(9)"><a href="./tkcon.tcl.html#tk_6296">tk</a></a> windowingsystem] eq &#34;aqua&#34;} {
		$w.text configure -highlightthickness 0
	    }
	}
	scrollbar $w.sx -orient h -command [list $w.text xview]
	scrollbar $w.sy -orient v -command [list $w.text yview]

	set menu [menu $w.mbar]
	$w configure -menu $menu

	<font color="#208020">## File Menu</font>
	<font color="#208020">##</font>
	set m [menu [::tkcon::MenuButton $menu File file]]
	$m add command -label &#34;Save As...&#34;  -underline 0 \
		-command [list ::tkcon::Save {} widget $w.text]
	$m add command -label &#34;Append To...&#34;  -underline 0 \
		-command [list ::tkcon::Save {} widget $w.text a+]
	$m add separator
	$m add command -label &#34;Dismiss&#34; -underline 0 -accel &#34;Ctrl-w&#34; \
		-command [list destroy $w]
	bind $w &lt;Control-w&gt;			[list destroy $w]
	bind $w &lt;$::tkcon::PRIV(meta)-w&gt;	[list destroy $w]

	<font color="#208020">## Edit Menu</font>
	<font color="#208020">##</font>
	set text $w.text
	set m [menu [::tkcon::MenuButton $menu Edit edit]]
	$m add command -label &#34;Cut&#34;   -under 2 \
		-command [list tk_textCut $text]
	$m add command -label &#34;Copy&#34;  -under 0 \
		-command [list tk_textCopy $text]
	$m add command -label &#34;Paste&#34; -under 0 \
		-command [list tk_textPaste $text]
	$m add separator
	$m add command -label &#34;Find&#34; -under 0 \
		-command [list ::tkcon::FindBox $text]

	<font color="#208020">## Send To Menu</font>
	<font color="#208020">##</font>
	set m [menu [::tkcon::MenuButton $menu &#34;Send To...&#34; send]]
	$m add command -label &#34;Send To $app&#34; -underline 0 \
		-command &#34;::tkcon::EvalOther [list $app] $type \
		eval \[$w.text get 1.0 end-1c\]&#34;
	set other [<a name="tkcon(16)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> attach]
	if {[string compare $other [list $app $type]]} {
	    $m add command -label &#34;Send To [lindex $other 0]&#34; \
		    -command &#34;::tkcon::EvalOther $other \
		    eval \[$w.text get 1.0 end-1c\]&#34;
	}

	grid $w.text - $w.sy -sticky news
	grid $w.sx - -sticky ew
	grid columnconfigure $w 0 -weight 1
	grid columnconfigure $w 1 -weight 1
	grid rowconfigure $w 0 -weight 1
    } else {
	return -code error &#34;unrecognized type '$word'&#34;
    }
    switch -glob -- $opts(-type) {
	proc*	{
	    $w.text insert 1.0 \
		    [<a name="::tkcon::EvalOther(8)"><a href="./tkcon.tcl.html#::tkcon::EvalOther_1038">::tkcon::EvalOther</a></a> $app $type dump proc [list $word]]
	    after idle [<a name="::tkcon::Highlight(1)"><a href="./tkcon.tcl.html#::tkcon::Highlight_2904">::tkcon::Highlight</a></a> $w.text tcl]
	}
	var*	{
	    $w.text insert 1.0 \
		    [<a name="::tkcon::EvalOther(9)"><a href="./tkcon.tcl.html#::tkcon::EvalOther_1038">::tkcon::EvalOther</a></a> $app $type dump var [list $word]]
	    after idle [<a name="::tkcon::Highlight(2)"><a href="./tkcon.tcl.html#::tkcon::Highlight_2904">::tkcon::Highlight</a></a> $w.text tcl]
	}
	file	{
	    $w.text insert 1.0 [<a name="::tkcon::EvalOther(10)"><a href="./tkcon.tcl.html#::tkcon::EvalOther_1038">::tkcon::EvalOther</a></a> $app $type eval \
		    [subst -nocommands {
		set __tkcon(fid) [open {$word} r]
		set __tkcon(data) [read \$__tkcon(fid)]
		close \$__tkcon(fid)
		after 1000 unset __tkcon
		return \$__tkcon(data)
	    }
	    ]]
	    after idle [<a name="::tkcon::Highlight(3)"><a href="./tkcon.tcl.html#::tkcon::Highlight_2904">::tkcon::Highlight</a></a> $w.text \
			    [string trimleft [file extension $word] .]]
	}
	error*	{
	    $w.text insert 1.0 [join $args \n]
	    after idle [<a name="::tkcon::Highlight(4)"><a href="./tkcon.tcl.html#::tkcon::Highlight_2904">::tkcon::Highlight</a></a> $w.text error]
	}
	default	{
	    $w.text insert 1.0 [join $args \n]
	}
    }
    wm deiconify $w
    focus $w.text
    if {[string compare $opts(-find) {}]} {
	<a name="::tkcon::Find(2)"><a href="./tkcon.tcl.html#::tkcon::Find_2045">::tkcon::Find</a></a> $w.text $opts(-find) -case 1
    }
}
interp alias {} ::more {} ::edit
interp alias {} ::less {} ::edit

<font color="#208020">## echo</font>
<font color="#208020">## Relaxes the one string restriction of 'puts'</font>
<font color="#208020"># ARGS:	any number of strings to output to stdout</font>
<font color="#208020">##</font>
<strong><a name="echo_3895">proc <a href="tkcon.tcl-annot.html#echo">echo</a></a></strong><a name="echo"></a> args { puts stdout [concat $args] }

<font color="#208020">## clear - clears the buffer of the console (not the history though)</font>
<font color="#208020">## This is executed in the parent interpreter</font>
<font color="#208020">## </font>
<strong><a name="clear_3900">proc <a href="tkcon.tcl-annot.html#clear">clear</a></a></strong><a name="clear"></a> {{pcnt 100}} {
    if {![regexp {^[0-9]*$} $pcnt] || $pcnt &lt; 1 || $pcnt &gt; 100} {
	return -code error \
		&#34;invalid percentage to clear: must be 1-100 (100 default)&#34;
    } elseif {$pcnt == 100} {
	<a name="tkcon(17)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> console delete 1.0 end
    } else {
	set tmp [expr {$pcnt/100.0*[<a name="tkcon(18)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> console index end]}]
	<a name="tkcon(19)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> console delete 1.0 &#34;$tmp linestart&#34;
    }
}

<font color="#208020">## alias - akin to the csh alias command</font>
<font color="#208020">## If called with no args, then it dumps out all current aliases</font>
<font color="#208020">## If called with one arg, returns the alias of that arg (or {} if none)</font>
<font color="#208020"># ARGS:	newcmd	- (optional) command to bind alias to</font>
<font color="#208020"># 	args	- command and args being aliased</font>
<font color="#208020">## </font>
<strong><a name="alias_3918">proc <a href="tkcon.tcl-annot.html#alias">alias</a></a></strong><a name="alias"></a> {{newcmd {}} args} {
    if {[string match {} $newcmd]} {
	set res {}
	foreach a [interp aliases] {
	    lappend res [list $a -&gt; [interp alias {} $a]]
	}
	return [join $res \n]
    } elseif {![llength $args]} {
	interp alias {} $newcmd
    } else {
	eval interp alias [list {} $newcmd {}] $args
    }
}

<font color="#208020">## unalias - unaliases an alias'ed command</font>
<font color="#208020"># ARGS:	cmd	- command to unbind as an alias</font>
<font color="#208020">## </font>
<strong><a name="unalias_3935">proc <a href="tkcon.tcl-annot.html#unalias">unalias</a></a></strong><a name="unalias"></a> {cmd} {
    interp alias {} $cmd {}
}

<font color="#208020">## dump - outputs variables/procedure/widget info in source'able form.</font>
<font color="#208020">## Accepts glob style pattern matching for the names</font>
<font color="#208020">#</font>
<font color="#208020"># ARGS:	type	- type of thing to dump: must be variable, procedure, widget</font>
<font color="#208020">#</font>
<font color="#208020"># OPTS: -nocomplain</font>
<font color="#208020">#		don't complain if no items of the specified type are found</font>
<font color="#208020">#	-filter pattern</font>
<font color="#208020">#		specifies a glob filter pattern to be used by the variable</font>
<font color="#208020">#		method as an array filter pattern (it filters down for</font>
<font color="#208020">#		nested elements) and in the widget method as a config</font>
<font color="#208020">#		option filter pattern</font>
<font color="#208020">#	--	forcibly ends options recognition</font>
<font color="#208020">#</font>
<font color="#208020"># Returns:	the values of the requested items in a 'source'able form</font>
<font color="#208020">## </font>
<strong><a name="dump_3955">proc <a href="tkcon.tcl-annot.html#dump">dump</a></a></strong><a name="dump"></a> {type args} {
    set whine 1
    set code  ok
    if {![llength $args]} {
	<font color="#208020">## If no args, assume they gave us something to dump and</font>
	<font color="#208020">## we'll try anything</font>
	set args $type
	set type any
    }
    while {[string match -* [lindex $args 0]]} {
	switch -glob -- [lindex $args 0] {
	    -n* { set whine 0; set args [lreplace $args 0 0] }
	    -f* { set fltr [lindex $args 1]; set args [lreplace $args 0 1] }
	    --  { set args [lreplace $args 0 0]; break }
	    default {return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;}
	}
    }
    if {$whine &amp;&amp; ![llength $args]} {
	return -code error &#34;wrong \# args: [lindex [info level 0] 0] type\
		?-nocomplain? ?-filter pattern? ?--? pattern ?pattern ...?&#34;
    }
    set res {}
    switch -glob -- $type {
	c* {
	    <font color="#208020"># command</font>
	    <font color="#208020"># outputs commands by figuring out, as well as possible, what it is</font>
	    <font color="#208020"># this does not attempt to auto-load anything</font>
	    foreach arg $args {
		if {[llength [set cmds [info commands $arg]]]} {
		    foreach cmd [lsort $cmds] {
			if {[lsearch -exact [interp aliases] $cmd] &gt; -1} {
			    append res &#34;\#\# ALIAS:   $cmd =&gt;\
				    [interp alias {} $cmd]\n&#34;
			} elseif {
			    [llength [info procs $cmd]] ||
			    ([string match *::* $cmd] &amp;&amp;
			    [llength [namespace eval [namespace qual $cmd] \
				    info procs [namespace tail $cmd]]])
			} {
			    if {[catch {<a name="dump(4)"><a href="./tkcon.tcl.html#dump_3955">dump</a></a> p -- $cmd} msg] &amp;&amp; $whine} {
				set code error
			    }
			    append res $msg\n
			} else {
			    append res &#34;\#\# COMMAND: $cmd\n&#34;
			}
		    }
		} elseif {$whine} {
		    append res &#34;\#\# No known command $arg\n&#34;
		    set code error
		}
	    }
	}
	v* {
	    <font color="#208020"># variable</font>
	    <font color="#208020"># outputs variables value(s), whether array or simple.</font>
	    if {![info exists fltr]} { set fltr * }
	    foreach arg $args {
		if {![llength [set vars [uplevel 1 info vars [list $arg]]]]} {
		    if {[uplevel 1 info exists $arg]} {
			set vars $arg
		    } elseif {$whine} {
			append res &#34;\#\# No known variable $arg\n&#34;
			set code error
			continue
		    } else { continue }
		}
		foreach var [lsort $vars] {
		    if {[uplevel 1 [list info locals $var]] == &#34;&#34;} {
			<font color="#208020"># use the proper scope of the var, but namespace which</font>
			<font color="#208020"># won't id locals or some upvar'ed vars correctly</font>
			set new [uplevel 1 \
				[list namespace which -variable $var]]
			if {$new != &#34;&#34;} {
			    set var $new
			}
		    }
		    upvar 1 $var v
		    if {[array exists v] || [catch {string length $v}]} {
			set nst {}
			append res &#34;array set [list $var] \{\n&#34;
			if {[array size v]} {
			    foreach i \
				    [lsort -dictionary [array names v $fltr]] {
				upvar 0 v\($i\) __a
				if {[array exists __a]} {
				    append nst &#34;\#\# NESTED ARRAY ELEM: $i\n&#34;
				    append nst &#34;upvar 0 [list $var\($i\)] __a;\
					    [<a name="dump(5)"><a href="./tkcon.tcl.html#dump_3955">dump</a></a> v -filter $fltr __a]\n&#34;
				} else {
				    append res &#34;    [list $i]\t[list $v($i)]\n&#34;
				}
			    }
			} else {
			    <font color="#208020">## empty array</font>
			    append res &#34;    empty array\n&#34;
			    if {$var == &#34;&#34;} {
				append nst &#34;unset (empty)\n&#34;
			    } else {
				append nst &#34;unset [list $var](empty)\n&#34;
			    }
			}
			append res &#34;\}\n$nst&#34;
		    } else {
			append res [list set $var $v]\n
		    }
		}
	    }
	}
	p* {
	    <font color="#208020"># procedure</font>
	    foreach arg $args {
		if {
		    ![llength [set procs [info proc $arg]]] &amp;&amp;
		    ([string match *::* $arg] &amp;&amp;
		    [llength [set ps [namespace eval \
			    [namespace qualifier $arg] \
			    info procs [namespace tail $arg]]]])
		} {
		    set procs {}
		    set namesp [namespace qualifier $arg]
		    foreach p $ps {
			lappend procs ${namesp}::$p
		    }
		}
		if {[llength $procs]} {
		    foreach p [lsort $procs] {
			set as {}
			foreach a [info args $p] {
			    if {[info default $p $a tmp]} {
				lappend as [list $a $tmp]
			    } else {
				lappend as $a
			    }
			}
			append res [list proc $p $as [info body $p]]\n
		    }
		} elseif {$whine} {
		    append res &#34;\#\# No known proc $arg\n&#34;
		    set code error
		}
	    }
	}
	w* {
	    <font color="#208020"># widget</font>
	    <font color="#208020">## The user should have Tk loaded</font>
	    if {![llength [info command winfo]]} {
		return -code error &#34;winfo not present, cannot dump widgets&#34;
	    }
	    if {![info exists fltr]} { set fltr .* }
	    foreach arg $args {
		if {[llength [set ws [info command $arg]]]} {
		    foreach w [lsort $ws] {
			if {[winfo exists $w]} {
			    if {[catch {$w configure} cfg]} {
				append res &#34;\#\# Widget $w\
					does not support configure method&#34;
				set code error
			    } else {
				append res &#34;\#\# [winfo class $w]\
					$w\n$w configure&#34;
				foreach c $cfg {
				    if {[llength $c] != 5} continue
				    <font color="#208020">## Check to see that the option does</font>
				    <font color="#208020">## not match the default, then check</font>
				    <font color="#208020">## the item against the user filter</font>
				    if {[string compare [lindex $c 3] \
					    [lindex $c 4]] &amp;&amp; \
					    [regexp -nocase -- $fltr $c]} {
					append res &#34; \\\n\t[list [lindex $c 0]\
						[lindex $c 4]]&#34;
				    }
				}
				append res \n
			    }
			}
		    }
		} elseif {$whine} {
		    append res &#34;\#\# No known widget $arg\n&#34;
		    set code error
		}
	    }
	}
	a* {
	    <font color="#208020">## see if we recognize it, other complain</font>
	    if {[regexp {(var|com|proc|widget)} \
		    [set types [uplevel 1 what $args]]]} {
		foreach type $types {
		    if {[regexp {(var|com|proc|widget)} $type]} {
			append res &#34;[uplevel 1 dump $type $args]\n&#34;
		    }
		}
	    } else {
		set res &#34;dump was unable to resolve type for \&#34;$args\&#34;&#34;
		set code error
	    }
	}
	default {
	    return -code error &#34;bad [lindex [info level 0] 0] option\
		    \&#34;$type\&#34;: must be variable, command, procedure,\
		    or widget&#34;
	}
    }
    return -code $code [string trimright $res \n]
}

<font color="#208020">## idebug - interactive debugger</font>
<font color="#208020">#</font>
<font color="#208020"># idebug body ?level?</font>
<font color="#208020">#</font>
<font color="#208020">#	Prints out the body of the command (if it is a procedure) at the</font>
<font color="#208020">#	specified level.  &lt;i&gt;level&lt;/i&gt; defaults to the current level.</font>
<font color="#208020">#</font>
<font color="#208020"># idebug break</font>
<font color="#208020">#</font>
<font color="#208020">#	Creates a breakpoint within a procedure.  This will only trigger</font>
<font color="#208020">#	if idebug is on and the id matches the pattern.  If so, TkCon will</font>
<font color="#208020">#	pop to the front with the prompt changed to an idebug prompt.  You</font>
<font color="#208020">#	are given the basic ability to observe the call stack an query/set</font>
<font color="#208020">#	variables or execute Tcl commands at any level.  A separate history</font>
<font color="#208020">#	is maintained in debugging mode.</font>
<font color="#208020">#</font>
<font color="#208020"># idebug echo|{echo ?id?} ?args?</font>
<font color="#208020">#</font>
<font color="#208020">#	Behaves just like &#34;echo&#34;, but only triggers when idebug is on.</font>
<font color="#208020">#	You can specify an optional id to further restrict triggering.</font>
<font color="#208020">#	If no id is specified, it defaults to the name of the command</font>
<font color="#208020">#	in which the call was made.</font>
<font color="#208020">#</font>
<font color="#208020"># idebug id ?id?</font>
<font color="#208020">#</font>
<font color="#208020">#	Query or set the idebug id.  This id is used by other idebug</font>
<font color="#208020">#	methods to determine if they should trigger or not.  The idebug</font>
<font color="#208020">#	id can be a glob pattern and defaults to *.</font>
<font color="#208020">#</font>
<font color="#208020"># idebug off</font>
<font color="#208020">#</font>
<font color="#208020">#	Turns idebug off.</font>
<font color="#208020">#</font>
<font color="#208020"># idebug on ?id?</font>
<font color="#208020">#</font>
<font color="#208020">#	Turns idebug on.  If 'id' is specified, it sets the id to it.</font>
<font color="#208020">#</font>
<font color="#208020"># idebug puts|{puts ?id?} args</font>
<font color="#208020">#</font>
<font color="#208020">#	Behaves just like &#34;puts&#34;, but only triggers when idebug is on.</font>
<font color="#208020">#	You can specify an optional id to further restrict triggering.</font>
<font color="#208020">#	If no id is specified, it defaults to the name of the command</font>
<font color="#208020">#	in which the call was made.</font>
<font color="#208020">#</font>
<font color="#208020"># idebug show type ?level? ?VERBOSE?</font>
<font color="#208020">#</font>
<font color="#208020">#	'type' must be one of vars, locals or globals.  This method</font>
<font color="#208020">#	will output the variables/locals/globals present in a particular</font>
<font color="#208020">#	level.  If VERBOSE is added, then it actually 'dump's out the</font>
<font color="#208020">#	values as well.  'level' defaults to the level in which this</font>
<font color="#208020">#	method was called.</font>
<font color="#208020">#</font>
<font color="#208020"># idebug trace ?level?</font>
<font color="#208020">#</font>
<font color="#208020">#	Prints out the stack trace from the specified level up to the top</font>
<font color="#208020">#	level.  'level' defaults to the current level.</font>
<font color="#208020">#</font>
<font color="#208020">##</font>
<strong><a name="idebug_4219">proc <a href="tkcon.tcl-annot.html#idebug">idebug</a></a></strong><a name="idebug"></a> {opt args} {
    global IDEBUG

    if {![info exists IDEBUG(on)]} {
	array set IDEBUG { on 0 id * debugging 0 }
    }
    set level [expr {[info level]-1}]
    switch -glob -- $opt {
	on	{
	    if {[llength $args]} { set IDEBUG(id) $args }
	    return [set IDEBUG(on) 1]
	}
	off	{ return [set IDEBUG(on) 0] }
	id  {
	    if {![llength $args]} {
		return $IDEBUG(id)
	    } else { return [set IDEBUG(id) $args] }
	}
	break {
	    if {!$IDEBUG(on) || $IDEBUG(debugging) || \
		    ([llength $args] &amp;&amp; \
		    ![string match $IDEBUG(id) $args]) || [info level]&lt;1} {
		return
	    }
	    set IDEBUG(debugging) 1
	    puts stderr &#34;idebug at level \#$level: [lindex [info level -1] 0]&#34;
	    set tkcon [llength [info command tkcon]]
	    if {$tkcon} {
		<a name="tkcon(20)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> master eval set ::tkcon::OPT(prompt2) \$::tkcon::OPT(prompt1)
		<a name="tkcon(21)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> master eval set ::tkcon::OPT(prompt1) \$::tkcon::OPT(debugPrompt)
		set slave [<a name="tkcon(22)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> set ::tkcon::OPT(exec)]
		set event [<a name="tkcon(23)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> set ::tkcon::PRIV(event)]
		<a name="tkcon(24)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> set ::tkcon::OPT(exec) [<a name="tkcon(25)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> master interp create debugger]
		<a name="tkcon(26)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> set ::tkcon::PRIV(event) 1
	    }
	    set max $level
	    while 1 {
		set err {}
		if {$tkcon} {
		    <font color="#208020"># tkcon's overload of gets is advanced enough to not need</font>
		    <font color="#208020"># this, but we get a little better control this way.</font>
		    <a name="tkcon(27)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> evalSlave set level $level
		    <a name="tkcon(28)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> prompt
		    set line [<a name="tkcon(29)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> getcommand]
		    <a name="tkcon(30)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> console mark set output end
		} else {
		    puts -nonewline stderr &#34;(level \#$level) debug &gt; &#34;
		    gets stdin line
		    while {![info complete $line]} {
			puts -nonewline &#34;&gt; &#34;
			append line &#34;\n[gets stdin]&#34;
		    }
		}
		if {[string match {} $line]} continue
		set key [lindex $line 0]
		if {![regexp {^([#-]?[0-9]+)} [lreplace $line 0 0] lvl]} {
		    set lvl \#$level
		}
		set res {}; set c 0
		switch -- $key {
		    + {
			<font color="#208020">## Allow for jumping multiple levels</font>
			if {$level &lt; $max} {
			    <a name="idebug(1)"><a href="./tkcon.tcl.html#idebug_4219">idebug</a></a> trace [incr level] $level 0 VERBOSE
			}
		    }
		    - {
			<font color="#208020">## Allow for jumping multiple levels</font>
			if {$level &gt; 1} {
			    <a name="idebug(2)"><a href="./tkcon.tcl.html#idebug_4219">idebug</a></a> trace [incr level -1] $level 0 VERBOSE
			}
		    }
		    . { set c [catch {<a name="idebug(3)"><a href="./tkcon.tcl.html#idebug_4219">idebug</a></a> trace $level $level 0 VERBOSE} res] }
		    v { set c [catch {<a name="idebug(4)"><a href="./tkcon.tcl.html#idebug_4219">idebug</a></a> show vars $lvl } res] }
		    V { set c [catch {<a name="idebug(5)"><a href="./tkcon.tcl.html#idebug_4219">idebug</a></a> show vars $lvl VERBOSE} res] }
		    l { set c [catch {<a name="idebug(6)"><a href="./tkcon.tcl.html#idebug_4219">idebug</a></a> show locals $lvl } res] }
		    L { set c [catch {<a name="idebug(7)"><a href="./tkcon.tcl.html#idebug_4219">idebug</a></a> show locals $lvl VERBOSE} res] }
		    g { set c [catch {<a name="idebug(8)"><a href="./tkcon.tcl.html#idebug_4219">idebug</a></a> show globals $lvl } res] }
		    G { set c [catch {<a name="idebug(9)"><a href="./tkcon.tcl.html#idebug_4219">idebug</a></a> show globals $lvl VERBOSE} res] }
		    t { set c [catch {<a name="idebug(10)"><a href="./tkcon.tcl.html#idebug_4219">idebug</a></a> trace 1 $max $level } res] }
		    T { set c [catch {<a name="idebug(11)"><a href="./tkcon.tcl.html#idebug_4219">idebug</a></a> trace 1 $max $level VERBOSE} res]}
		    b { set c [catch {<a name="idebug(12)"><a href="./tkcon.tcl.html#idebug_4219">idebug</a></a> body $lvl} res] }
		    o { set res [set IDEBUG(on) [expr {!$IDEBUG(on)}]] }
		    h - ?	{
			puts stderr &#34;    +		Move down in call stack
    -		Move up in call stack
    .		Show current proc name and params

    v		Show names of variables currently in scope
    V		Show names of variables currently in scope with values
    l		Show names of local (transient) variables
    L		Show names of local (transient) variables with values
    g		Show names of declared global variables
    G		Show names of declared global variables with values
    t		Show a stack trace
    T		Show a verbose stack trace

    b		Show body of current proc
    o		Toggle on/off any further debugging
    c,q		Continue regular execution (Quit debugger)
    h,?		Print this help
    default	Evaluate line at current level (\#$level)&#34;
		    }
		    c - q break
		    default { set c [catch {uplevel \#$level $line} res] }
		}
		if {$tkcon} {
		    <a name="tkcon(31)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> set ::tkcon::PRIV(event) \
			    [<a name="tkcon(32)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> evalSlave eval history add [list $line]\
			    \; history nextid]
		}
		if {$c} {
		    puts stderr $res
		} elseif {[string compare {} $res]} {
		    puts $res
		}
	    }
	    set IDEBUG(debugging) 0
	    if {$tkcon} {
		<a name="tkcon(33)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> master interp delete debugger
		<a name="tkcon(34)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> master eval set ::tkcon::OPT(prompt1) \$::tkcon::OPT(prompt2)
		<a name="tkcon(35)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> set ::tkcon::OPT(exec) $slave
		<a name="tkcon(36)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> set ::tkcon::PRIV(event) $event
		<a name="tkcon(37)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> prompt
	    }
	}
	bo* {
	    if {[regexp {^([#-]?[0-9]+)} $args level]} {
		return [uplevel $level {<a name="dump(6)"><a href="./tkcon.tcl.html#dump_3955">dump</a></a> c -no [lindex [info level 0] 0]}]
	    }
	}
	t* {
	    if {[llength $args]&lt;2} return
	    set min [set max [set lvl $level]]
	    set exp {^#?([0-9]+)? ?#?([0-9]+) ?#?([0-9]+)? ?(VERBOSE)?}
	    if {![regexp $exp $args junk min max lvl verbose]} return
	    for {set i $max} {
		$i&gt;=$min &amp;&amp; ![catch {uplevel \#$i info level 0} info]
	    } {incr i -1} {
		if {$i==$lvl} {
		    puts -nonewline stderr &#34;* \#$i:\t&#34;
		} else {
		    puts -nonewline stderr &#34;  \#$i:\t&#34;
		}
		set name [lindex $info 0]
		if {[string compare VERBOSE $verbose] || \
			![llength [info procs $name]]} {
		    puts $info
		} else {
		    puts &#34;proc $name {[info args $name]} { ... }&#34;
		    set idx 0
		    foreach arg [info args $name] {
			if {[string match args $arg]} {
			    puts &#34;\t$arg = [lrange $info [incr idx] end]&#34;
			    break
			} else {
			    puts &#34;\t$arg = [lindex $info [incr idx]]&#34;
			}
		    }
		}
	    }
	}
	s* {
	    <font color="#208020">#var, local, global</font>
	    set level \#$level
	    if {![regexp {^([vgl][^ ]*) ?([#-]?[0-9]+)? ?(VERBOSE)?} \
		    $args junk type level verbose]} return
	    switch -glob -- $type {
		v* { set vars [uplevel $level {lsort [info vars]}] }
		l* { set vars [uplevel $level {lsort [info locals]}] }
		g* { set vars [<a name="lremove(12)"><a href="./tkcon.tcl.html#lremove_4738">lremove</a></a> [uplevel $level {info vars}] \
			[uplevel $level {info locals}]] }
	    }
	    if {[string match VERBOSE $verbose]} {
		return [uplevel $level dump var -nocomplain $vars]
	    } else {
		return $vars
	    }
	}
	e* - pu* {
	    if {[llength $opt]==1 &amp;&amp; [catch {lindex [info level -1] 0} id]} {
		set id [lindex [info level 0] 0]
	    } else {
		set id [lindex $opt 1]
	    }
	    if {$IDEBUG(on) &amp;&amp; [string match $IDEBUG(id) $id]} {
		if {[string match e* $opt]} {
		    puts [concat $args]
		} else { eval puts $args }
	    }
	}
	default {
	    return -code error &#34;bad [lindex [info level 0] 0] option \&#34;$opt\&#34;,\
		    must be: [join [lsort [list on off id break print body\
		    trace show puts echo]] {, }]&#34;
	}
    }
}

<font color="#208020">## observe - like trace, but not</font>
<font color="#208020"># ARGS:	opt	- option</font>
<font color="#208020">#	name	- name of variable or command</font>
<font color="#208020">##</font>
<strong><a name="observe_4422">proc <a href="tkcon.tcl-annot.html#observe">observe</a></a></strong><a name="observe"></a> {opt name args} {
    global tcl_observe
    switch -glob -- $opt {
	co* {
	    if {[regexp {^(catch|lreplace|set|puts|for|incr|info|uplevel)$} \
		    $name]} {
		return -code error &#34;cannot observe \&#34;$name\&#34;:\
			infinite eval loop will occur&#34;
	    }
	    set old ${name}@
	    while {[llength [info command $old]]} { append old @ }
	    rename $name $old
	    set max 4
	    regexp {^[0-9]+} $args max
	    <font color="#208020"># handle the observe'ing of 'proc'</font>
	    set proccmd &#34;proc&#34;
	    if {[string match &#34;proc&#34; $name]} { set proccmd $old }
	    <font color="#208020">## idebug trace could be used here</font>
	    $proccmd $name args &#34;
	    for {set i \[info level\]; set max \[expr \[info level\]-$max\]} {
		\$i&gt;=\$max &amp;&amp; !\[catch {uplevel \#\$i info level 0} info\]
	    } {incr i -1} {
		puts -nonewline stderr \&#34;  \#\$i:\t\&#34;
		puts \$info
	    }
	    uplevel \[lreplace \[info level 0\] 0 0 $old\]
	    &#34;
	    set tcl_observe($name) $old
	}
	cd* {
	    if {[info exists tcl_observe($name)] &amp;&amp; [catch {
		rename $name {}
		rename $tcl_observe($name) $name
		unset tcl_observe($name)
	    } err]} { return -code error $err }
	}
	ci* {
	    <font color="#208020">## What a useless method...</font>
	    if {[info exists tcl_observe($name)]} {
		set i $tcl_observe($name)
		set res &#34;\&#34;$name\&#34; observes true command \&#34;$i\&#34;&#34;
		while {[info exists tcl_observe($i)]} {
		    append res &#34;\n\&#34;$name\&#34; observes true command \&#34;$i\&#34;&#34;
		    set i $tcl_observe($name)
		}
		return $res
	    }
	}
	va* - vd* {
	    set type [lindex $args 0]
	    set args [lrange $args 1 end]
	    if {![regexp {^[rwu]} $type type]} {
		return -code error &#34;bad [lindex [info level 0] 0] $opt type\
			\&#34;$type\&#34;, must be: read, write or unset&#34;
	    }
	    if {![llength $args]} { set args observe_var }
	    foreach c [uplevel 1 [list trace vinfo $name]] {
		<font color="#208020"># don't double up on the traces</font>
		if {[list $type $args] == $c} { return }
	    }
	    uplevel 1 [list trace $opt $name $type $args]
	}
	vi* {
	    uplevel 1 [list trace vinfo $name]
	}
	default {
	    return -code error &#34;bad [lindex [info level 0] 0] option\
		    \&#34;[lindex $args 0]\&#34;, must be: [join [lsort \
		    [list command cdelete cinfo variable vdelete vinfo]] {, }]&#34;
	}
    }
}

<font color="#208020">## observe_var - auxilary function for observing vars, called by trace</font>
<font color="#208020">## via observe</font>
<font color="#208020"># ARGS:	name	- variable name</font>
<font color="#208020">#	el	- array element name, if any</font>
<font color="#208020">#	op	- operation type (rwu)</font>
<font color="#208020">##</font>
<strong><a name="observe_var_4501">proc <a href="tkcon.tcl-annot.html#observe_var">observe_var</a></a></strong><a name="observe_var"></a> {name el op} {
    if {[string match u $op]} {
	if {[string compare {} $el]} {
	    puts &#34;unset \&#34;${name}($el)\&#34;&#34;
	} else {
	    puts &#34;unset \&#34;$name\&#34;&#34;
	}
    } else {
	upvar 1 $name $name
	if {[info exists ${name}($el)]} {
	    puts [<a name="dump(7)"><a href="./tkcon.tcl.html#dump_3955">dump</a></a> v ${name}($el)]
	} else {
	    puts [<a name="dump(8)"><a href="./tkcon.tcl.html#dump_3955">dump</a></a> v $name]
	}
    }
}

<font color="#208020">## which - tells you where a command is found</font>
<font color="#208020"># ARGS:	cmd	- command name</font>
<font color="#208020"># Returns:	where command is found (internal / external / unknown)</font>
<font color="#208020">## </font>
<strong><a name="which_4522">proc <a href="tkcon.tcl-annot.html#which">which</a></a></strong><a name="which"></a> cmd {
    <font color="#208020">## This tries to auto-load a command if not recognized</font>
    set types [uplevel 1 [list what $cmd 1]]
    if {[llength $types]} {
	set out {}
	
	foreach type $types {
	    switch -- $type {
		<a name="alias(2)"><a href="./tkcon.tcl.html#alias_3918">alias</a></a>		{ set res &#34;$cmd: aliased to [<a name="alias(3)"><a href="./tkcon.tcl.html#alias_3918">alias</a></a> $cmd]&#34; }
		procedure	{ set res &#34;$cmd: procedure&#34; }
		command		{ set res &#34;$cmd: internal command&#34; }
		executable	{ lappend out [auto_execok $cmd] }
		variable	{ lappend out &#34;$cmd: $type&#34; }
	    }
	    if {[info exists res]} {
		global auto_index
		if {[info exists auto_index($cmd)]} {
		    <font color="#208020">## This tells you where the command MIGHT have come from -</font>
		    <font color="#208020">## not true if the command was redefined interactively or</font>
		    <font color="#208020">## existed before it had to be auto_loaded.  This is just</font>
		    <font color="#208020">## provided as a hint at where it MAY have come from</font>
		    append res &#34; ($auto_index($cmd))&#34;
		}
		lappend out $res
		unset res
	    }
	}
	return [join $out \n]
    } else {
	return -code error &#34;$cmd: command not found&#34;
    }
}

<font color="#208020">## what - tells you what a string is recognized as</font>
<font color="#208020"># ARGS:	str	- string to id</font>
<font color="#208020"># Returns:	id types of command as list</font>
<font color="#208020">## </font>
<strong><a name="what_4559">proc <a href="tkcon.tcl-annot.html#what">what</a></a></strong><a name="what"></a> {str {autoload 0}} {
    set types {}
    if {[llength [info commands $str]] || ($autoload &amp;&amp; \
	    [auto_load $str] &amp;&amp; [llength [info commands $str]])} {
	if {[lsearch -exact [interp aliases] $str] &gt; -1} {
	    lappend types &#34;alias&#34;
	} elseif {
	    [llength [info procs $str]] ||
	    ([string match *::* $str] &amp;&amp;
	    [llength [namespace eval [namespace qualifier $str] \
		    info procs [namespace tail $str]]])
	} {
	    lappend types &#34;procedure&#34;
	} else {
	    lappend types &#34;command&#34;
	}
    }
    if {[llength [uplevel 1 info vars $str]]} {
	upvar 1 $str var
	if {[array exists var]} {
	    lappend types array variable
	} else {
	    lappend types scalar variable
	}
    }
    if {[file isdirectory $str]} {
	lappend types &#34;directory&#34;
    }
    if {[file isfile $str]} {
	lappend types &#34;file&#34;
    }
    if {[llength [info commands winfo]] &amp;&amp; [winfo exists $str]} {
	lappend types &#34;widget&#34;
    }
    if {[string compare {} [auto_execok $str]]} {
	lappend types &#34;executable&#34;
    }
    return $types
}

<font color="#208020">## dir - directory list</font>
<font color="#208020"># ARGS:	args	- names/glob patterns of directories to list</font>
<font color="#208020"># OPTS:	-all	- list hidden files as well (Unix dot files)</font>
<font color="#208020">#	-long	- list in full format &#34;permissions size date filename&#34;</font>
<font color="#208020">#	-full	- displays / after directories and link paths for links</font>
<font color="#208020"># Returns:	a directory listing</font>
<font color="#208020">## </font>
<strong><a name="dir_4606">proc <a href="tkcon.tcl-annot.html#dir">dir</a></a></strong><a name="dir"></a> {args} {
    array set s {
	all 0 full 0 long 0
	0 --- 1 --x 2 -w- 3 -wx 4 r-- 5 r-x 6 rw- 7 rwx
    }
    while {[string match \-* [lindex $args 0]]} {
	set str [lindex $args 0]
	set args [lreplace $args 0 0]
	switch -glob -- $str {
	    -a* {set s(all) 1} -f* {set s(full) 1}
	    -l* {set s(long) 1} -- break
	    default {
		return -code error &#34;unknown option \&#34;$str\&#34;,\
			should be one of: -all, -full, -long&#34;
	    }
	}
    }
    set sep [string trim [file join . .] .]
    if {![llength $args]} { set args [list [pwd]] }
    if {$::tcl_version &gt;= 8.3} {
	<font color="#208020"># Newer glob args allow safer dir processing.  The user may still</font>
	<font color="#208020"># want glob chars, but really only for file matching.</font>
	foreach arg $args {
	    if {[file isdirectory $arg]} {
		if {$s(all)} {
		    lappend out [list $arg [lsort \
			    [glob -nocomplain -directory $arg .* *]]]
		} else {
		    lappend out [list $arg [lsort \
			    [glob -nocomplain -directory $arg *]]]
		}
	    } else {
		set dir [file dirname $arg]
		lappend out [list $dir$sep [lsort \
			[glob -nocomplain -directory $dir [file tail $arg]]]]
	    }
	}
    } else {
	foreach arg $args {
	    if {[file isdirectory $arg]} {
		set arg [string trimright $arg $sep]$sep
		if {$s(all)} {
		    lappend out [list $arg [lsort [glob -nocomplain -- $arg.* $arg*]]]
		} else {
		    lappend out [list $arg [lsort [glob -nocomplain -- $arg*]]]
		}
	    } else {
		lappend out [list [file dirname $arg]$sep \
			[lsort [glob -nocomplain -- $arg]]]
	    }
	}
    }
    if {$s(long)} {
	set old [clock scan {1 year ago}]
	set fmt &#34;%s%9ld %s %s\n&#34;
	foreach o $out {
	    set d [lindex $o 0]
	    append res $d:\n
	    foreach f [lindex $o 1] {
		file lstat $f st
		set f [file tail $f]
		if {$s(full)} {
		    switch -glob $st(type) {
			d* { append f $sep }
			l* { append f &#34;@ -&gt; [file readlink $d$sep$f]&#34; }
			default { if {[file exec $d$sep$f]} { append f * } }
		    }
		}
		if {[string match file $st(type)]} {
		    set mode -
		} else {
		    set mode [string index $st(type) 0]
		}
		foreach j [split [format %03o [expr {$st(mode)&amp;0777}]] {}] {
		    append mode $s($j)
		}
		if {$st(mtime)&gt;$old} {
		    set cfmt {%b %d %H:%M}
		} else {
		    set cfmt {%b %d  %Y}
		}
		append res [format $fmt $mode $st(size) \
			[clock format $st(mtime) -format $cfmt] $f]
	    }
	    append res \n
	}
    } else {
	foreach o $out {
	    set d [lindex $o 0]
	    append res &#34;$d:\n&#34;
	    set i 0
	    foreach f [lindex $o 1] {
		if {[string len [file tail $f]] &gt; $i} {
		    set i [string len [file tail $f]]
		}
	    }
	    set i [expr {$i+2+$s(full)}]
	    set j 80
	    <font color="#208020">## This gets the number of cols in the tkcon console widget</font>
	    if {[llength [info commands tkcon]]} {
		set j [expr {[<a name="tkcon(38)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> master set ::tkcon::OPT(cols)]/$i}]
	    }
	    set k 0
	    foreach f [lindex $o 1] {
		set f [file tail $f]
		if {$s(full)} {
		    switch -glob [file type $d$sep$f] {
			d* { append f $sep }
			l* { append f @ }
			default { if {[file exec $d$sep$f]} { append f * } }
		    }
		}
		append res [format &#34;%-${i}s&#34; $f]
		if {$j == 0 || [incr k]%$j == 0} {
		    set res [string trimright $res]\n
		}
	    }
	    append res \n\n
	}
    }
    return [string trimright $res]
}
interp alias {} ::ls {} ::dir -full

<font color="#208020">## lremove - remove items from a list</font>
<font color="#208020"># OPTS:</font>
<font color="#208020">#   -all	remove all instances of each item</font>
<font color="#208020">#   -glob	remove all instances matching glob pattern</font>
<font color="#208020">#   -regexp	remove all instances matching regexp pattern</font>
<font color="#208020"># ARGS:	l	a list to remove items from</font>
<font color="#208020">#	args	items to remove (these are 'join'ed together)</font>
<font color="#208020">##</font>
<strong><a name="lremove_4738">proc <a href="tkcon.tcl-annot.html#lremove">lremove</a></a></strong><a name="lremove"></a> {args} {
    array set opts {-all 0 pattern -exact}
    while {[string match -* [lindex $args 0]]} {
	switch -glob -- [lindex $args 0] {
	    -a*	{ set opts(-all) 1 }
	    -g*	{ set opts(pattern) -glob }
	    -r*	{ set opts(pattern) -regexp }
	    --	{ set args [lreplace $args 0 0]; break }
	    default {return -code error &#34;unknown option \&#34;[lindex $args 0]\&#34;&#34;}
	}
	set args [lreplace $args 0 0]
    }
    set l [lindex $args 0]
    foreach i [join [lreplace $args 0 0]] {
	if {[set ix [lsearch $opts(pattern) $l $i]] == -1} continue
	set l [lreplace $l $ix $ix]
	if {$opts(-all)} {
	    while {[set ix [lsearch $opts(pattern) $l $i]] != -1} {
		set l [lreplace $l $ix $ix]
	    }
	}
    }
    return $l
}

if {!$::tkcon::PRIV(WWW)} {;

<font color="#208020">## Unknown changed to get output into tkcon window</font>
<font color="#208020"># unknown:</font>
<font color="#208020"># Invoked automatically whenever an unknown command is encountered.</font>
<font color="#208020"># Works through a list of &#34;unknown handlers&#34; that have been registered</font>
<font color="#208020"># to deal with unknown commands.  Extensions can integrate their own</font>
<font color="#208020"># handlers into the 'unknown' facility via 'unknown_handler'.</font>
<font color="#208020">#</font>
<font color="#208020"># If a handler exists that recognizes the command, then it will</font>
<font color="#208020"># take care of the command action and return a valid result or a</font>
<font color="#208020"># Tcl error.  Otherwise, it should return &#34;-code continue&#34; (=2)</font>
<font color="#208020"># and responsibility for the command is passed to the next handler.</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020"># args -	A list whose elements are the words of the original</font>
<font color="#208020">#		command, including the command name.</font>

<strong><a name="unknown_4781">proc <a href="tkcon.tcl-annot.html#unknown">unknown</a></a></strong><a name="unknown"></a> args {
    global unknown_handler_order unknown_handlers errorInfo errorCode

    <font color="#208020">#</font>
    <font color="#208020"># Be careful to save error info now, and restore it later</font>
    <font color="#208020"># for each handler.  Some handlers generate their own errors</font>
    <font color="#208020"># and disrupt handling.</font>
    <font color="#208020">#</font>
    set savedErrorCode $errorCode
    set savedErrorInfo $errorInfo

    if {![info exists unknown_handler_order] || \
	    ![info exists unknown_handlers]} {
	set unknown_handlers(tcl) tcl_unknown
	set unknown_handler_order tcl
    }

    foreach handler $unknown_handler_order {
        set status [catch {uplevel 1 $unknown_handlers($handler) $args} result]

        if {$status == 1} {
            <font color="#208020">#</font>
            <font color="#208020"># Strip the last five lines off the error stack (they're</font>
            <font color="#208020"># from the &#34;uplevel&#34; command).</font>
            <font color="#208020">#</font>
            set new [split $errorInfo \n]
            set new [join [lrange $new 0 [expr {[llength $new]-6}]] \n]
            return -code $status -errorcode $errorCode \
                -errorinfo $new $result

        } elseif {$status != 4} {
            return -code $status $result
        }

        set errorCode $savedErrorCode
        set errorInfo $savedErrorInfo
    }

    set name [lindex $args 0]
    return -code error &#34;invalid command name \&#34;$name\&#34;&#34;
}

<font color="#208020"># tcl_unknown:</font>
<font color="#208020"># Invoked when a Tcl command is invoked that doesn't exist in the</font>
<font color="#208020"># interpreter:</font>
<font color="#208020">#</font>
<font color="#208020">#	1. See if the autoload facility can locate the command in a</font>
<font color="#208020">#	   Tcl script file.  If so, load it and execute it.</font>
<font color="#208020">#	2. If the command was invoked interactively at top-level:</font>
<font color="#208020">#	    (a) see if the command exists as an executable UNIX program.</font>
<font color="#208020">#		If so, &#34;exec&#34; the command.</font>
<font color="#208020">#	    (b) see if the command requests csh-like history substitution</font>
<font color="#208020">#		in one of the common forms !!, !&lt;number&gt;, or ^old^new.  If</font>
<font color="#208020">#		so, emulate csh's history substitution.</font>
<font color="#208020">#	    (c) see if the command is a unique abbreviation for another</font>
<font color="#208020">#		command.  If so, invoke the command.</font>
<font color="#208020">#</font>
<font color="#208020"># Arguments:</font>
<font color="#208020"># args -	A list whose elements are the words of the original</font>
<font color="#208020">#		command, including the command name.</font>

<strong><a name="tcl_unknown_4842">proc <a href="tkcon.tcl-annot.html#tcl_unknown">tcl_unknown</a></a></strong><a name="tcl_unknown"></a> args {
    global auto_noexec auto_noload env unknown_pending tcl_interactive
    global errorCode errorInfo

    <font color="#208020"># If the command word has the form &#34;namespace inscope ns cmd&#34;</font>
    <font color="#208020"># then concatenate its arguments onto the end and evaluate it.</font>

    set cmd [lindex $args 0]
    if {[regexp &#34;^:*namespace\[ \t\n\]+inscope&#34; $cmd] \
	    &amp;&amp; [llength $cmd] == 4} {
        set arglist [lrange $args 1 end]
	set ret [catch {uplevel 1 $cmd $arglist} result]
        if {$ret == 0} {
            return $result
        } else {
	    return -code $ret -errorcode $errorCode $result
        }
    }

    <font color="#208020"># Save the values of errorCode and errorInfo variables, since they</font>
    <font color="#208020"># may get modified if caught errors occur below.  The variables will</font>
    <font color="#208020"># be restored just before re-executing the missing command.</font>

    set savedErrorCode $errorCode
    set savedErrorInfo $errorInfo
    set name [lindex $args 0]
    if {![info exists auto_noload]} {
	<font color="#208020">#</font>
	<font color="#208020"># Make sure we're not trying to load the same proc twice.</font>
	<font color="#208020">#</font>
	if {[info exists unknown_pending($name)]} {
	    return -code error &#34;self-referential recursion in \&#34;unknown\&#34; for command \&#34;$name\&#34;&#34;
	}
	set unknown_pending($name) pending
	if {[llength [info args auto_load]]==1} {
	    set ret [catch {auto_load $name} msg]
	} else {
	    set ret [catch {auto_load $name [uplevel 1 {namespace current}]} msg]
	}
	unset unknown_pending($name)
	if {$ret} {
	    return -code $ret -errorcode $errorCode \
		    &#34;error while autoloading \&#34;$name\&#34;: $msg&#34;
	}
	if {![array size unknown_pending]} { unset unknown_pending }
	if {$msg} {
	    set errorCode $savedErrorCode
	    set errorInfo $savedErrorInfo
	    set code [catch {uplevel 1 $args} msg]
	    if {$code ==  1} {
		<font color="#208020">#</font>
		<font color="#208020"># Strip the last five lines off the error stack (they're</font>
		<font color="#208020"># from the &#34;uplevel&#34; command).</font>
		<font color="#208020">#</font>

		set new [split $errorInfo \n]
		set new [join [lrange $new 0 [expr {[llength $new]-6}]] \n]
		return -code error -errorcode $errorCode \
			-errorinfo $new $msg
	    } else {
		return -code $code $msg
	    }
	}
    }
    if {[info level] == 1 &amp;&amp; [string match {} [info script]] \
	    &amp;&amp; [info exists tcl_interactive] &amp;&amp; $tcl_interactive} {
	if {![info exists auto_noexec]} {
	    set new [auto_execok $name]
	    if {[string compare {} $new]} {
		set errorCode $savedErrorCode
		set errorInfo $savedErrorInfo
		if {[info exists ::tkcon::EXPECT] &amp;&amp; $::tkcon::EXPECT &amp;&amp; [package provide Expect] != &#34;&#34;} {
		    return [<a name="tkcon(39)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> expect [concat $new [lrange $args 1 end]]]
		} else {
		    return [uplevel 1 exec $new [lrange $args 1 end]]
		}
		<font color="#208020">#return [uplevel exec &gt;&amp;@stdout &lt;@stdin $new [lrange $args 1 end]]</font>
	    }
	}
	set errorCode $savedErrorCode
	set errorInfo $savedErrorInfo
	<font color="#208020">##</font>
	<font color="#208020">## History substitution moved into ::tkcon::EvalCmd</font>
	<font color="#208020">##</font>
	if {[string compare $name &#34;::&#34;] == 0} {
	    set name &#34;&#34;
	}
	if {$ret != 0} {
	    return -code $ret -errorcode $errorCode \
		&#34;error in unknown while checking if \&#34;$name\&#34; is a unique command abbreviation: $msg&#34;
	}
	set cmds [info commands $name*]
	if {[llength $cmds] == 1} {
	    return [uplevel 1 [lreplace $args 0 0 $cmds]]
	}
	if {[llength $cmds]} {
	    if {$name == &#34;&#34;} {
		return -code error &#34;empty command name \&#34;\&#34;&#34;
	    } else {
		return -code error \
			&#34;ambiguous command name \&#34;$name\&#34;: [lsort $cmds]&#34;
	    }
	}
	<font color="#208020">## We've got nothing so far</font>
	<font color="#208020">## Check and see if Tk wasn't loaded, but it appears to be a Tk cmd</font>
	if {![uplevel \#0 info exists tk_version]} {
	    lappend tkcmds bell bind bindtags button \
		    canvas checkbutton clipboard destroy \
		    entry event focus font frame grab grid image \
		    label labelframe listbox lower menu menubutton message \
		    option pack panedwindow place radiobutton raise \
		    scale scrollbar selection send spinbox \
		    text tk tkwait toplevel winfo wm
	    if {[lsearch -exact $tkcmds $name] &gt;= 0 &amp;&amp; \
		    [<a name="tkcon(40)"><a href="./tkcon.tcl.html#tkcon_3337">tkcon</a></a> master tk_messageBox -icon question -parent . \
		    -title &#34;Load Tk?&#34; -type retrycancel -default retry \
		    -message &#34;This appears to be a Tk command, but Tk\
		    has not yet been loaded.  Shall I retry the command\
		    with loading Tk first?&#34;] == &#34;retry&#34;} {
		return [uplevel 1 &#34;load {} Tk; $args&#34;]
	    }
	}
    }
    return -code continue
}

} ; <font color="#208020"># end exclusionary code for WWW</font>

<strong><a name="::tkcon::Bindings_4970">proc <a href="tkcon.tcl-annot.html#::tkcon::Bindings">::tkcon::Bindings</a></a></strong><a name="::tkcon::Bindings"></a> {} {
    variable PRIV
    global tcl_platform tk_version

    <font color="#208020">#-----------------------------------------------------------------------</font>
    <font color="#208020"># Elements of tkPriv that are used in this file:</font>
    <font color="#208020">#</font>
    <font color="#208020"># char -		Character position on the line;  kept in order</font>
    <font color="#208020">#			to allow moving up or down past short lines while</font>
    <font color="#208020">#			still remembering the desired position.</font>
    <font color="#208020"># mouseMoved -	Non-zero means the mouse has moved a significant</font>
    <font color="#208020">#			amount since the button went down (so, for example,</font>
    <font color="#208020">#			start dragging out a selection).</font>
    <font color="#208020"># prevPos -		Used when moving up or down lines via the keyboard.</font>
    <font color="#208020">#			Keeps track of the previous insert position, so</font>
    <font color="#208020">#			we can distinguish a series of ups and downs, all</font>
    <font color="#208020">#			in a row, from a new up or down.</font>
    <font color="#208020"># selectMode -	The style of selection currently underway:</font>
    <font color="#208020">#			char, word, or line.</font>
    <font color="#208020"># x, y -		Last known mouse coordinates for scanning</font>
    <font color="#208020">#			and auto-scanning.</font>
    <font color="#208020">#-----------------------------------------------------------------------</font>

    switch -glob $tcl_platform(platform) {
	win*	{ set PRIV(meta) Alt }
	mac*	{ set PRIV(meta) Command }
	default	{ set PRIV(meta) Meta }
    }

    <font color="#208020">## Get all Text bindings into TkConsole</font>
    foreach ev [bind Text] { bind TkConsole $ev [bind Text $ev] }
    <font color="#208020">## We really didn't want the newline insertion</font>
    bind TkConsole &lt;Control-Key-o&gt; {}

    <font color="#208020">## Now make all our virtual event bindings</font>
    foreach {ev key} [subst -nocommand -noback {
	&lt;&lt;TkCon_Exit&gt;&gt;		&lt;Control-q&gt;
	&lt;&lt;TkCon_New&gt;&gt;		&lt;Control-N&gt;
	&lt;&lt;TkCon_NewTab&gt;&gt;	&lt;Control-T&gt;
	&lt;&lt;TkCon_NextTab&gt;&gt;	&lt;Control-Key-Tab&gt;
	&lt;&lt;TkCon_PrevTab&gt;&gt;	&lt;Control-Shift-Key-Tab&gt;
	&lt;&lt;TkCon_Close&gt;&gt;		&lt;Control-w&gt;
	&lt;&lt;TkCon_About&gt;&gt;		&lt;Control-A&gt;
	&lt;&lt;TkCon_Help&gt;&gt;		&lt;Control-H&gt;
	&lt;&lt;TkCon_Find&gt;&gt;		&lt;Control-F&gt;
	&lt;&lt;TkCon_Slave&gt;&gt;		&lt;Control-Key-1&gt;
	&lt;&lt;TkCon_Master&gt;&gt;	&lt;Control-Key-2&gt;
	&lt;&lt;TkCon_Main&gt;&gt;		&lt;Control-Key-3&gt;
	&lt;&lt;TkCon_Expand&gt;&gt;	&lt;Key-Tab&gt;
	&lt;&lt;TkCon_ExpandFile&gt;&gt;	&lt;Key-Escape&gt;
	&lt;&lt;TkCon_ExpandProc&gt;&gt;	&lt;Control-P&gt;
	&lt;&lt;TkCon_ExpandVar&gt;&gt;	&lt;Control-V&gt;
	&lt;&lt;TkCon_Tab&gt;&gt;		&lt;Control-i&gt;
	&lt;&lt;TkCon_Tab&gt;&gt;		&lt;$PRIV(meta)-i&gt;
	&lt;&lt;TkCon_Newline&gt;&gt;	&lt;Control-o&gt;
	&lt;&lt;TkCon_Newline&gt;&gt;	&lt;$PRIV(meta)-o&gt;
	&lt;&lt;TkCon_Newline&gt;&gt;	&lt;Control-Key-Return&gt;
	&lt;&lt;TkCon_Newline&gt;&gt;	&lt;Control-Key-KP_Enter&gt;
	&lt;&lt;TkCon_Eval&gt;&gt;		&lt;Return&gt;
	&lt;&lt;TkCon_Eval&gt;&gt;		&lt;KP_Enter&gt;
	&lt;&lt;TkCon_Clear&gt;&gt;		&lt;Control-l&gt;
	&lt;&lt;TkCon_Previous&gt;&gt;	&lt;Up&gt;
	&lt;&lt;TkCon_PreviousImmediate&gt;&gt;	&lt;Control-p&gt;
	&lt;&lt;TkCon_PreviousSearch&gt;&gt;	&lt;Control-r&gt;
	&lt;&lt;TkCon_Next&gt;&gt;		&lt;Down&gt;
	&lt;&lt;TkCon_NextImmediate&gt;&gt;	&lt;Control-n&gt;
	&lt;&lt;TkCon_NextSearch&gt;&gt;	&lt;Control-s&gt;
	&lt;&lt;TkCon_Transpose&gt;&gt;	&lt;Control-t&gt;
	&lt;&lt;TkCon_ClearLine&gt;&gt;	&lt;Control-u&gt;
	&lt;&lt;TkCon_SaveCommand&gt;&gt;	&lt;Control-z&gt;
	&lt;&lt;TkCon_Popup&gt;&gt;		&lt;Button-3&gt;
    }] {
	event add $ev $key
	<font color="#208020">## Make sure the specific key won't be defined</font>
	bind TkConsole $key {}
    }

    <font color="#208020">## Make the ROOT bindings</font>
    bind $PRIV(root) &lt;&lt;TkCon_Exit&gt;&gt;	exit
    bind $PRIV(root) &lt;&lt;TkCon_New&gt;&gt;	{ <a name="::tkcon::New(1)"><a href="./tkcon.tcl.html#::tkcon::New_2423">::tkcon::New</a></a> }
    bind $PRIV(root) &lt;&lt;TkCon_NewTab&gt;&gt;	{ <a name="::tkcon::NewTab(1)"><a href="./tkcon.tcl.html#::tkcon::NewTab_815">::tkcon::NewTab</a></a> }
    bind $PRIV(root) &lt;&lt;TkCon_NextTab&gt;&gt;	{ <a name="::tkcon::GotoTab(1)"><a href="./tkcon.tcl.html#::tkcon::GotoTab_768">::tkcon::GotoTab</a></a> 1 ; break }
    bind $PRIV(root) &lt;&lt;TkCon_PrevTab&gt;&gt;	{ <a name="::tkcon::GotoTab(2)"><a href="./tkcon.tcl.html#::tkcon::GotoTab_768">::tkcon::GotoTab</a></a> -1 ; break }
    bind $PRIV(root) &lt;&lt;TkCon_Close&gt;&gt;	{ <a name="::tkcon::Destroy(2)"><a href="./tkcon.tcl.html#::tkcon::Destroy_2485">::tkcon::Destroy</a></a> }
    bind $PRIV(root) &lt;&lt;TkCon_About&gt;&gt;	{ <a name="::tkcon::About(1)"><a href="./tkcon.tcl.html#::tkcon::About_1351">::tkcon::About</a></a> }
    bind $PRIV(root) &lt;&lt;TkCon_Help&gt;&gt;	{ ::tkcon::Help }
    bind $PRIV(root) &lt;&lt;TkCon_Find&gt;&gt;	{ <a name="::tkcon::FindBox(1)"><a href="./tkcon.tcl.html#::tkcon::FindBox_1986">::tkcon::FindBox</a></a> $::tkcon::PRIV(console) }
    bind $PRIV(root) &lt;&lt;TkCon_Slave&gt;&gt;	{
	<a name="::tkcon::Attach(1)"><a href="./tkcon.tcl.html#::tkcon::Attach_2078">::tkcon::Attach</a></a> {}
	<a name="::tkcon::RePrompt(6)"><a href="./tkcon.tcl.html#::tkcon::RePrompt_1339">::tkcon::RePrompt</a></a> &#34;\n&#34; [<a name="::tkcon::CmdGet(9)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> $::tkcon::PRIV(console)]
    }
    bind $PRIV(root) &lt;&lt;TkCon_Master&gt;&gt;	{
	if {[string compare {} $::tkcon::PRIV(name)]} {
	    <a name="::tkcon::Attach(2)"><a href="./tkcon.tcl.html#::tkcon::Attach_2078">::tkcon::Attach</a></a> $::tkcon::PRIV(name)
	} else {
	    <a name="::tkcon::Attach(3)"><a href="./tkcon.tcl.html#::tkcon::Attach_2078">::tkcon::Attach</a></a> Main
	}
	<a name="::tkcon::RePrompt(7)"><a href="./tkcon.tcl.html#::tkcon::RePrompt_1339">::tkcon::RePrompt</a></a> &#34;\n&#34; [<a name="::tkcon::CmdGet(10)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> $::tkcon::PRIV(console)]
    }
    bind $PRIV(root) &lt;&lt;TkCon_Main&gt;&gt;	{
	<a name="::tkcon::Attach(4)"><a href="./tkcon.tcl.html#::tkcon::Attach_2078">::tkcon::Attach</a></a> Main
	<a name="::tkcon::RePrompt(8)"><a href="./tkcon.tcl.html#::tkcon::RePrompt_1339">::tkcon::RePrompt</a></a> &#34;\n&#34; [<a name="::tkcon::CmdGet(11)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> $::tkcon::PRIV(console)]
    }
    bind $PRIV(root) &lt;&lt;TkCon_Popup&gt;&gt; {
	<a name="::tkcon::PopupMenu(1)"><a href="./tkcon.tcl.html#::tkcon::PopupMenu_5376">::tkcon::PopupMenu</a></a> %X %Y
    }

    <font color="#208020">## Menu items need null TkConsolePost bindings to avoid the TagProc</font>
    <font color="#208020">##</font>
    foreach ev [bind $PRIV(root)] {
	bind TkConsolePost $ev {
	    <font color="#208020"># empty</font>
	}
    }


    <font color="#208020"># ::tkcon::ClipboardKeysyms --</font>
    <font color="#208020"># This procedure is invoked to identify the keys that correspond to</font>
    <font color="#208020"># the copy, cut, and paste functions for the clipboard.</font>
    <font color="#208020">#</font>
    <font color="#208020"># Arguments:</font>
    <font color="#208020"># copy -	Name of the key (keysym name plus modifiers, if any,</font>
    <font color="#208020">#		such as &#34;Meta-y&#34;) used for the copy operation.</font>
    <font color="#208020"># cut -		Name of the key used for the cut operation.</font>
    <font color="#208020"># paste -	Name of the key used for the paste operation.</font>

    <strong><a name="::tkcon::ClipboardKeysyms_5096">proc <a href="tkcon.tcl-annot.html#::tkcon::ClipboardKeysyms">::tkcon::ClipboardKeysyms</a></a></strong><a name="::tkcon::ClipboardKeysyms"></a> {copy cut paste} {
	bind TkConsole &lt;$copy&gt;	{<a name="::tkcon::Copy(1)"><a href="./tkcon.tcl.html#::tkcon::Copy_5125">::tkcon::Copy</a></a> %W}
	bind TkConsole &lt;$cut&gt;	{<a name="::tkcon::Cut(1)"><a href="./tkcon.tcl.html#::tkcon::Cut_5113">::tkcon::Cut</a></a> %W}
	bind TkConsole &lt;$paste&gt;	{<a name="::tkcon::Paste(1)"><a href="./tkcon.tcl.html#::tkcon::Paste_5134">::tkcon::Paste</a></a> %W}
    }

    <strong><a name="::tkcon::GetSelection_5102">proc <a href="tkcon.tcl-annot.html#::tkcon::GetSelection">::tkcon::GetSelection</a></a></strong><a name="::tkcon::GetSelection"></a> {w} {
	if {
	    ![catch {selection get -displayof $w -type UTF8_STRING} txt] ||
	    ![catch {selection get -displayof $w} txt] ||
	    ![catch {selection get -displayof $w -selection CLIPBOARD} txt]
	} {
	    return $txt
	}
	return -code error &#34;could not find default selection&#34;
    }

    <strong><a name="::tkcon::Cut_5113">proc <a href="tkcon.tcl-annot.html#::tkcon::Cut">::tkcon::Cut</a></a></strong><a name="::tkcon::Cut"></a> w {
	if {[string match $w [selection own -displayof $w]]} {
	    clipboard clear -displayof $w
	    catch {
		set txt [selection get -displayof $w]
		clipboard append -displayof $w $txt
		if {[$w compare sel.first &gt;= limit]} {
		    $w delete sel.first sel.last
		}
	    }
	}
    }
    <strong><a name="::tkcon::Copy_5125">proc <a href="tkcon.tcl-annot.html#::tkcon::Copy">::tkcon::Copy</a></a></strong><a name="::tkcon::Copy"></a> w {
	if {[string match $w [selection own -displayof $w]]} {
	    clipboard clear -displayof $w
	    catch {
		set txt [selection get -displayof $w]
		clipboard append -displayof $w $txt
	    }
	}
    }
    <strong><a name="::tkcon::Paste_5134">proc <a href="tkcon.tcl-annot.html#::tkcon::Paste">::tkcon::Paste</a></a></strong><a name="::tkcon::Paste"></a> w {
	if {![catch {GetSelection $w} txt]} {
	    catch {
		if {[$w compare sel.first &gt;= limit]} {
		    $w delete sel.first sel.last
		}
	    }
	    if {[$w compare insert &lt; limit]} { $w mark set insert end }
	    $w insert insert $txt
	    $w see insert
	    if {[string match *\n* $txt]} { <a name="::tkcon::Eval(1)"><a href="./tkcon.tcl.html#::tkcon::Eval_904">::tkcon::Eval</a></a> $w }
	}
    }

    <font color="#208020">## Redefine for TkConsole what we need</font>
    <font color="#208020">##</font>
    event delete &lt;&lt;Paste&gt;&gt; &lt;Control-V&gt;
    <a name="::tkcon::ClipboardKeysyms(1)"><a href="./tkcon.tcl.html#::tkcon::ClipboardKeysyms_5096">::tkcon::ClipboardKeysyms</a></a> &lt;Copy&gt; &lt;Cut&gt; &lt;Paste&gt;

    bind TkConsole &lt;Insert&gt; {
	catch { <a name="::tkcon::Insert(1)"><a href="./tkcon.tcl.html#::tkcon::Insert_5561">::tkcon::Insert</a></a> %W [<a name="::tkcon::GetSelection(1)"><a href="./tkcon.tcl.html#::tkcon::GetSelection_5102">::tkcon::GetSelection</a></a> %W] }
    }

    bind TkConsole &lt;Triple-1&gt; {+
	catch {
	    eval %W tag remove sel [%W tag nextrange prompt sel.first sel.last]
	    eval %W tag remove sel sel.last-1c
	    %W mark set insert sel.first
	}
    }

    <font color="#208020">## binding editor needed</font>
    <font color="#208020">## binding &lt;events&gt; for .tkconrc</font>

    bind TkConsole &lt;&lt;TkCon_ExpandFile&gt;&gt; {
	if {[%W compare insert &gt; limit]} {<a name="::tkcon::Expand(1)"><a href="./tkcon.tcl.html#::tkcon::Expand_5591">::tkcon::Expand</a></a> %W path}
	break
    }
    bind TkConsole &lt;&lt;TkCon_ExpandProc&gt;&gt; {
	if {[%W compare insert &gt; limit]} {<a name="::tkcon::Expand(2)"><a href="./tkcon.tcl.html#::tkcon::Expand_5591">::tkcon::Expand</a></a> %W proc}
    }
    bind TkConsole &lt;&lt;TkCon_ExpandVar&gt;&gt; {
	if {[%W compare insert &gt; limit]} {<a name="::tkcon::Expand(3)"><a href="./tkcon.tcl.html#::tkcon::Expand_5591">::tkcon::Expand</a></a> %W var}
    }
    bind TkConsole &lt;&lt;TkCon_Expand&gt;&gt; {
	if {[%W compare insert &gt; limit]} {<a name="::tkcon::Expand(4)"><a href="./tkcon.tcl.html#::tkcon::Expand_5591">::tkcon::Expand</a></a> %W}
    }
    bind TkConsole &lt;&lt;TkCon_Tab&gt;&gt; {
	if {[%W compare insert &gt;= limit]} {
	    <a name="::tkcon::Insert(2)"><a href="./tkcon.tcl.html#::tkcon::Insert_5561">::tkcon::Insert</a></a> %W \t
	}
    }
    bind TkConsole &lt;&lt;TkCon_Newline&gt;&gt; {
	if {[%W compare insert &gt;= limit]} {
	    <a name="::tkcon::Insert(3)"><a href="./tkcon.tcl.html#::tkcon::Insert_5561">::tkcon::Insert</a></a> %W \n
	}
    }
    bind TkConsole &lt;&lt;TkCon_Eval&gt;&gt; {
	<a name="::tkcon::Eval(2)"><a href="./tkcon.tcl.html#::tkcon::Eval_904">::tkcon::Eval</a></a> %W
    }
    bind TkConsole &lt;Delete&gt; {
	if {[llength [%W tag nextrange sel 1.0 end]] \
		&amp;&amp; [%W compare sel.first &gt;= limit]} {
	    %W delete sel.first sel.last
	} elseif {[%W compare insert &gt;= limit]} {
	    %W delete insert
	    %W see insert
	}
    }
    bind TkConsole &lt;BackSpace&gt; {
	if {[llength [%W tag nextrange sel 1.0 end]] \
		&amp;&amp; [%W compare sel.first &gt;= limit]} {
	    %W delete sel.first sel.last
	} elseif {[%W compare insert != 1.0] &amp;&amp; [%W compare insert &gt; limit]} {
	    %W delete insert-1c
	    %W see insert
	}
    }
    bind TkConsole &lt;Control-h&gt; [bind TkConsole &lt;BackSpace&gt;]

    bind TkConsole &lt;KeyPress&gt; {
	<a name="::tkcon::Insert(4)"><a href="./tkcon.tcl.html#::tkcon::Insert_5561">::tkcon::Insert</a></a> %W %A
    }

    bind TkConsole &lt;Control-a&gt; {
	if {[%W compare {limit linestart} == {insert linestart}]} {
	    tkTextSetCursor %W limit
	} else {
	    tkTextSetCursor %W {insert linestart}
	}
    }
    bind TkConsole &lt;Key-Home&gt; [bind TkConsole &lt;Control-a&gt;]
    bind TkConsole &lt;Control-d&gt; {
	if {[%W compare insert &lt; limit]} break
	%W delete insert
    }
    bind TkConsole &lt;Control-k&gt; {
	if {[%W compare insert &lt; limit]} break
	if {[%W compare insert == {insert lineend}]} {
	    %W delete insert
	} else {
	    %W delete insert {insert lineend}
	}
    }
    bind TkConsole &lt;&lt;TkCon_Clear&gt;&gt; {
	<font color="#208020">## Clear console buffer, without losing current command line input</font>
	set ::tkcon::PRIV(tmp) [<a name="::tkcon::CmdGet(12)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> %W]
	<a name="clear(2)"><a href="./tkcon.tcl.html#clear_3900">clear</a></a>
	<a name="::tkcon::Prompt(2)"><a href="./tkcon.tcl.html#::tkcon::Prompt_1309">::tkcon::Prompt</a></a> {} $::tkcon::PRIV(tmp)
    }
    bind TkConsole &lt;&lt;TkCon_Previous&gt;&gt; {
	if {[%W compare {insert linestart} != {limit linestart}]} {
	    tkTextSetCursor %W [tkTextUpDownLine %W -1]
	} else {
	    <a name="::tkcon::Event(1)"><a href="./tkcon.tcl.html#::tkcon::Event_2826">::tkcon::Event</a></a> -1
	}
    }
    bind TkConsole &lt;&lt;TkCon_Next&gt;&gt; {
	if {[%W compare {insert linestart} != {end-1c linestart}]} {
	    tkTextSetCursor %W [tkTextUpDownLine %W 1]
	} else {
	    <a name="::tkcon::Event(2)"><a href="./tkcon.tcl.html#::tkcon::Event_2826">::tkcon::Event</a></a> 1
	}
    }
    bind TkConsole &lt;&lt;TkCon_NextImmediate&gt;&gt;  { <a name="::tkcon::Event(3)"><a href="./tkcon.tcl.html#::tkcon::Event_2826">::tkcon::Event</a></a> 1 }
    bind TkConsole &lt;&lt;TkCon_PreviousImmediate&gt;&gt; { <a name="::tkcon::Event(4)"><a href="./tkcon.tcl.html#::tkcon::Event_2826">::tkcon::Event</a></a> -1 }
    bind TkConsole &lt;&lt;TkCon_PreviousSearch&gt;&gt; {
	<a name="::tkcon::Event(5)"><a href="./tkcon.tcl.html#::tkcon::Event_2826">::tkcon::Event</a></a> -1 [<a name="::tkcon::CmdGet(13)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> %W]
    }
    bind TkConsole &lt;&lt;TkCon_NextSearch&gt;&gt;	    {
	<a name="::tkcon::Event(6)"><a href="./tkcon.tcl.html#::tkcon::Event_2826">::tkcon::Event</a></a> 1 [<a name="::tkcon::CmdGet(14)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> %W]
    }
    bind TkConsole &lt;&lt;TkCon_Transpose&gt;&gt;	{
	<font color="#208020">## Transpose current and previous chars</font>
	if {[%W compare insert &gt; &#34;limit+1c&#34;]} { tkTextTranspose %W }
    }
    bind TkConsole &lt;&lt;TkCon_ClearLine&gt;&gt; {
	<font color="#208020">## Clear command line (Unix shell staple)</font>
	%W delete limit end
    }
    bind TkConsole &lt;&lt;TkCon_SaveCommand&gt;&gt; {
	<font color="#208020">## Save command buffer (swaps with current command)</font>
	set ::tkcon::PRIV(tmp) $::tkcon::PRIV(cmdsave)
	set ::tkcon::PRIV(cmdsave) [<a name="::tkcon::CmdGet(15)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> %W]
	if {[string match {} $::tkcon::PRIV(cmdsave)]} {
	    set ::tkcon::PRIV(cmdsave) $::tkcon::PRIV(tmp)
	} else {
	    %W delete limit end-1c
	}
	<a name="::tkcon::Insert(5)"><a href="./tkcon.tcl.html#::tkcon::Insert_5561">::tkcon::Insert</a></a> %W $::tkcon::PRIV(tmp)
	%W see end
    }
    catch {bind TkConsole &lt;Key-Page_Up&gt;   { tkTextScrollPages %W -1 }}
    catch {bind TkConsole &lt;Key-Prior&gt;     { tkTextScrollPages %W -1 }}
    catch {bind TkConsole &lt;Key-Page_Down&gt; { tkTextScrollPages %W 1 }}
    catch {bind TkConsole &lt;Key-Next&gt;      { tkTextScrollPages %W 1 }}
    bind TkConsole &lt;$PRIV(meta)-d&gt; {
	if {[%W compare insert &gt;= limit]} {
	    %W delete insert {insert wordend}
	}
    }
    bind TkConsole &lt;$PRIV(meta)-BackSpace&gt; {
	if {[%W compare {insert -1c wordstart} &gt;= limit]} {
	    %W delete {insert -1c wordstart} insert
	}
    }
    bind TkConsole &lt;$PRIV(meta)-Delete&gt; {
	if {[%W compare insert &gt;= limit]} {
	    %W delete insert {insert wordend}
	}
    }
    bind TkConsole &lt;ButtonRelease-2&gt; {
	if {
	    (!$tkPriv(mouseMoved) || $tk_strictMotif) &amp;&amp;
	    ![catch {<a name="::tkcon::GetSelection(2)"><a href="./tkcon.tcl.html#::tkcon::GetSelection_5102">::tkcon::GetSelection</a></a> %W} ::tkcon::PRIV(tmp)]
	} {
	    if {[%W compare @%x,%y &lt; limit]} {
		%W insert end $::tkcon::PRIV(tmp)
	    } else {
		%W insert @%x,%y $::tkcon::PRIV(tmp)
	    }
	    if {[string match *\n* $::tkcon::PRIV(tmp)]} {<a name="::tkcon::Eval(3)"><a href="./tkcon.tcl.html#::tkcon::Eval_904">::tkcon::Eval</a></a> %W}
	}
    }

    <font color="#208020">##</font>
    <font color="#208020">## End TkConsole bindings</font>
    <font color="#208020">##</font>

    <font color="#208020">##</font>
    <font color="#208020">## Bindings for doing special things based on certain keys</font>
    <font color="#208020">##</font>
    bind TkConsolePost &lt;Key-parenright&gt; {
	if {$::tkcon::OPT(lightbrace) &amp;&amp; $::tkcon::OPT(blinktime)&gt;99 &amp;&amp; \
		[string compare \\ [%W get insert-2c]]} {
	    <a name="::tkcon::MatchPair(1)"><a href="./tkcon.tcl.html#::tkcon::MatchPair_5482">::tkcon::MatchPair</a></a> %W \( \) limit
	}
	set ::tkcon::PRIV(StatusCursor) [%W index insert]
    }
    bind TkConsolePost &lt;Key-bracketright&gt; {
	if {$::tkcon::OPT(lightbrace) &amp;&amp; $::tkcon::OPT(blinktime)&gt;99 &amp;&amp; \
		[string compare \\ [%W get insert-2c]]} {
	    <a name="::tkcon::MatchPair(2)"><a href="./tkcon.tcl.html#::tkcon::MatchPair_5482">::tkcon::MatchPair</a></a> %W \[ \] limit
	}
	set ::tkcon::PRIV(StatusCursor) [%W index insert]
    }
    bind TkConsolePost &lt;Key-braceright&gt; {
	if {$::tkcon::OPT(lightbrace) &amp;&amp; $::tkcon::OPT(blinktime)&gt;99 &amp;&amp; \
		[string compare \\ [%W get insert-2c]]} {
	    <a name="::tkcon::MatchPair(3)"><a href="./tkcon.tcl.html#::tkcon::MatchPair_5482">::tkcon::MatchPair</a></a> %W \{ \} limit
	}
	set ::tkcon::PRIV(StatusCursor) [%W index insert]
    }
    bind TkConsolePost &lt;Key-quotedbl&gt; {
	if {$::tkcon::OPT(lightbrace) &amp;&amp; $::tkcon::OPT(blinktime)&gt;99 &amp;&amp; \
		[string compare \\ [%W get insert-2c]]} {
	    <a name="::tkcon::MatchQuote(1)"><a href="./tkcon.tcl.html#::tkcon::MatchQuote_5520">::tkcon::MatchQuote</a></a> %W limit
	}
	set ::tkcon::PRIV(StatusCursor) [%W index insert]
    }

    bind TkConsolePost &lt;KeyPress&gt; {
	if {[winfo exists &#34;%W&#34;]} {
	    if {$::tkcon::OPT(lightcmd) &amp;&amp; [string compare {} %A]} {
		<a name="::tkcon::TagProc(1)"><a href="./tkcon.tcl.html#::tkcon::TagProc_5453">::tkcon::TagProc</a></a> %W
	    }
	    set ::tkcon::PRIV(StatusCursor) [%W index insert]
	}
    }

    bind TkConsolePost &lt;Button-1&gt; {
	set ::tkcon::PRIV(StatusCursor) [%W index insert]
    }
    bind TkConsolePost &lt;B1-Motion&gt; {
	set ::tkcon::PRIV(StatusCursor) [%W index insert]
    }

}

<font color="#208020">##</font>
<font color="#208020"># ::tkcon::PopupMenu - what to do when the popup menu is requested</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::PopupMenu_5376">proc <a href="tkcon.tcl-annot.html#::tkcon::PopupMenu">::tkcon::PopupMenu</a></a></strong><a name="::tkcon::PopupMenu"></a> {X Y} {
    variable PRIV
    variable OPT

    set w $PRIV(console)
    if {[string compare $w [winfo containing $X $Y]]} {
	tk_popup $PRIV(popup) $X $Y
	return
    }
    set x [expr {$X-[winfo rootx $w]}]
    set y [expr {$Y-[winfo rooty $w]}]
    if {[llength [set tags [$w tag names @$x,$y]]]} {
	if {[lsearch -exact $tags &#34;proc&#34;] &gt;= 0} {
	    lappend type &#34;proc&#34;
	    foreach {first last} [$w tag prevrange proc @$x,$y] {
		set word [$w get $first $last]; break
	    }
	}
	if {[lsearch -exact $tags &#34;var&#34;] &gt;= 0} {
	    lappend type &#34;var&#34;
	    foreach {first last} [$w tag prevrange var @$x,$y] {
		set word [$w get $first $last]; break
	    }
	}
    }
    if {![info exists type]} {
	set exp &#34;(^|\[^\\\\\]\[ \t\n\r\])&#34;
	set exp2 &#34;\[\[\\\\\\?\\*\]&#34;
	set i [$w search -backwards -regexp $exp @$x,$y &#34;@$x,$y linestart&#34;]
	if {[string compare {} $i]} {
	    if {![string match *.0 $i]} {append i +2c}
	    if {[string compare {} \
		    [set j [$w search -regexp $exp $i &#34;$i lineend&#34;]]]} {
		append j +1c
	    } else {
		set j &#34;$i lineend&#34;
	    }
	    regsub -all $exp2 [$w get $i $j] {\\\0} word
	    set word [string trim $word {\&#34;$[]{}',?#*}]
	    if {[llength [EvalAttached [list info commands $word]]]} {
		lappend type &#34;proc&#34;
	    }
	    if {[llength [EvalAttached [list info vars $word]]]} {
		lappend type &#34;var&#34;
	    }
	    if {[EvalAttached [list file isfile $word]]} {
		lappend type &#34;file&#34;
	    }
	}
    }
    if {![info exists type] || ![info exists word]} {
	tk_popup $PRIV(popup) $X $Y
	return
    }
    $PRIV(context) delete 0 end
    $PRIV(context) add command -label &#34;$word&#34; -state disabled
    $PRIV(context) add separator
    set app [Attach]
    if {[lsearch $type proc] != -1} {
	$PRIV(context) add command -label &#34;View Procedure&#34; \
		-command [list $OPT(edit) -attach $app -type proc -- $word]
    }
    if {[lsearch $type var] != -1} {
	$PRIV(context) add command -label &#34;View Variable&#34; \
		-command [list $OPT(edit) -attach $app -type var -- $word]
    }
    if {[lsearch $type file] != -1} {
	$PRIV(context) add command -label &#34;View File&#34; \
		-command [list $OPT(edit) -attach $app -type file -- $word]
    }
    tk_popup $PRIV(context) $X $Y
}

<font color="#208020">## ::tkcon::TagProc - tags a procedure in the console if it's recognized</font>
<font color="#208020">## This procedure is not perfect.  However, making it perfect wastes</font>
<font color="#208020">## too much CPU time...</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::TagProc_5453">proc <a href="tkcon.tcl-annot.html#::tkcon::TagProc">::tkcon::TagProc</a></a></strong><a name="::tkcon::TagProc"></a> w {
    set exp &#34;\[^\\\\\]\[\[ \t\n\r\;{}\&#34;\$\]&#34;
    set i [$w search -backwards -regexp $exp insert-1c limit-1c]
    if {[string compare {} $i]} {append i +2c} else {set i limit}
    regsub -all &#34;\[\[\\\\\\?\\*\]&#34; [$w get $i &#34;insert-1c wordend&#34;] {\\\0} c
    if {[llength [EvalAttached [list info commands $c]]]} {
	$w tag add proc $i &#34;insert-1c wordend&#34;
    } else {
	$w tag remove proc $i &#34;insert-1c wordend&#34;
    }
    if {[llength [EvalAttached [list info vars $c]]]} {
	$w tag add var $i &#34;insert-1c wordend&#34;
    } else {
	$w tag remove var $i &#34;insert-1c wordend&#34;
    }
}

<font color="#208020">## ::tkcon::MatchPair - blinks a matching pair of characters</font>
<font color="#208020">## c2 is assumed to be at the text index 'insert'.</font>
<font color="#208020">## This proc is really loopy and took me an hour to figure out given</font>
<font color="#208020">## all possible combinations with escaping except for escaped \'s.</font>
<font color="#208020">## It doesn't take into account possible commenting... Oh well.  If</font>
<font color="#208020">## anyone has something better, I'd like to see/use it.  This is really</font>
<font color="#208020">## only efficient for small contexts.</font>
<font color="#208020"># ARGS:	w	- console text widget</font>
<font color="#208020"># 	c1	- first char of pair</font>
<font color="#208020"># 	c2	- second char of pair</font>
<font color="#208020"># Calls:	::tkcon::Blink</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::MatchPair_5482">proc <a href="tkcon.tcl-annot.html#::tkcon::MatchPair">::tkcon::MatchPair</a></a></strong><a name="::tkcon::MatchPair"></a> {w c1 c2 {lim 1.0}} {
    if {[string compare {} [set ix [$w search -back $c1 insert $lim]]]} {
	while {
	    [string match {\\} [$w get $ix-1c]] &amp;&amp;
	    [string compare {} [set ix [$w search -back $c1 $ix-1c $lim]]]
	} {}
	set i1 insert-1c
	while {[string compare {} $ix]} {
	    set i0 $ix
	    set j 0
	    while {[string compare {} [set i0 [$w search $c2 $i0 $i1]]]} {
		append i0 +1c
		if {[string match {\\} [$w get $i0-2c]]} continue
		incr j
	    }
	    if {!$j} break
	    set i1 $ix
	    while {$j &amp;&amp; [string compare {} \
		    [set ix [$w search -back $c1 $ix $lim]]]} {
		if {[string match {\\} [$w get $ix-1c]]} continue
		incr j -1
	    }
	}
	if {[string match {} $ix]} { set ix [$w index $lim] }
    } else { set ix [$w index $lim] }
    if {$::tkcon::OPT(blinkrange)} {
	Blink $w $ix [$w index insert]
    } else {
	Blink $w $ix $ix+1c [$w index insert-1c] [$w index insert]
    }
}

<font color="#208020">## ::tkcon::MatchQuote - blinks between matching quotes.</font>
<font color="#208020">## Blinks just the quote if it's unmatched, otherwise blinks quoted string</font>
<font color="#208020">## The quote to match is assumed to be at the text index 'insert'.</font>
<font color="#208020"># ARGS:	w	- console text widget</font>
<font color="#208020"># Calls:	::tkcon::Blink</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::MatchQuote_5520">proc <a href="tkcon.tcl-annot.html#::tkcon::MatchQuote">::tkcon::MatchQuote</a></a></strong><a name="::tkcon::MatchQuote"></a> {w {lim 1.0}} {
    set i insert-1c
    set j 0
    while {[string compare [set i [$w search -back \&#34; $i $lim]] {}]} {
	if {[string match {\\} [$w get $i-1c]]} continue
	if {!$j} {set i0 $i}
	incr j
    }
    if {$j&amp;1} {
	if {$::tkcon::OPT(blinkrange)} {
	    Blink $w $i0 [$w index insert]
	} else {
	    Blink $w $i0 $i0+1c [$w index insert-1c] [$w index insert]
	}
    } else {
	Blink $w [$w index insert-1c] [$w index insert]
    }
}

<font color="#208020">## ::tkcon::Blink - blinks between n index pairs for a specified duration.</font>
<font color="#208020"># ARGS:	w	- console text widget</font>
<font color="#208020"># 	i1	- start index to blink region</font>
<font color="#208020"># 	i2	- end index of blink region</font>
<font color="#208020"># 	dur	- duration in usecs to blink for</font>
<font color="#208020"># Outputs:	blinks selected characters in $w</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::Blink_5546">proc <a href="tkcon.tcl-annot.html#::tkcon::Blink">::tkcon::Blink</a></a></strong><a name="::tkcon::Blink"></a> {w args} {
    eval [list $w tag add blink] $args
    after $::tkcon::OPT(blinktime) [list $w] tag remove blink $args
    return
}


<font color="#208020">## ::tkcon::Insert</font>
<font color="#208020">## Insert a string into a text console at the point of the insertion cursor.</font>
<font color="#208020">## If there is a selection in the text, and it covers the point of the</font>
<font color="#208020">## insertion cursor, then delete the selection before inserting.</font>
<font color="#208020"># ARGS:	w	- text window in which to insert the string</font>
<font color="#208020"># 	s	- string to insert (usually just a single char)</font>
<font color="#208020"># Outputs:	$s to text widget</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::Insert_5561">proc <a href="tkcon.tcl-annot.html#::tkcon::Insert">::tkcon::Insert</a></a></strong><a name="::tkcon::Insert"></a> {w s} {
    if {[string match {} $s] || [string match disabled [$w cget -state]]} {
	return
    }
    variable EXP
    if {[info exists EXP(spawn_id)]} {
	exp_send -i $EXP(spawn_id) -- $s
	return
    }
    if {[$w comp insert &lt; limit]} {
	$w mark set insert end
    }
    if {[llength [$w tag ranges sel]] &amp;&amp; \
	    [$w comp sel.first &lt;= insert] &amp;&amp; [$w comp sel.last &gt;= insert]} {
	$w delete sel.first sel.last
    }
    $w insert insert $s
    $w see insert
}

<font color="#208020">## ::tkcon::Expand - </font>
<font color="#208020"># ARGS:	w	- text widget in which to expand str</font>
<font color="#208020"># 	type	- type of expansion (path / proc / variable)</font>
<font color="#208020"># Calls:	::tkcon::Expand(Pathname|Procname|Variable)</font>
<font color="#208020"># Outputs:	The string to match is expanded to the longest possible match.</font>
<font color="#208020">#		If ::tkcon::OPT(showmultiple) is non-zero and the user longest</font>
<font color="#208020">#		match equaled the string to expand, then all possible matches</font>
<font color="#208020">#		are output to stdout.  Triggers bell if no matches are found.</font>
<font color="#208020"># Returns:	number of matches found</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::Expand_5591">proc <a href="tkcon.tcl-annot.html#::tkcon::Expand">::tkcon::Expand</a></a></strong><a name="::tkcon::Expand"></a> {w {type &#34;&#34;}} {
    set exp &#34;\[^\\\\\]\[\[ \t\n\r\\\{\&#34;$\]&#34;
    set tmp [$w search -backwards -regexp $exp insert-1c limit-1c]
    if {[string compare {} $tmp]} {append tmp +2c} else {set tmp limit}
    if {[$w compare $tmp &gt;= insert]} return
    set str [$w get $tmp insert]
    switch -glob $type {
	pa* { set res [ExpandPathname $str] }
	pr* { set res [ExpandProcname $str] }
	v*  { set res [ExpandVariable $str] }
	default {
	    set res {}
	    foreach t $::tkcon::OPT(expandorder) {
		if {![catch {Expand$t $str} res] &amp;&amp; \
			[string compare {} $res]} break
	    }
	}
    }
    set len [llength $res]
    if {$len} {
	$w delete $tmp insert
	$w insert $tmp [lindex $res 0]
	if {$len &gt; 1} {
	    if {$::tkcon::OPT(showmultiple) &amp;&amp; \
		    ![string compare [lindex $res 0] $str]} {
		puts stdout [lsort [lreplace $res 0 0]]
	    }
	}
    } else { bell }
    return [incr len -1]
}

<font color="#208020">## ::tkcon::ExpandPathname - expand a file pathname based on $str</font>
<font color="#208020">## This is based on UNIX file name conventions</font>
<font color="#208020"># ARGS:	str	- partial file pathname to expand</font>
<font color="#208020"># Calls:	::tkcon::ExpandBestMatch</font>
<font color="#208020"># Returns:	list containing longest unique match followed by all the</font>
<font color="#208020">#		possible further matches</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::ExpandPathname_5630">proc <a href="tkcon.tcl-annot.html#::tkcon::ExpandPathname">::tkcon::ExpandPathname</a></a></strong><a name="::tkcon::ExpandPathname"></a> str {
    set pwd [EvalAttached pwd]
    <font color="#208020"># Cause a string like {C:/Program\ Files/} to become &#34;C:/Program Files/&#34;</font>
    regsub -all {\\([][ ])} $str {\1} str
    if {[catch {EvalAttached [list cd [file dirname $str]]} err]} {
	return -code error $err
    }
    set dir [file tail $str]
    <font color="#208020">## Check to see if it was known to be a directory and keep the trailing</font>
    <font color="#208020">## slash if so (file tail cuts it off)</font>
    if {[string match */ $str]} { append dir / }
    <font color="#208020"># Create a safely glob-able name</font>
    regsub -all {([][])} $dir {\\\1} safedir
    if {[catch {lsort [EvalAttached [list glob $safedir*]]} m]} {
	set match {}
    } else {
	if {[llength $m] &gt; 1} {
	    global tcl_platform
	    if {[string match windows $tcl_platform(platform)]} {
		<font color="#208020">## Windows is screwy because it's case insensitive</font>
		set tmp [ExpandBestMatch [string tolower $m] \
			[string tolower $dir]]
		<font color="#208020">## Don't change case if we haven't changed the word</font>
		if {[string length $dir]==[string length $tmp]} {
		    set tmp $dir
		}
	    } else {
		set tmp [ExpandBestMatch $m $dir]
	    }
	    if {[string match */* $str]} {
		set tmp [string trimright [file dirname $str] /]/$tmp
	    }
	    regsub -all {([^\\])([][ ])} $tmp {\1\\\2} tmp
	    set match [linsert $m 0 $tmp]
	} else {
	    <font color="#208020">## This may look goofy, but it handles spaces in path names</font>
	    eval append match $m
	    if {[file isdirectory $match]} {append match /}
	    if {[string match */* $str]} {
		set match [string trimright [file dirname $str] /]/$match
	    }
	    regsub -all {([^\\])([][ ])} $match {\1\\\2} match
	    <font color="#208020">## Why is this one needed and the ones below aren't!!</font>
	    set match [list $match]
	}
    }
    EvalAttached [list cd $pwd]
    return $match
}

<font color="#208020">## ::tkcon::ExpandProcname - expand a tcl proc name based on $str</font>
<font color="#208020"># ARGS:	str	- partial proc name to expand</font>
<font color="#208020"># Calls:	::tkcon::ExpandBestMatch</font>
<font color="#208020"># Returns:	list containing longest unique match followed by all the</font>
<font color="#208020">#		possible further matches</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::ExpandProcname_5686">proc <a href="tkcon.tcl-annot.html#::tkcon::ExpandProcname">::tkcon::ExpandProcname</a></a></strong><a name="::tkcon::ExpandProcname"></a> str {
    set match [EvalAttached [list info commands $str*]]
    if {[llength $match] == 0} {
	set ns [EvalAttached \
		&#34;namespace children \[namespace current\] [list $str*]&#34;]
	if {[llength $ns]==1} {
	    set match [EvalAttached [list info commands ${ns}::*]]
	} else {
	    set match $ns
	}
    }
    if {[llength $match] &gt; 1} {
	regsub -all {([^\\]) } [ExpandBestMatch $match $str] {\1\\ } str
	set match [linsert $match 0 $str]
    } else {
	regsub -all {([^\\]) } $match {\1\\ } match
    }
    return $match
}

<font color="#208020">## ::tkcon::ExpandXotcl - expand an xotcl method name based on $str</font>
<font color="#208020"># ARGS:	str	- partial proc name to expand</font>
<font color="#208020"># Calls:	::tkcon::ExpandBestMatch</font>
<font color="#208020"># Returns:	list containing longest unique match followed by all the</font>
<font color="#208020">#		possible further matches</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::ExpandXotcl_5712">proc <a href="tkcon.tcl-annot.html#::tkcon::ExpandXotcl">::tkcon::ExpandXotcl</a></a></strong><a name="::tkcon::ExpandXotcl"></a> str {
    <font color="#208020"># in a first step, get the cmd to check, if we should handle subcommands</font>
    set cmd [<a name="::tkcon::CmdGet(16)"><a href="./tkcon.tcl.html#::tkcon::CmdGet_1221">::tkcon::CmdGet</a></a> $::tkcon::PRIV(console)]
    <font color="#208020"># Only do the xotcl magic if there are two cmds and xotcl is loaded</font>
    if {[llength $cmd] != 2
	|| ![EvalAttached [list info exists ::xotcl::version]]} {
	return
    }
    set obj [lindex $cmd 0]
    set sub [lindex $cmd 1]
    set match [EvalAttached [list $obj info methods $sub*]]
    if {[llength $match] &gt; 1} {
	regsub -all {([^\\]) } [ExpandBestMatch $match $str] {\1\\ } str
	set match [linsert $match 0 $str]
    } else {
	regsub -all {([^\\]) } $match {\1\\ } match
    }
    return $match
}

<font color="#208020">## ::tkcon::ExpandVariable - expand a tcl variable name based on $str</font>
<font color="#208020"># ARGS:	str	- partial tcl var name to expand</font>
<font color="#208020"># Calls:	::tkcon::ExpandBestMatch</font>
<font color="#208020"># Returns:	list containing longest unique match followed by all the</font>
<font color="#208020">#		possible further matches</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::ExpandVariable_5738">proc <a href="tkcon.tcl-annot.html#::tkcon::ExpandVariable">::tkcon::ExpandVariable</a></a></strong><a name="::tkcon::ExpandVariable"></a> str {
    if {[regexp {([^\(]*)\((.*)} $str junk ary str]} {
	<font color="#208020">## Looks like they're trying to expand an array.</font>
	set match [EvalAttached [list array names $ary $str*]]
	if {[llength $match] &gt; 1} {
	    set vars $ary\([ExpandBestMatch $match $str]
	    foreach var $match {lappend vars $ary\($var\)}
	    return $vars
	} elseif {[llength $match] == 1} {
	    set match $ary\($match\)
	}
	<font color="#208020">## Space transformation avoided for array names.</font>
    } else {
	set match [EvalAttached [list info vars $str*]]
	if {[llength $match] &gt; 1} {
	    regsub -all {([^\\]) } [ExpandBestMatch $match $str] {\1\\ } str
	    set match [linsert $match 0 $str]
	} else {
	    regsub -all {([^\\]) } $match {\1\\ } match
	}
    }
    return $match
}

<font color="#208020">## ::tkcon::ExpandBestMatch2 - finds the best unique match in a list of names</font>
<font color="#208020">## Improves upon the speed of the below proc only when $l is small</font>
<font color="#208020">## or $e is {}.  $e is extra for compatibility with proc below.</font>
<font color="#208020"># ARGS:	l	- list to find best unique match in</font>
<font color="#208020"># Returns:	longest unique match in the list</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::ExpandBestMatch2_5768">proc <a href="tkcon.tcl-annot.html#::tkcon::ExpandBestMatch2">::tkcon::ExpandBestMatch2</a></a></strong><a name="::tkcon::ExpandBestMatch2"></a> {l {e {}}} {
    set s [lindex $l 0]
    if {[llength $l]&gt;1} {
	set i [expr {[string length $s]-1}]
	foreach l $l {
	    while {$i&gt;=0 &amp;&amp; [string first $s $l]} {
		set s [string range $s 0 [incr i -1]]
	    }
	}
    }
    return $s
}

<font color="#208020">## ::tkcon::ExpandBestMatch - finds the best unique match in a list of names</font>
<font color="#208020">## The extra $e in this argument allows us to limit the innermost loop a</font>
<font color="#208020">## little further.  This improves speed as $l becomes large or $e becomes long.</font>
<font color="#208020"># ARGS:	l	- list to find best unique match in</font>
<font color="#208020"># 	e	- currently best known unique match</font>
<font color="#208020"># Returns:	longest unique match in the list</font>
<font color="#208020">## </font>
<strong><a name="::tkcon::ExpandBestMatch_5788">proc <a href="tkcon.tcl-annot.html#::tkcon::ExpandBestMatch">::tkcon::ExpandBestMatch</a></a></strong><a name="::tkcon::ExpandBestMatch"></a> {l {e {}}} {
    set ec [lindex $l 0]
    if {[llength $l]&gt;1} {
	set e  [string length $e]; incr e -1
	set ei [string length $ec]; incr ei -1
	foreach l $l {
	    while {$ei&gt;=$e &amp;&amp; [string first $ec $l]} {
		set ec [string range $ec 0 [incr ei -1]]
	    }
	}
    }
    return $ec
}

<font color="#208020"># Here is a group of functions that is only used when Tkcon is</font>
<font color="#208020"># executed in a safe interpreter. It provides safe versions of</font>
<font color="#208020"># missing functions. For example:</font>
<font color="#208020">#</font>
<font color="#208020"># - &#34;tk appname&#34; returns &#34;tkcon.tcl&#34; but cannot be set</font>
<font color="#208020"># - &#34;toplevel&#34; is equivalent to 'frame', only it is automatically</font>
<font color="#208020">#   packed.</font>
<font color="#208020"># - The 'source', 'load', 'open', 'file' and 'exit' functions are</font>
<font color="#208020">#   mapped to corresponding functions in the parent interpreter.</font>
<font color="#208020">#</font>
<font color="#208020"># Further on, Tk cannot be really loaded. Still the safe 'load'</font>
<font color="#208020"># provedes a speciall case. The Tk can be divided into 4 groups,</font>
<font color="#208020"># that each has a safe handling procedure.</font>
<font color="#208020">#</font>
<font color="#208020"># - &#34;::tkcon::SafeItem&#34; handles commands like 'button', 'canvas' ......</font>
<font color="#208020">#   Each of these functions has the window name as first argument.</font>
<font color="#208020"># - &#34;::tkcon::SafeManage&#34; handles commands like 'pack', 'place', 'grid',</font>
<font color="#208020">#   'winfo', which can have multiple window names as arguments.</font>
<font color="#208020"># - &#34;::tkcon::SafeWindow&#34; handles all windows, such as '.'. For every</font>
<font color="#208020">#   window created, a new alias is formed which also is handled by</font>
<font color="#208020">#   this function.</font>
<font color="#208020"># - Other (e.g. bind, bindtag, image), which need their own function.</font>
<font color="#208020">#</font>
<font color="#208020">## These functions courtesy Jan Nijtmans</font>
<font color="#208020">##</font>
if {![llength [info commands tk]]} {
    <strong><a name="tk_5828">proc <a href="tkcon.tcl-annot.html#tk">tk</a></a></strong> {option args} {
	if {![string match app* $option]} {
	    error &#34;wrong option \&#34;$option\&#34;: should be appname&#34;
	}
	return &#34;tkcon.tcl&#34;
    }
}

if {![llength [info command toplevel]]} {
    <strong><a name="toplevel_5837">proc <a href="tkcon.tcl-annot.html#toplevel">toplevel</a></a></strong><a name="toplevel"></a> {name args} {
	eval [linsert $args 0 frame $name]
	grid $name -sticky news
    }
}

<strong><a name="::tkcon::SafeSource_5843">proc <a href="tkcon.tcl-annot.html#::tkcon::SafeSource">::tkcon::SafeSource</a></a></strong><a name="::tkcon::SafeSource"></a> {i f} {
    set fd [open $f r]
    set r [read $fd]
    close $fd
    if {[catch {interp eval $i $r} msg]} {
	error $msg
    }
}

<strong><a name="::tkcon::SafeOpen_5852">proc <a href="tkcon.tcl-annot.html#::tkcon::SafeOpen">::tkcon::SafeOpen</a></a></strong><a name="::tkcon::SafeOpen"></a> {i f {m r}} {
    set fd [open $f $m]
    interp transfer {} $fd $i
    return $fd
}

<strong><a name="::tkcon::SafeLoad_5858">proc <a href="tkcon.tcl-annot.html#::tkcon::SafeLoad">::tkcon::SafeLoad</a></a></strong><a name="::tkcon::SafeLoad"></a> {i f p} {
    global tk_version tk_patchLevel tk_library auto_path
    if {[string compare $p Tk]} {
	load $f $p $i
    } else {
	foreach command {button canvas checkbutton entry frame label
	listbox message radiobutton scale scrollbar spinbox text toplevel} {
	    $i alias $command ::tkcon::SafeItem $i $command
	}
	$i alias image ::tkcon::SafeImage $i
	foreach command {pack place grid destroy winfo} {
	    $i alias $command ::tkcon::SafeManage $i $command
	}
	if {[llength [info command event]]} {
	    $i alias event ::tkcon::SafeManage $i $command
	}
	frame .${i}_dot -width 300 -height 300 -relief raised
	pack .${i}_dot -side left
	$i alias tk tk
	$i alias bind ::tkcon::SafeBind $i
	$i alias bindtags ::tkcon::SafeBindtags $i
	$i alias . ::tkcon::SafeWindow $i {}
	foreach var {tk_version tk_patchLevel tk_library auto_path} {
	    $i eval [list set $var [set $var]]
	}
	$i eval {
	    package provide Tk $tk_version
	    if {[lsearch -exact $auto_path $tk_library] &lt; 0} {
		lappend auto_path $tk_library
	    }
	}
	return &#34;&#34;
    }
}

<strong><a name="::tkcon::SafeSubst_5893">proc <a href="tkcon.tcl-annot.html#::tkcon::SafeSubst">::tkcon::SafeSubst</a></a></strong><a name="::tkcon::SafeSubst"></a> {i a} {
    set arg1 &#34;&#34;
    foreach {arg value} $a {
	if {![string compare $arg -textvariable] ||
	![string compare $arg -variable]} {
	    set newvalue &#34;[list $i] $value&#34;
	    global $newvalue
	    if {[interp eval $i info exists $value]} {
		set $newvalue [interp eval $i set $value]
	    } else {
		catch {unset $newvalue}
	    }
	    $i eval trace variable $value rwu \{[list tkcon set $newvalue $i]\}
	    set value $newvalue
	} elseif {![string compare $arg -command]} {
	    set value [list $i eval $value]
	}
	lappend arg1 $arg $value
    }
    return $arg1
}

<strong><a name="::tkcon::SafeItem_5915">proc <a href="tkcon.tcl-annot.html#::tkcon::SafeItem">::tkcon::SafeItem</a></a></strong><a name="::tkcon::SafeItem"></a> {i command w args} {
    set args [<a name="::tkcon::SafeSubst(1)"><a href="./tkcon.tcl.html#::tkcon::SafeSubst_5893">::tkcon::SafeSubst</a></a> $i $args]
    set code [catch &#34;$command [list .${i}_dot$w] $args&#34; msg]
    $i alias $w ::tkcon::SafeWindow $i $w
    regsub -all .${i}_dot $msg {} msg
    return -code $code $msg
}

<strong><a name="::tkcon::SafeManage_5923">proc <a href="tkcon.tcl-annot.html#::tkcon::SafeManage">::tkcon::SafeManage</a></a></strong><a name="::tkcon::SafeManage"></a> {i command args} {
    set args1 &#34;&#34;
    foreach arg $args {
	if {[string match . $arg]} {
	    set arg .${i}_dot
	} elseif {[string match .* $arg]} {
	    set arg &#34;.${i}_dot$arg&#34;
	}
	lappend args1 $arg
    }
    set code [catch &#34;$command $args1&#34; msg]
    regsub -all .${i}_dot $msg {} msg
    return -code $code $msg
}

<font color="#208020">#</font>
<font color="#208020"># FIX: this function doesn't work yet if the binding starts with '+'.</font>
<font color="#208020">#</font>
<strong><a name="::tkcon::SafeBind_5941">proc <a href="tkcon.tcl-annot.html#::tkcon::SafeBind">::tkcon::SafeBind</a></a></strong><a name="::tkcon::SafeBind"></a> {i w args} {
    if {[string match . $w]} {
	set w .${i}_dot
    } elseif {[string match .* $w]} {
	set w &#34;.${i}_dot$w&#34;
    }
    if {[llength $args] &gt; 1} {
	set args [list [lindex $args 0] \
		&#34;[list $i] eval [list [lindex $args 1]]&#34;]
    }
    set code [catch &#34;bind $w $args&#34; msg]
    if {[llength $args] &lt;2 &amp;&amp; $code == 0} {
	set msg [lindex $msg 3]
    }
    return -code $code $msg
}

<strong><a name="::tkcon::SafeImage_5958">proc <a href="tkcon.tcl-annot.html#::tkcon::SafeImage">::tkcon::SafeImage</a></a></strong><a name="::tkcon::SafeImage"></a> {i option args} {
    set code [catch &#34;image $option $args&#34; msg]
    if {[string match cr* $option]} {
	$i alias $msg $msg
    }
    return -code $code $msg
}

<strong><a name="::tkcon::SafeBindtags_5966">proc <a href="tkcon.tcl-annot.html#::tkcon::SafeBindtags">::tkcon::SafeBindtags</a></a></strong><a name="::tkcon::SafeBindtags"></a> {i w {tags {}}} {
    if {[string match . $w]} {
	set w .${i}_dot
    } elseif {[string match .* $w]} {
	set w &#34;.${i}_dot$w&#34;
    }
    set newtags {}
    foreach tag $tags {
	if {[string match . $tag]} {
	    lappend newtags .${i}_dot
	} elseif {[string match .* $tag]} {
	    lappend newtags &#34;.${i}_dot$tag&#34;
	} else {
	    lappend newtags $tag
	}
    }
    if {[string match $tags {}]} {
	set code [catch {bindtags $w} msg]
	regsub -all \\.${i}_dot $msg {} msg
    } else {
	set code [catch {bindtags $w $newtags} msg]
    }
    return -code $code $msg
}

<strong><a name="::tkcon::SafeWindow_5991">proc <a href="tkcon.tcl-annot.html#::tkcon::SafeWindow">::tkcon::SafeWindow</a></a></strong><a name="::tkcon::SafeWindow"></a> {i w option args} {
    if {[string match conf* $option] &amp;&amp; [llength $args] &gt; 1} {
	set args [<a name="::tkcon::SafeSubst(2)"><a href="./tkcon.tcl.html#::tkcon::SafeSubst_5893">::tkcon::SafeSubst</a></a> $i $args]
    } elseif {[string match itemco* $option] &amp;&amp; [llength $args] &gt; 2} {
	set args &#34;[list [lindex $args 0]] [<a name="::tkcon::SafeSubst(3)"><a href="./tkcon.tcl.html#::tkcon::SafeSubst_5893">::tkcon::SafeSubst</a></a> $i [lrange $args 1 end]]&#34;
    } elseif {[string match cr* $option]} {
	if {[llength $args]%2} {
	    set args &#34;[list [lindex $args 0]] [<a name="::tkcon::SafeSubst(4)"><a href="./tkcon.tcl.html#::tkcon::SafeSubst_5893">::tkcon::SafeSubst</a></a> $i [lrange $args 1 end]]&#34;
	} else {
	    set args [<a name="::tkcon::SafeSubst(5)"><a href="./tkcon.tcl.html#::tkcon::SafeSubst_5893">::tkcon::SafeSubst</a></a> $i $args]
	}
    } elseif {[string match bi* $option] &amp;&amp; [llength $args] &gt; 2} {
	set args [list [lindex $args 0] [lindex $args 1] &#34;[list $i] eval [list [lindex $args 2]]&#34;]
    }
    set code [catch &#34;.${i}_dot$w $option $args&#34; msg]
    if {$code} {
	regsub -all .${i}_dot $msg {} msg
    } elseif {[string match conf* $option] || [string match itemco* $option]} {
	if {[llength $args] == 1} {
	    switch -- $args {
		-textvariable - -variable {
		    set msg &#34;[lrange $msg 0 3] [list [lrange [lindex $msg 4] 1 end]]&#34;
		}
		-command - updatecommand {
		    set msg &#34;[lrange $msg 0 3] [list [lindex [lindex $msg 4] 2]]&#34;
		}
	    }
	} elseif {[llength $args] == 0} {
	    set args1 &#34;&#34;
	    foreach el $msg {
		switch -- [lindex $el 0] {
		    -textvariable - -variable {
			set el &#34;[lrange $el 0 3] [list [lrange [lindex $el 4] 1 end]]&#34;
		    }
		    -command - updatecommand {
			set el &#34;[lrange $el 0 3] [list [lindex [lindex $el 4] 2]]&#34;
		    }
		}
		lappend args1 $el
	    }
	    set msg $args1
	}
    } elseif {[string match cg* $option] || [string match itemcg* $option]} {
	switch -- $args {
	    -textvariable - -variable {
		set msg [lrange $msg 1 end]
	    }
	    -command - updatecommand {
		set msg [lindex $msg 2]
	    }
	}
    } elseif {[string match bi* $option]} {
	if {[llength $args] == 2 &amp;&amp; $code == 0} {
	    set msg [lindex $msg 2]
	}
    }
    return -code $code $msg
}

<strong><a name="::tkcon::RetrieveFilter_6050">proc <a href="tkcon.tcl-annot.html#::tkcon::RetrieveFilter">::tkcon::RetrieveFilter</a></a></strong><a name="::tkcon::RetrieveFilter"></a> {host} {
    variable PRIV
    set result {}
    if {[info exists PRIV(proxy)]} {
	if {![regexp &#34;^(localhost|127\.0\.0\.1)&#34; $host]} {
	    set result [lrange [split [lindex $PRIV(proxy) 0] :] 0 1]
	}
    }
    return $result
}

<strong><a name="::tkcon::RetrieveAuthentication_6061">proc <a href="tkcon.tcl-annot.html#::tkcon::RetrieveAuthentication">::tkcon::RetrieveAuthentication</a></a></strong><a name="::tkcon::RetrieveAuthentication"></a> {} {
    package require Tk
    if {[catch {package require base64}]} {
        if {[catch {package require Trf}]} {
            error &#34;base64 support not available&#34;
        } else {
            set local64 &#34;base64 -mode enc&#34;
        }
    } else {
        set local64 &#34;base64::encode&#34;
    }

    set dlg [<a name="toplevel(12)"><a href="./tkcon.tcl.html#toplevel_5837">toplevel</a></a> .auth]
    wm title $dlg &#34;Authenticating Proxy Configuration&#34;
    set f1 [frame ${dlg}.f1]
    set f2 [frame ${dlg}.f2]
    button $f2.b -text &#34;OK&#34; -command &#34;destroy $dlg&#34;
    pack $f2.b -side right
    label $f1.l2 -text &#34;Username&#34;
    label $f1.l3 -text &#34;Password&#34;
    entry $f1.e2 -textvariable &#34;[namespace current]::conf_userid&#34;
    entry $f1.e3 -textvariable &#34;[namespace current]::conf_passwd&#34; -show *
    grid $f1.l2 -column 0 -row 0 -sticky e
    grid $f1.l3 -column 0 -row 1 -sticky e
    grid $f1.e2 -column 1 -row 0 -sticky news
    grid $f1.e3 -column 1 -row 1 -sticky news
    grid columnconfigure $f1 1 -weight 1
    pack $f2 -side bottom -fill x
    pack $f1 -side top -anchor n -fill both -expand 1
    tkwait window $dlg
    set result {}
    if {[info exists [namespace current]::conf_userid]} {
	set data [subst $[namespace current]::conf_userid]
	append data : [subst $[namespace current]::conf_passwd]
	set data [$local64 $data]
	set result [list &#34;Proxy-Authorization&#34; &#34;Basic $data&#34;]
    }
    unset [namespace current]::conf_passwd
    return $result
}

<strong><a name="::tkcon::Retrieve_6102">proc <a href="tkcon.tcl-annot.html#::tkcon::Retrieve">::tkcon::Retrieve</a></a></strong><a name="::tkcon::Retrieve"></a> {} {
    <font color="#208020"># A little bit'o'magic to grab the latest tkcon from CVS and</font>
    <font color="#208020"># save it locally.  It doesn't support proxies though...</font>
    variable PRIV

    set defExt &#34;&#34;
    if {[string match &#34;windows&#34; $::tcl_platform(platform)]} {
	set defExt &#34;.tcl&#34;
    }
    set file [tk_getSaveFile -title &#34;Save Latest tkcon to ...&#34; \
	    -defaultextension $defExt \
	    -initialdir  [file dirname $PRIV(SCRIPT)] \
	    -initialfile [file tail $PRIV(SCRIPT)] \
	    -parent $PRIV(root) \
	    -filetypes {{&#34;Tcl Files&#34; {.tcl .tk}} {&#34;All Files&#34; {*.*}}}]
    if {[string compare $file &#34;&#34;]} {
	package require http 2
	set headers {}
	if {[info exists PRIV(proxy)]} {
	    ::http::config -proxyfilter [namespace origin RetrieveFilter]
	    if {[lindex $PRIV(proxy) 1] != {}} {
		set headers [RetrieveAuthentication]
	    }
	}
	set token [::http::geturl $PRIV(HEADURL) \
		-headers $headers -timeout 30000]
	set token [::http::geturl $PRIV(HEADURL) -timeout 30000]
	::http::wait $token
	set code [catch {
	    set ncode [::http::ncode $token]
	    if {$ncode != 200} {
		return &#34;expected http return code 200, received $ncode&#34;
	    }
	    set status [::http::status $token]
	    if {$status == &#34;ok&#34;} {
		set data [::http::data $token]
		regexp {Id: tkcon.tcl,v (\d+\.\d+)} $data -&gt; rcsVersion
		regexp {VERSION\s+"(\d+\.\d+[^\"]*)"} $data -&gt; tkconVersion
		if {(![info exists rcsVersion] || ![info exists tkconVersion])
		    &amp;&amp; [tk_messageBox -type yesno -icon warning \
			    -parent $PRIV(root) \
			    -title &#34;Invalid tkcon source code&#34; \
			    -message &#34;Source code retrieved does not appear\
			to be correct.\nContinue with save to \&#34;$file\&#34;?&#34;] \
			== &#34;no&#34;} {
		    return &#34;invalid tkcon source code retrieved&#34;
		}
		set fid [open $file w]
		<font color="#208020"># We don't want newline mode to change</font>
		fconfigure $fid -translation binary
		puts -nonewline $fid $data
		close $fid
	    } else {
		return &#34;expected http status ok, received $status&#34;
	    }
	} err]
	::http::cleanup $token
	if {$code == 2} {
	    tk_messageBox -type ok -icon info -parent $PRIV(root) \
		    -title &#34;Failed to retrieve source&#34; \
		    -message &#34;Failed to retrieve latest tkcon source:\n$err&#34;
	} elseif {$code} {
	    return -code error $err
	} else {
	    if {![info exists rcsVersion]}   { set rcsVersion   &#34;UNKNOWN&#34; }
	    if {![info exists tkconVersion]} { set tkconVersion &#34;UNKNOWN&#34; }
	    if {[tk_messageBox -type yesno -icon info -parent $PRIV(root) \
		    -title &#34;Retrieved tkcon v$tkconVersion, RCS $rcsVersion&#34; \
		    -message &#34;Successfully retrieved tkcon v$tkconVersion,\
		    RCS $rcsVersion.  Shall I resource (not restart) this\
		    version now?&#34;] == &#34;yes&#34;} {
		set PRIV(SCRIPT) $file
		set PRIV(version) $tkconVersion.$rcsVersion
		<a name="::tkcon::Resource(1)"><a href="./tkcon.tcl.html#::tkcon::Resource_6309">::tkcon::Resource</a></a>
	    }
	}
    }
}

<font color="#208020">## 'send' package that handles multiple communication variants</font>
<font color="#208020">##</font>
<font color="#208020"># Try using Tk send first, then look for a winsend interp,</font>
<font color="#208020"># then try dde and finally have a go at comm</font>
namespace eval ::send {}
<strong><a name="::send::send_6186">proc <a href="tkcon.tcl-annot.html#::send::send">::send::send</a></a></strong><a name="::send::send"></a> {args} {
    set winfoInterpCmd [list ::winfo interps]
    array set opts [list displayof {} async 0]
    while {[string match -* [lindex $args 0]]} {
	switch -exact -- [lindex $args 0] {
	    -displayof {
		set opts(displayof) [Pop args 1]
		lappend winfoInterpCmd -displayof $opts(displayof)
	    }
	    -async     { set opts(async) 1 }
	    -- { Pop args ; break }
	    default {
		return -code error &#34;bad option \&#34;[lindex $args 0]\&#34;:\
		    should be -displayof, -async or --&#34;
	    }
	}
	Pop args
    }
    set app [Pop args]

    if {[llength [info commands ::winfo]]
	&amp;&amp; [lsearch -exact [eval $winfoInterpCmd] $app] &gt; -1} {
	set cmd [list ::send]
	if {$opts(async) == 1} {lappend cmd -async}
	if {$opts(displayof) != {}} {lappend cmd -displayof $opts(displayof)}
	lappend cmd $app
	eval $cmd $args
    } elseif {[llength [info commands ::winsend]]
	      &amp;&amp; [lsearch -exact [::winsend interps] $app] &gt; -1} {
	eval [list ::winsend send $app] $args
    } elseif {[llength [info commands ::dde]]
	      &amp;&amp; [lsearch -exact [dde services TclEval {}] \
		      [list TclEval $app]] &gt; -1} {
	eval [list ::dde eval $app] $args
    } elseif {[package provide comm] != {}
	      &amp;&amp; [regexp {^[0-9]+$} [lindex $app 0]]} {
	<font color="#208020">#if {$opts(displayof) != {} &amp;&amp; [llength $app] == 1} {</font>
	<font color="#208020">#    lappend app $opts(displayof)</font>
	<font color="#208020">#}</font>
	eval [list ::comm::comm send $app] $args
    } else {
	return -code error &#34;bad interp: \&#34;$app\&#34; could not be found&#34;
    }
}

<strong><a name="::send::interps_6231">proc <a href="tkcon.tcl-annot.html#::send::interps">::send::interps</a></a></strong><a name="::send::interps"></a> {args} {
    set winfoInterpCmd [list ::winfo interps]
    array set opts [list displayof {}]
    while {[string match -* [lindex $args 0]]} {
	switch -exact -- [lindex $args 0] {
	    -displayof {
		set opts(displayof) [Pop args 1]
		lappend winfoInterpCmd -displayof $opts(displayof)
	    }
	    --	       { Pop args ; break }
	    default {
		return -code error &#34;bad option \&#34;[lindex $args 0]\&#34;:\
		    should be -displayof or --&#34;
	    }
	}
	Pop args
    }

    set interps {}
    if {[llength [info commands ::winfo]]} {
	set interps [concat $interps [eval $winfoInterpCmd]]
    }
    if {[llength [info commands ::winsend]]} {
	set interps [concat $interps [::winsend interps]]
    }
    if {[llength [info commands ::dde]]} {
	set servers {}
	foreach server [::dde services TclEval {}] {
	    lappend servers [lindex $server 1]
	}
	set interps [concat $interps $servers]
    }
    if {[package provide comm] != {}} {
	set interps [concat $interps [::comm::comm interps]]
    }
    return $interps
}

<strong><a name="::send::appname_6269">proc <a href="tkcon.tcl-annot.html#::send::appname">::send::appname</a></a></strong><a name="::send::appname"></a> {args} {
    set appname {}
    if {[llength [info commands ::tk]]} {
	set appname [eval ::tk appname $args]
    }
    if {[llength [info commands ::winsend]]} {
	set appname [concat $appname [eval ::winsend appname $args]]
    }
    if {[llength [info commands ::dde]]} {
	set appname [concat $appname [eval ::dde servername $args]]
    }
    <font color="#208020"># comm? can set port num and local/global interface.</font>
    return [lsort -unique $appname]
}

<strong><a name="::send::Pop_6284">proc <a href="tkcon.tcl-annot.html#::send::Pop">::send::Pop</a></a></strong><a name="::send::Pop"></a> {varname {nth 0}} {
    upvar $varname args
    set r [lindex $args $nth]
    set args [lreplace $args $nth $nth]
    return $r
}
<font color="#208020">##</font>
<font color="#208020">## end 'send' pacakge</font>

<font color="#208020">## special case 'tk appname' in Tcl plugin</font>
if {$::tkcon::PRIV(WWW)} {
    rename tk ::tkcon::_tk
    <strong><a name="tk_6296">proc <a href="tkcon.tcl-annot.html#tk">tk</a></a></strong><a name="tk"></a> {cmd args} {
	if {$cmd == &#34;appname&#34;} {
	    return &#34;tkcon/WWW&#34;
	} else {
	    return [uplevel 1 ::tkcon::_tk [list $cmd] $args]
	}
    }
}

<font color="#208020">## ::tkcon::Resource - re'source's this script into current console</font>
<font color="#208020">## Meant primarily for my development of this program.  It follows</font>
<font color="#208020">## links until the ultimate source is found.</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::Resource_6309">proc <a href="tkcon.tcl-annot.html#::tkcon::Resource">::tkcon::Resource</a></a></strong><a name="::tkcon::Resource"></a> {} {
    uplevel \#0 {
	if {[catch {source -rsrc tkcon}]} { source $::tkcon::PRIV(SCRIPT) }
    }
    Bindings
    InitSlave $::tkcon::OPT(exec)
}

<font color="#208020">## Initialize only if we haven't yet, and do other stuff that prepares to</font>
<font color="#208020">## run.  It only actually inits (and runs) tkcon if it is the main script.</font>
<font color="#208020">##</font>
<strong><a name="::tkcon::AtSource_6320">proc <a href="tkcon.tcl-annot.html#::tkcon::AtSource">::tkcon::AtSource</a></a></strong><a name="::tkcon::AtSource"></a> {} {
    variable PRIV

    <font color="#208020"># the info script assumes we always call this while being sourced</font>
    set PRIV(SCRIPT) [info script]
    if {!$PRIV(WWW) &amp;&amp; [string length $PRIV(SCRIPT)]} {
	if {[info tclversion] &gt;= 8.4} {
	    set PRIV(SCRIPT) [file normalize $PRIV(SCRIPT)]
	} else {
	    <font color="#208020"># we use a catch here because some wrap apps choke on 'file type'</font>
	    <font color="#208020"># because TclpLstat wasn't wrappable until 8.4.</font>
	    catch {
		while {[string match link [file type $PRIV(SCRIPT)]]} {
		    set link [file readlink $PRIV(SCRIPT)]
		    if {[string match relative [file pathtype $link]]} {
			set PRIV(SCRIPT) \
			    [file join [file dirname $PRIV(SCRIPT)] $link]
		    } else {
			set PRIV(SCRIPT) $link
		    }
		}
		catch {unset link}
		if {[string match relative [file pathtype $PRIV(SCRIPT)]]} {
		    set PRIV(SCRIPT) [file join [pwd] $PRIV(SCRIPT)]
		}
	    }
	}
    }
    <font color="#208020"># normalize argv0 if it was tkcon to ensure that we'll be able</font>
    <font color="#208020"># to load slaves correctly.</font>
    if {[info exists ::argv0] &amp;&amp; [info script] == $::argv0} {
	set ::argv0 $PRIV(SCRIPT)
    }

    if {(![info exists PRIV(root)] || ![winfo exists $PRIV(root)]) \
	    &amp;&amp; (![info exists ::argv0] || $PRIV(SCRIPT) == $::argv0)} {
	global argv
	if {[info exists argv]} {
	    eval ::tkcon::Init $argv
	} else {
	    <a name="::tkcon::Init(2)"><a href="./tkcon.tcl.html#::tkcon::Init_95">::tkcon::Init</a></a>
	}
    }
}
tkcon::AtSource

package provide tkcon $::tkcon::VERSION
</pre>
<hr>
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#byfilename">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a><br>
<cite>File generated 2008-04-03 at 09:49.</cite>
</font>
</body>
</html>
