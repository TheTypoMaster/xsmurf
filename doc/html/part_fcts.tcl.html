<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- Generated by TclDoc 0.3 -->
<html>
<head><title>part_fcts.tcl</title></head>
<body bgcolor="#ffffff">
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#part_fcts.tcl">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a>
</font>
<hr>
<strong>part_fcts.tcl</strong>
(<a href="part_fcts.tcl-annot.html">annotations</a> | <a href="part_fcts.tcl.txt">original source</a>)
<p>
<pre>
<font color="#208020"># part_fcts.tcl --</font>
<font color="#208020">#</font>
<font color="#208020">#       This file implements the Tcl code to handle partition functions.</font>
<font color="#208020">#</font>
<font color="#208020">#   Copyright 1998 Centre de Recherche Paul Pascal, Bordeaux, France.</font>
<font color="#208020">#   Written by Nicolas Decoster.</font>
<font color="#208020">#</font>
<font color="#208020">#  RCS : $Id: part_fcts.tcl,v 1.13 1998/04/22 16:47:53 decoster Exp $</font>
<font color="#208020">#</font>


<font color="#208020"># sw_fqaqtq --</font>
<font color="#208020"># usage : sw_fqaqtq str float int int list str [args]</font>
<font color="#208020">#</font>
<font color="#208020">#  Create partition functions files sw can read with the commands qfile, qget,</font>
<font color="#208020"># etc. These files are create from a serie of ext image from a wavelet</font>
<font color="#208020"># transform.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string  - base name of the ext images.</font>
<font color="#208020">#   float   - first scale of the WT.</font>
<font color="#208020">#   integer - number of octaves.</font>
<font color="#208020">#   integer - number of voices for each octave.</font>
<font color="#208020">#   list    - values of q for the partition functions.</font>
<font color="#208020">#   string  - base name of the resulting files (i.e. name to use in the sw</font>
<font color="#208020">#             command 'qfile').</font>
<font color="#208020">#   args    - any option to pass to command efct.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<font color="#208020"># State : Exp.</font>
<strong><a name="sw_fqaqtq_33">proc <a href="part_fcts.tcl-annot.html#sw_fqaqtq">sw_fqaqtq</a></a></strong><a name="sw_fqaqtq"></a> {name a_min n_oct n_vox q_lst res args} {
    <font color="#208020"># Create general file.</font>
    set res_file [open $res w]
    puts $res_file &#34;noct $n_oct&#34;
    puts $res_file &#34;nvoice $n_vox&#34;
    puts $res_file &#34;wavelet Gauss_dx_dy&#34;
    puts $res_file &#34;amin $a_min&#34;
    foreach q $q_lst {
	puts $res_file $q
    }
    close $res_file

    <font color="#208020"># Create history file.</font>
    set hist_file [open ${res}_history w]
    puts $hist_file &#34;***Computation on a new signal:&#34;
    puts $hist_file &#34;q Values   \[nb = [llength $q_lst]\]:&#34;
    foreach q $q_lst {
	puts -nonewline $hist_file &#34;$q &#34;
    }
    puts $hist_file &#34;&#34;
    puts $hist_file &#34;Signal size : [expr $n_oct*$n_vox]&#34;
    puts $hist_file &#34;Signal name : Gauss_dx_dy&#34;
    puts $hist_file &#34;&#34;
    close $hist_file


    <font color="#208020"># Create data files.</font>
    foreach q $q_lst {
	set q_str [<a name="get_q_str(1)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	catch {exec rm ${res}_Pq.$q_str}
	set Pq_file [open ${res}_Pq.$q_str a+]
	catch {exec rm ${res}_logsP.$q_str}
	set logsP_file [open ${res}_logsP.$q_str a+]
	catch {exec rm ${res}_PqlogP.$q_str}
	set PqlogP_file [open ${res}_PqlogP.$q_str a+]
	for { set oct 0;set num 0}\
		{ $oct &lt; $n_oct} \
		{ incr oct } {
	    for {set vox 0} \
		    { $vox &lt; $n_vox } \
		    { incr vox ; incr num} {
		set new_num [format &#34;%.3d&#34; $num]
		set sPq [eval efct ${name}${new_num} abs(x)^y $q $args]
		puts $Pq_file $sPq
		puts $logsP_file [expr ($sPq?log($sPq):0)]
		puts $PqlogP_file [eval efct ${name}${new_num} log(abs(x))*abs(x)^y $q $args]
	    }
	}
	close $Pq_file
	close $logsP_file
	close $PqlogP_file
    }
    return
}

<font color="#208020">#  Add values to files sw can read with the qfile, qget, etc commands.</font>
<font color="#208020"># NAME is the base name of the ext images. RES is the base name of the</font>
<font color="#208020"># resulting files (i.e. name to use in the sw command 'qfile').</font>
<font color="#208020">#</font>

<font color="#208020"># sw_add_fqaqtq --</font>
<font color="#208020"># usage : sw_fqaqtq str float int int list str [args]</font>
<font color="#208020">#</font>
<font color="#208020">#  Add values to (or create) partition functions files sw can read with the</font>
<font color="#208020"># commands qfile, qget, etc. These files are (were) created from a serie of ext</font>
<font color="#208020"># image from a wavelet transform.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string  - base name of the ext images.</font>
<font color="#208020">#   float   - first scale of the WT.</font>
<font color="#208020">#   integer - number of octaves.</font>
<font color="#208020">#   integer - number of voices for each octave.</font>
<font color="#208020">#   list    - values of q for the partition functions.</font>
<font color="#208020">#   string  - base name of the resulting files (i.e. name to use in the sw</font>
<font color="#208020">#             command 'qfile').</font>
<font color="#208020">#   args    - any option to pass to command efct.</font>
<font color="#208020">#</font>
<font color="#208020"># Warning :</font>
<font color="#208020">#   If the history file doesn't exists, new files are created.</font>
<font color="#208020">#   If it exists, the other files MUST exist. There is no check.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<font color="#208020"># State : Exp.</font>
<strong><a name="sw_add_fqaqtq_119">proc <a href="part_fcts.tcl-annot.html#sw_add_fqaqtq">sw_add_fqaqtq</a></a></strong><a name="sw_add_fqaqtq"></a> {name a_min n_oct n_vox q_lst res args} {
    if {[file exists ${res}_history] == 0} {
	eval sw_fqaqtq $name $a_min $n_oct $n_vox {$q_lst} $res $args
	return
    }


    <font color="#208020"># Update history file.</font>
    set hist_file [open ${res}_history a+]
    puts $hist_file &#34;***Computation on a new signal:&#34;
    puts $hist_file &#34;q Values   \[nb = [llength $q_lst]\]:&#34;
    foreach q $q_lst {
	puts -nonewline $hist_file &#34;$q &#34;
    }
    puts $hist_file &#34;&#34;
    puts $hist_file &#34;Signal size : [expr $n_oct*$n_vox]&#34;
    puts $hist_file &#34;Signal name : Gauss_dx_dy&#34;
    puts $hist_file &#34;&#34;
    close $hist_file


    <font color="#208020"># Update data files.</font>
    foreach q $q_lst {
	set q_str [<a name="get_q_str(2)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	<font color="#208020"># Read existing data.</font>
	set Pq_file [open ${res}_Pq.$q_str r]
	set logsP_file [open ${res}_logsP.$q_str r]
	set PqlogP_file [open ${res}_PqlogP.$q_str r]
	catch {unset Pq_lst}
	catch {unset logsP_lst}
	catch {unset PqlogP_lst}
	for { set oct 0;set num 0}\
		{ $oct &lt; $n_oct} \
		{ incr oct } {
	    for {set vox 0} \
		    { $vox &lt; $n_vox } \
		    { incr vox ; incr num} {
		set new_num [format &#34;%.3d&#34; $num]
		lappend Pq_lst [gets $Pq_file]
		lappend logsP_lst [gets $logsP_file]
		lappend PqlogP_lst [gets $PqlogP_file]
	    }
	}
	close $Pq_file
	close $logsP_file
	close $PqlogP_file

	<font color="#208020"># Add the new data.</font>
	catch {exec rm ${res}_Pq.$q_str}
	set Pq_file [open ${res}_Pq.$q_str a+]
	catch {exec rm ${res}_logsP.$q_str}
	set logsP_file [open ${res}_logsP.$q_str a+]
	catch {exec rm ${res}_PqlogP.$q_str}
	set PqlogP_file [open ${res}_PqlogP.$q_str a+]
	for { set oct 0;set num 0}\
		{ $oct &lt; $n_oct} \
		{ incr oct } {
	    for {set vox 0} \
		    { $vox &lt; $n_vox } \
		    { incr vox ; incr num} {
		set new_num [format &#34;%.3d&#34; $num]
		set sPq [expr [eval efct ${name}${new_num} abs(x)^y $q $args]+[lindex $Pq_lst $num]]
		puts $Pq_file $sPq
		puts $logsP_file [expr ($sPq?log($sPq):0)+[lindex $logsP_lst $num]]
		puts $PqlogP_file [expr [eval efct ${name}${new_num} log(abs(x))*abs(x)^y $q $args]+[lindex $PqlogP_lst $num]]
	    }
	}
	close $Pq_file
	close $logsP_file
	close $PqlogP_file
    }
}

<font color="#208020"># Creates (or update) signals for each value of q that contains the Tq and so</font>
<font color="#208020"># on. NAME is the base name of the ext images. RES is the base name of the</font>
<font color="#208020"># resulting signals.</font>
<font color="#208020">#</font>
<font color="#208020"># State : Exp.</font>
<font color="#208020">#</font>
<strong><a name="sm_fqaqtq_199">proc <a href="part_fcts.tcl-annot.html#sm_fqaqtq">sm_fqaqtq</a></a></strong><a name="sm_fqaqtq"></a> {name a_min n_oct n_vox q_lst res args} {
    foreach q $q_lst {
	set q_str [<a name="get_q_str(3)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	<font color="#208020"># Compute all the lists of points for the signals.</font>
	catch {unset STq_lst}
	catch {unset STq_a_lst}
	catch {unset logSTq_lst}
	catch {unset STqlogT_lst}
	for { set oct 0;set num 0}\
		{ $oct &lt; $n_oct} \
		{ incr oct } {
	    for {set vox 0} \
		    { $vox &lt; $n_vox } \
		    { incr vox ; incr num} {
		set new_num [format &#34;%.3d&#34; $num]
		set STq [eval &#34;efct ${name}${new_num} abs(x)^y $q $args&#34;]
		lappend STq_lst $STq
		lappend logSTq_lst [expr ($STq?log($STq):0)]
		lappend STqlogT_lst [eval &#34;efct ${name}${new_num} log(abs(x))*abs(x)^y $q $args&#34;]
		flush stdout
	    }
	}

	<font color="#208020"># Add the lists to signals.</font>
	if {[string compare [gettype ${res}_STq_$q_str] S]} {
	    screate ${res}_STq_$q_str 1 [expr 1.0/$n_vox] $STq_lst
	} else {
	    screate __tmp 1 [expr 1.0/$n_vox] $STq_lst
	    sadd ${res}_STq_$q_str __tmp ${res}_STq_$q_str
	}

	if {[string compare [gettype ${res}_STqlogT_$q_str] S]} {
	    screate ${res}_STqlogT_$q_str 1 [expr 1.0/$n_vox] $STqlogT_lst
	} else {
	    screate __tmp 1 [expr 1.0/$n_vox] $STqlogT_lst
	    sadd ${res}_STqlogT_$q_str __tmp ${res}_STqlogT_$q_str
	}

	if {[string compare [gettype ${res}_logSTq_$q_str] S]} {
	    screate ${res}_logSTq_$q_str 1 [expr 1.0/$n_vox] $logSTq_lst
	} else {
	    screate __tmp 1 [expr 1.0/$n_vox] $logSTq_lst
	    sadd ${res}_logSTq_$q_str __tmp ${res}_logSTq_$q_str
	}
	catch {delete __tmp}
    }
}

<font color="#208020"># State : Exp.</font>
<font color="#208020">#</font>
<strong><a name="part_load_250">proc <a href="part_fcts.tcl-annot.html#part_load">part_load</a></a></strong><a name="part_load"></a> {q_lst name {options &#34;&#34;}} {
    foreach q $q_lst {
	set q_str [<a name="get_q_str(4)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	sload ${name}$q_str ${name}$q_str $options
    }
}

<font color="#208020"># State : Exp.</font>
<font color="#208020">#</font>
<strong><a name="part_save_259">proc <a href="part_fcts.tcl-annot.html#part_save">part_save</a></a></strong><a name="part_save"></a> {q_lst name {options &#34;&#34;}} {
    foreach q $q_lst {
	set q_str [<a name="get_q_str(5)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	ssave ${name}$q_str $options
    }
}

<font color="#208020"># sw_part_load --</font>
<font color="#208020"># usage : sw_part_load str</font>
<font color="#208020">#</font>
<font color="#208020">#  Read partition functions files in the sw format and create signals for each</font>
<font color="#208020"># partition functions (Pq, logsP and PqlogsP).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - base name of the files (i.e. name used in the sw command 'qfile').</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   A list with the parameters of the wavelet transform : first scale, number</font>
<font color="#208020">#   of octaves, number of voices and the list of the values of q.</font>

<font color="#208020"># State : Exp.</font>
<strong><a name="sw_part_load_280">proc <a href="part_fcts.tcl-annot.html#sw_part_load">sw_part_load</a></a></strong><a name="sw_part_load"></a> {name} {
    <font color="#208020"># Read general file.</font>
    set res_file [open $name r]
    set n_oct [lindex [gets $res_file] 1]
    set n_vox [lindex [gets $res_file] 1]
    gets $res_file
    set a_min [lindex [gets $res_file] 1]
    gets $res_file q
    while {$q != &#34;&#34;} {
	lappend q_lst $q
	gets $res_file q
    }
    close $res_file

    foreach q $q_lst {
	set q_str [<a name="get_q_str(6)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	<font color="#208020"># Read existing data.</font>
	set Pq_file [open ${name}_Pq.$q_str r]
	set logsP_file [open ${name}_logsP.$q_str r]
	set PqlogP_file [open ${name}_PqlogP.$q_str r]
	catch {unset Pq_lst}
	catch {unset logsP_lst}
	catch {unset PqlogP_lst}
	for { set oct 0;set num 0}\
		{ $oct &lt; $n_oct} \
		{ incr oct } {
	    for {set vox 0} \
		    { $vox &lt; $n_vox } \
		    { incr vox ; incr num} {
		set new_num [format &#34;%.3d&#34; $num]
		lappend Pq_lst [gets $Pq_file]
		set val [gets $logsP_file]
		if {[string compare $val &#34;--.-00000e+01&#34;] == 0} {
		    set val 0
		}
		lappend logsP_lst $val
		lappend PqlogP_lst [gets $PqlogP_file]
	    }
	}

	close $Pq_file
	close $logsP_file
	close $PqlogP_file
	screate ${name}_Pq_$q_str 1 [expr 1.0/$n_vox] $Pq_lst
	screate ${name}_logsP_$q_str 1 [expr 1.0/$n_vox] $logsP_lst
	screate ${name}_PqlogP_$q_str 1 [expr 1.0/$n_vox] $PqlogP_lst
    }
    return &#34;$a_min $n_oct $n_vox {$q_lst}&#34;
}

<font color="#208020"># thd --</font>
<font color="#208020"># usage : thd str list</font>
<font color="#208020">#</font>
<font color="#208020">#  Creates signals that contains tau(a), h(a) and D(a) for each value of q. Pq,</font>
<font color="#208020"># logPq and PqlogP signals must have been loaded previously.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - base name of the signals.</font>
<font color="#208020">#   list   - list of the values of q.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   None.</font>

<font color="#208020"># State : Exp.</font>
<strong><a name="thd_344">proc <a href="part_fcts.tcl-annot.html#thd">thd</a></a></strong><a name="thd"></a> {name q_lst} {
    foreach q $q_lst {
	set q_str [<a name="get_q_str(7)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	set STq     ${name}_Pq_$q_str
	set logSTq  ${name}_logPq_$q_str
	set STqlogT ${name}_PqlogP_$q_str

	scomb $STq $STq     log(x)/log(2)              ${name}_tau$q_str -xnull
	scomb $STqlogT $STq x/(log(2)*y)               ${name}_h$q_str   -ynull
	scomb $STqlogT $STq ($q*x-y*log(y))/(y*log(2)) ${name}_D$q_str   -ynull
    }
    return
}

<strong><a name="oldthd_359">proc <a href="part_fcts.tcl-annot.html#oldthd">oldthd</a></a></strong><a name="oldthd"></a> {name a_min n_oct n_vox q_lst res args} {
    eval sm_fqaqtq $name $a_min $n_oct $n_vox $q_lst $res $args
    foreach q $q_lst {
	set q_str [<a name="get_q_str(8)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	set STq     ${res}_STq_$q_str
	set logSTq  ${res}_logSTq_$q_str
	set STqlogT ${res}_STqlogT_$q_str
	set STq_a   ${res}_STq_a_$q_str

	scomb $STq $STq     log(x)/log(2)              ${res}_tau$q_str
	scomb $STqlogT $STq x/(log(2)*y)               ${res}_h$q_str
	scomb $STqlogT $STq ($q*x-y*log(y))/(y*log(2)) ${res}_D$q_str
    }
}

<font color="#208020"># tq --</font>
<font color="#208020"># Creates a signal that contains tau(q).</font>

<strong><a name="tq_378">proc <a href="part_fcts.tcl-annot.html#tq">tq</a></a></strong><a name="tq"></a> {a_min a_max q_lst name} {
    catch {unset fit_lst}
    foreach q $q_lst {
	set q_str [<a name="get_q_str(9)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	set fit [sfit ${name}_tau$q_str $a_min $a_max]
	lappend fit_lst [lindex $fit 0]
    }
    screate ${name}_tq [lindex $q_lst 0] 1 $fit_lst -xy $q_lst
}

<font color="#208020"># Dq --</font>
<font color="#208020"># Creates a signal that contains D(q).</font>

<strong><a name="Dq_392">proc <a href="part_fcts.tcl-annot.html#Dq">Dq</a></a></strong><a name="Dq"></a> {a_min a_max q_lst name} {
    catch {unset D_fit_lst}
    foreach q $q_lst {
	<a name="dputs(1)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;q = $q.&#34;
	set q_str [<a name="get_q_str(10)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	set D_fit [sfit ${name}_D$q_str $a_min $a_max]
	lappend D_fit_lst [expr [lindex $D_fit 0]+1]
    }
    screate ${name}_Dq [lindex $q_lst 0] 1 $D_fit_lst
}

<font color="#208020"># hq --</font>
<font color="#208020"># Creates a signal that contains h(q).</font>

<strong><a name="hq_407">proc <a href="part_fcts.tcl-annot.html#hq">hq</a></a></strong><a name="hq"></a> {a_min a_max q_lst name} {
    catch {unset h_fit_lst}
    foreach q $q_lst {
	<a name="dputs(2)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;q = $q.&#34;
	set q_str [<a name="get_q_str(11)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	set h_fit [sfit ${name}_h$q_str $a_min $a_max]
	lappend h_fit_lst [lindex $h_fit 0]
    }
    screate ${name}_hq [lindex $q_lst 0] 1 $h_fit_lst
}

<font color="#208020"># Displays the NAME signals for all the values of q (m1p00, 0p00, 1p00, etc).</font>
<font color="#208020">#</font>
<strong><a name="paff_421">proc <a href="part_fcts.tcl-annot.html#paff">paff</a></a></strong><a name="paff"></a> {name} {
    eval &#34;nsaff [lsort -decreasing [ginfo ${name}m* -list]] [lsort [ginfo ${name}?p* -list]]&#34;
}

<font color="#208020">#</font>
<font color="#208020"># Partition functions for images.</font>
<font color="#208020">#</font>

<font color="#208020"># isw_fqaqtq_one --</font>
<font color="#208020">#  Create files sw can read with the qfile, qget, etc commands.</font>
<font color="#208020"># NAME is the base name of the ext images. RES is the base name of the</font>
<font color="#208020"># resulting files (i.e. name to use in the sw command 'qfile').</font>
<font color="#208020">#</font>
<font color="#208020"># State : Exp.</font>
<font color="#208020">#</font>
<strong><a name="isw_fqaqtq_one_436">proc <a href="part_fcts.tcl-annot.html#isw_fqaqtq_one">isw_fqaqtq_one</a></a></strong><a name="isw_fqaqtq_one"></a> {name a_min n_oct n_vox index q_lst res args} {

    <font color="#208020"># Create general file.</font>
    set res_file [open $res w]
    puts $res_file &#34;noct $n_oct&#34;
    puts $res_file &#34;nvoice $n_vox&#34;
    puts $res_file &#34;wavelet Gauss_dx_dy&#34;
    puts $res_file &#34;amin $a_min&#34;
    foreach q $q_lst {
	puts $res_file $q
    }
    close $res_file

    <font color="#208020"># Create history file.</font>
    set hist_file [open ${res}_history w]
    puts $hist_file &#34;***Computation on a new signal:&#34;
    puts $hist_file &#34;q Values   \[nb = [llength $q_lst]\]:&#34;
    foreach q $q_lst {
	puts -nonewline $hist_file &#34;$q &#34;
    }
    puts $hist_file &#34;&#34;
    puts $hist_file &#34;Signal size : [expr $n_oct*$n_vox]&#34;
    puts $hist_file &#34;Signal name : Gauss_dx_dy&#34;
    puts $hist_file &#34;&#34;
    close $hist_file


    <font color="#208020"># Create data files.</font>
    foreach q $q_lst {
	set q_str [<a name="get_q_str(12)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	if {$index == 0} {
	    catch {exec rm ${res}_Pq.$q_str}
	    catch {exec rm ${res}_logsP.$q_str}
	    catch {exec rm ${res}_PqlogP.$q_str}
	}
	set Pq_file [open ${res}_Pq.$q_str a+]
	set logsP_file [open ${res}_logsP.$q_str a+]
	set PqlogP_file [open ${res}_PqlogP.$q_str a+]

	set new_num [format &#34;%.3d&#34; $index]
	set sPq [eval ifct ${name}${new_num} abs(x)^y $q $args -domain_out -1e-8 1e-8]
	puts $Pq_file $sPq
	puts $logsP_file [expr ($sPq?log($sPq):0)]
	puts $PqlogP_file [eval ifct ${name}${new_num} log(abs(x))*abs(x)^y $q $args -domain_out -1e-8 1e-8]

	close $Pq_file
	close $logsP_file
	close $PqlogP_file
    }
}

<font color="#208020"># isw_add_fqaqtq_one --</font>
<font color="#208020">#  Add values to files sw can read with the qfile, qget, etc commands.</font>
<font color="#208020"># NAME is the base name of the ext images. RES is the base name of the</font>
<font color="#208020"># resulting files (i.e. name to use in the sw command 'qfile').</font>
<font color="#208020">#</font>
<font color="#208020"># WARNINGS :</font>
<font color="#208020">#    If the file ${res}_history doesn't exists, new files are created.</font>
<font color="#208020">#    If it exists, the other files MUST exist. There is no check.</font>
<font color="#208020">#</font>
<font color="#208020"># State : Exp.</font>
<font color="#208020">#</font>
<strong><a name="isw_add_fqaqtq_one_499">proc <a href="part_fcts.tcl-annot.html#isw_add_fqaqtq_one">isw_add_fqaqtq_one</a></a></strong><a name="isw_add_fqaqtq_one"></a> {name a_min n_oct n_vox index q_lst res args} {
    if {[file exists ${res}_history] == 0} {
	eval isw_fqaqtq_one $name $a_min $n_oct $n_vox $index {$q_lst} $res $args
	return
    }

    if {$index == 0} {
	<font color="#208020"># Update history file.</font>
	set hist_file [open ${res}_history a+]
	puts $hist_file &#34;***Computation on a new signal:&#34;
	puts $hist_file &#34;q Values   \[nb = [llength $q_lst]\]:&#34;
	foreach q $q_lst {
	    puts -nonewline $hist_file &#34;$q &#34;
	}
	puts $hist_file &#34;&#34;
	puts $hist_file &#34;Signal size : [expr $n_oct*$n_vox]&#34;
	puts $hist_file &#34;Signal name : Gauss_dx_dy&#34;
	puts $hist_file &#34;&#34;
	close $hist_file
    }

    <font color="#208020"># Update data files.</font>
    foreach q $q_lst {
	set q_str [<a name="get_q_str(13)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	<font color="#208020"># Read existing data.</font>
	set Pq_file [open ${res}_Pq.$q_str r]
	set logsP_file [open ${res}_logsP.$q_str r]
	set PqlogP_file [open ${res}_PqlogP.$q_str r]
	catch {unset Pq_lst}
	catch {unset logsP_lst}
	catch {unset PqlogP_lst}
	for { set oct 0;set num 0}\
		{ $oct &lt; $n_oct} \
		{ incr oct } {
	    for {set vox 0} \
		    { $vox &lt; $n_vox } \
		    { incr vox ; incr num} {
		set new_num [format &#34;%.3d&#34; $num]
		set Pq [gets $Pq_file]
		if {$Pq != &#34;&#34;} {
		    lappend Pq_lst $Pq
		} else {
		    lappend Pq_lst 0
		}

		set logsP [gets $logsP_file]
		if {$logsP != &#34;&#34;} {
		    lappend logsP_lst $logsP
		} else {
		    lappend logsP_lst 0
		}

		set PqlogP [gets $PqlogP_file]
		if {$PqlogP != &#34;&#34;} {
		    lappend PqlogP_lst $PqlogP
		} else {
		    lappend PqlogP_lst 0
		}
	    }
	}
	close $Pq_file
	close $logsP_file
	close $PqlogP_file

	<font color="#208020"># Add the new data.</font>
	catch {exec rm ${res}_Pq.$q_str}
	set Pq_file [open ${res}_Pq.$q_str a+]
	catch {exec rm ${res}_logsP.$q_str}
	set logsP_file [open ${res}_logsP.$q_str a+]
	catch {exec rm ${res}_PqlogP.$q_str}
	set PqlogP_file [open ${res}_PqlogP.$q_str a+]
	for { set oct 0;set num 0}\
		{ $oct &lt; $n_oct} \
		{ incr oct } {
	    for {set vox 0} \
		    { $vox &lt; $n_vox } \
		    { incr vox ; incr num} {
		set new_num [format &#34;%.3d&#34; $num]
		if {$index == $num} {
		    set sPq [expr [eval ifct ${name}${new_num} abs(x)^y $q $args -domain_out -1e-8 1e-8]+[lindex $Pq_lst $num]]
		    puts $Pq_file $sPq
		    puts $logsP_file [expr ($sPq?log($sPq):0)+[lindex $logsP_lst $num]]
		    puts $PqlogP_file [expr [eval ifct ${name}${new_num} log(abs(x))*abs(x)^y $q $args -domain_out -1e-8 1e-8]+[lindex $PqlogP_lst $num]]
		} else {
		    puts $Pq_file [lindex $Pq_lst $num]
		    puts $logsP_file [lindex $logsP_lst $num]
		    puts $PqlogP_file [lindex $PqlogP_lst $num]
		}
	    }
	}
	close $Pq_file
	close $logsP_file
	close $PqlogP_file
    }
}

<font color="#208020"># Creates (or update) signals for each value of q that contains the Tq and so</font>
<font color="#208020"># on. NAME is the base name of the ext images. RES is the base name of the</font>
<font color="#208020"># resulting signals.</font>
<font color="#208020">#</font>
<font color="#208020"># State : Exp.</font>
<font color="#208020">#</font>
<strong><a name="ism_fqaqtq_602">proc <a href="part_fcts.tcl-annot.html#ism_fqaqtq">ism_fqaqtq</a></a></strong><a name="ism_fqaqtq"></a> {name a_min n_oct n_vox q_lst res args} {
    foreach q $q_lst {
	<a name="dputs(3)"><a href="./new_puts.tcl.html#dputs_12">dputs</a></a> &#34;q = $q&#34;
	set q_str [<a name="get_q_str(14)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	<font color="#208020"># Compute all the lists of points for the signals.</font>
	catch {unset STq_lst}
	catch {unset STq_a_lst}
	catch {unset logSTq_lst}
	catch {unset STqlogT_lst}
	for { set oct 0;set num 0}\
		{ $oct &lt; $n_oct} \
		{ incr oct } {
	    for {set vox 0} \
		    { $vox &lt; $n_vox } \
		    { incr vox ; incr num} {
		set new_num [format &#34;%.3d&#34; $num]
		set STq [eval ifct ${name}${new_num} abs(x)^y $q $args -domain_out -1e-8 1e-8]
		lappend STq_lst $STq
		lappend logSTq_lst [expr ($STq?log($STq):0)]
		lappend STqlogT_lst [eval ifct ${name}${new_num} log(abs(x))*abs(x)^y $q $args -domain_out -1e-8 1e-8]
		puts -nonewline &#34;.&#34;
		flush stdout
	    }
	}

	<font color="#208020"># Add the lists to signals.</font>
	if {[string compare [gettype ${res}_STq_$q_str] S]} {
	    screate ${res}_STq_$q_str 1 [expr 1.0/$n_vox] $STq_lst
	} else {
	    screate __tmp 1 [expr 1.0/$n_vox] $STq_lst
	    sadd ${res}_STq_$q_str __tmp ${res}_STq_$q_str
	}

	if {[string compare [gettype ${res}_STqlogT_$q_str] S]} {
	    screate ${res}_STqlogT_$q_str 1 [expr 1.0/$n_vox] $STqlogT_lst
	} else {
	    screate __tmp 1 [expr 1.0/$n_vox] $STqlogT_lst
	    sadd ${res}_STqlogT_$q_str __tmp ${res}_STqlogT_$q_str
	}

	if {[string compare [gettype ${res}_logSTq_$q_str] S]} {
	    screate ${res}_logSTq_$q_str 1 [expr 1.0/$n_vox] $logSTq_lst
	} else {
	    screate __tmp 1 [expr 1.0/$n_vox] $logSTq_lst
	    sadd ${res}_logSTq_$q_str __tmp ${res}_logSTq_$q_str
	}
	puts &#34;&#34;
	catch {delete __tmp}
    }
}


<font color="#208020">#  Creates signals for each value of q that contains tau(a), h(a) and D(a).</font>
<font color="#208020"># NAME is the base name of the ext images. RES is the base name of the resulting</font>
<font color="#208020"># signals.</font>
<font color="#208020">#</font>
<font color="#208020"># State : Exp.</font>
<font color="#208020">#</font>
<strong><a name="ithd_661">proc <a href="part_fcts.tcl-annot.html#ithd">ithd</a></a></strong><a name="ithd"></a> {name a_min n_oct n_vox q_lst res args} {
    eval ism_fqaqtq $name $a_min $n_oct $n_vox $q_lst $res $args
    foreach q $q_lst {
	set q_str [<a name="get_q_str(15)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]

	set STq     ${res}_STq_$q_str
	set logSTq  ${res}_logSTq_$q_str
	set STqlogT ${res}_STqlogT_$q_str
	set STq_a   ${res}_STq_a_$q_str

	scomb $STq $STq     log(x)/log(2)              ${res}_tau$q_str
	scomb $STqlogT $STq x/(log(2)*y)               ${res}_h$q_str
	scomb $STqlogT $STq ($q*x-y*log(y))/(y*log(2)) ${res}_D$q_str
    }
}

<font color="#208020"># Displays the NAME signals for all the values of q (0p00, 1p00, etc).</font>
<font color="#208020"># but not negative values of q.</font>
<font color="#208020">#</font>
<strong><a name="ipaff_680">proc <a href="part_fcts.tcl-annot.html#ipaff">ipaff</a></a></strong><a name="ipaff"></a> {name} {
    eval &#34;nsaff [lsort -decreasing [lsort [ginfo ${name}?p* -list]]]&#34;
}

<font color="#208020"># get_q_str --</font>
<font color="#208020"># usage : get_q_str float</font>
<font color="#208020">#</font>
<font color="#208020">#  Create a q-formated string from a float.</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   float - value to format.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   The string.</font>
<font color="#208020">#</font>
<font color="#208020"># Examples :</font>
<font color="#208020">#   %get_q_str 1.2</font>
<font color="#208020">#   1p20</font>
<font color="#208020">#   %get_q_str -10.92</font>
<font color="#208020">#   m10p92</font>

<strong><a name="get_q_str_701">proc <a href="part_fcts.tcl-annot.html#get_q_str">get_q_str</a></a></strong><a name="get_q_str"></a> {q} {
    if {[file extension $q] != &#34;&#34;} {
	set q_str [expr int(abs($q))]p[format &#34;%.2d&#34; [expr int(100*[file extension $q])]]
    } else {
	set q_str [expr int(abs($q))]p00
    }
    if {$q &lt; 0} {
	set q_str m$q_str
    }
    return $q_str
}

<strong><a name="oldpdisp_713">proc <a href="part_fcts.tcl-annot.html#oldpdisp">oldpdisp</a></a></strong><a name="oldpdisp"></a> {name} {
    set tau_lst &#34;[lsort -decreasing [ginfo ${name}_taum* -list]] [lsort [ginfo ${name}_tau?p* -list]]&#34;
    set h_lst &#34;[lsort -decreasing [ginfo ${name}_hm* -list]] [lsort [ginfo ${name}_h?p* -list]]&#34;
    set D_lst &#34;[lsort -decreasing [ginfo ${name}_Dm* -list]] [lsort [ginfo ${name}_D?p* -list]]&#34;
    set code [catch {eval &#34;mdisp 2 2 {{$tau_lst} {$h_lst} {$D_lst}}&#34;} result]
    if {$code != 0} {
	error $result $result
    }
    return $result
}

<font color="#208020"># pdisp --</font>
<font color="#208020"># usage : pdisp str [list]</font>
<font color="#208020">#</font>
<font color="#208020">#  Display part functions (tau(a,q), h(a,q), and D(a,q)).</font>
<font color="#208020">#</font>
<font color="#208020"># Parameters :</font>
<font color="#208020">#   string - base name of the part functions.</font>
<font color="#208020">#   list   - list of the values of q to display. The default is all the values.</font>
<font color="#208020">#</font>
<font color="#208020"># Return value :</font>
<font color="#208020">#   Name of the object that handle the window.</font>

<strong><a name="pdisp_736">proc <a href="part_fcts.tcl-annot.html#pdisp">pdisp</a></a></strong><a name="pdisp"></a> {name {q_lst &#34;&#34;}} {
    set completeLst {}
    if {$q_lst == &#34;&#34;} {
	return opdisp $name
    } else {
	set sigLst {}
	foreach q $q_lst {
	    set q_str [<a name="get_q_str(16)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${name}_tau${q_str}]
	}
	set completeLst [lappend completeLst ${sigLst}]
	set sigLst {}
	foreach q $q_lst {
	    set q_str [<a name="get_q_str(17)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${name}_h${q_str}]
	}
	set completeLst [lappend completeLst ${sigLst}]
	set sigLst {}
	foreach q $q_lst {
	    set q_str [<a name="get_q_str(18)"><a href="./part_fcts.tcl.html#get_q_str_701">get_q_str</a></a> $q]
	    set sigLst [lappend sigLst ${name}_D${q_str}]
	}
	set completeLst [lappend completeLst ${sigLst}]
    }

    set code [catch {mdisp 2 2 ${completeLst}} result]
    if {$code != 0} {
	error $result $result
    }
    $result setColorsByList {darkgreen green darkcyan darkblue slateblue darkviolet violet}
    set itemList {}
    foreach value $q_lst {
	set itemList [lappend itemlist [list %c $value]]
    }
    eval $result setLabelsItemsByList $itemList
    ${result}gr0000 set_label {black &#34;tau(a), q = &#34;} allSigLabel
    ${result}gr0100 set_label {black &#34;D(a), q = &#34;} allSigLabel
    ${result}gr0001 set_label {black &#34;h(a), q = &#34;} allSigLabel
    return $result
}
</pre>
<hr>
<font size="-2">
<a href="xsmurf_tcl_lib_intro.html">Overview</a> | Index by:  <a href="index_main.html#byfilename">file name</a> |
<a href="index_main.html#byprocname">procedure name</a> |
<a href="index_main.html#bycall">procedure call</a> |
<a href="index_annot_full.html">annotation</a><br>
<cite>File generated 2008-04-03 at 09:49.</cite>
</font>
</body>
</html>
